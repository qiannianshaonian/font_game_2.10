{
  "code": "import { Pool } from \"../utils/Pool\";\r\nimport { Point } from \"./Point\";\r\nexport class Rectangle {\r\n    constructor(x = 0, y = 0, width = 0, height = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n    get right() {\r\n        return this.x + this.width;\r\n    }\r\n    get bottom() {\r\n        return this.y + this.height;\r\n    }\r\n    setTo(x, y, width, height) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n    reset() {\r\n        this.x = this.y = this.width = this.height = 0;\r\n        return this;\r\n    }\r\n    recover() {\r\n        if (this == Rectangle.TEMP || this == Rectangle.EMPTY) {\r\n            console.log(\"recover Temp or Empty:\", this);\r\n            return;\r\n        }\r\n        Pool.recover(\"Rectangle\", this.reset());\r\n    }\r\n    static create() {\r\n        return Pool.getItemByClass(\"Rectangle\", Rectangle);\r\n    }\r\n    copyFrom(source) {\r\n        this.x = source.x;\r\n        this.y = source.y;\r\n        this.width = source.width;\r\n        this.height = source.height;\r\n        return this;\r\n    }\r\n    contains(x, y) {\r\n        if (this.width <= 0 || this.height <= 0)\r\n            return false;\r\n        if (x >= this.x && x < this.right) {\r\n            if (y >= this.y && y < this.bottom) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    intersects(rect) {\r\n        return !(rect.x > (this.x + this.width) || (rect.x + rect.width) < this.x || rect.y > (this.y + this.height) || (rect.y + rect.height) < this.y);\r\n    }\r\n    intersection(rect, out = null) {\r\n        if (!this.intersects(rect))\r\n            return null;\r\n        out || (out = new Rectangle());\r\n        out.x = Math.max(this.x, rect.x);\r\n        out.y = Math.max(this.y, rect.y);\r\n        out.width = Math.min(this.right, rect.right) - out.x;\r\n        out.height = Math.min(this.bottom, rect.bottom) - out.y;\r\n        return out;\r\n    }\r\n    union(source, out = null) {\r\n        out || (out = new Rectangle());\r\n        this.clone(out);\r\n        if (source.width <= 0 || source.height <= 0)\r\n            return out;\r\n        out.addPoint(source.x, source.y);\r\n        out.addPoint(source.right, source.bottom);\r\n        return this;\r\n    }\r\n    clone(out = null) {\r\n        out || (out = new Rectangle());\r\n        out.x = this.x;\r\n        out.y = this.y;\r\n        out.width = this.width;\r\n        out.height = this.height;\r\n        return out;\r\n    }\r\n    toString() {\r\n        return this.x + \",\" + this.y + \",\" + this.width + \",\" + this.height;\r\n    }\r\n    equals(rect) {\r\n        if (!rect || rect.x !== this.x || rect.y !== this.y || rect.width !== this.width || rect.height !== this.height)\r\n            return false;\r\n        return true;\r\n    }\r\n    addPoint(x, y) {\r\n        this.x > x && (this.width += this.x - x, this.x = x);\r\n        this.y > y && (this.height += this.y - y, this.y = y);\r\n        if (this.width < x - this.x)\r\n            this.width = x - this.x;\r\n        if (this.height < y - this.y)\r\n            this.height = y - this.y;\r\n        return this;\r\n    }\r\n    _getBoundPoints() {\r\n        var rst = Rectangle._temB;\r\n        rst.length = 0;\r\n        if (this.width == 0 || this.height == 0)\r\n            return rst;\r\n        rst.push(this.x, this.y, this.x + this.width, this.y, this.x, this.y + this.height, this.x + this.width, this.y + this.height);\r\n        return rst;\r\n    }\r\n    static _getBoundPointS(x, y, width, height) {\r\n        var rst = Rectangle._temA;\r\n        rst.length = 0;\r\n        if (width == 0 || height == 0)\r\n            return rst;\r\n        rst.push(x, y, x + width, y, x, y + height, x + width, y + height);\r\n        return rst;\r\n    }\r\n    static _getWrapRec(pointList, rst = null) {\r\n        if (!pointList || pointList.length < 1)\r\n            return rst ? rst.setTo(0, 0, 0, 0) : Rectangle.TEMP.setTo(0, 0, 0, 0);\r\n        rst = rst ? rst : Rectangle.create();\r\n        var i, len = pointList.length, minX, maxX, minY, maxY, tPoint = Point.TEMP;\r\n        minX = minY = 99999;\r\n        maxX = maxY = -minX;\r\n        for (i = 0; i < len; i += 2) {\r\n            tPoint.x = pointList[i];\r\n            tPoint.y = pointList[i + 1];\r\n            minX = minX < tPoint.x ? minX : tPoint.x;\r\n            minY = minY < tPoint.y ? minY : tPoint.y;\r\n            maxX = maxX > tPoint.x ? maxX : tPoint.x;\r\n            maxY = maxY > tPoint.y ? maxY : tPoint.y;\r\n        }\r\n        return rst.setTo(minX, minY, maxX - minX, maxY - minY);\r\n    }\r\n    isEmpty() {\r\n        if (this.width <= 0 || this.height <= 0)\r\n            return true;\r\n        return false;\r\n    }\r\n}\r\nRectangle.EMPTY = new Rectangle();\r\nRectangle.TEMP = new Rectangle();\r\nRectangle._temB = [];\r\nRectangle._temA = [];\r\n",
  "references": [
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/utils/Pool.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/maths/Point.ts"
  ],
  "dts": {
    "name": "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/maths/Rectangle.d.ts",
    "writeByteOrderMark": false,
    "text": "export declare class Rectangle {\r\n    static EMPTY: Rectangle;\r\n    static TEMP: Rectangle;\r\n    private static _temB;\r\n    private static _temA;\r\n    x: number;\r\n    y: number;\r\n    width: number;\r\n    height: number;\r\n    constructor(x?: number, y?: number, width?: number, height?: number);\r\n    readonly right: number;\r\n    readonly bottom: number;\r\n    setTo(x: number, y: number, width: number, height: number): Rectangle;\r\n    reset(): Rectangle;\r\n    recover(): void;\r\n    static create(): Rectangle;\r\n    copyFrom(source: Rectangle): Rectangle;\r\n    contains(x: number, y: number): boolean;\r\n    intersects(rect: Rectangle): boolean;\r\n    intersection(rect: Rectangle, out?: Rectangle | null): Rectangle | null;\r\n    union(source: Rectangle, out?: Rectangle | null): Rectangle;\r\n    clone(out?: Rectangle | null): Rectangle;\r\n    toString(): string;\r\n    equals(rect: Rectangle): boolean;\r\n    addPoint(x: number, y: number): Rectangle;\r\n    _getBoundPoints(): number[];\r\n    static _getBoundPointS(x: number, y: number, width: number, height: number): any[];\r\n    static _getWrapRec(pointList: ArrayLike<number>, rst?: Rectangle | null): Rectangle;\r\n    isEmpty(): boolean;\r\n}\r\n"
  }
}

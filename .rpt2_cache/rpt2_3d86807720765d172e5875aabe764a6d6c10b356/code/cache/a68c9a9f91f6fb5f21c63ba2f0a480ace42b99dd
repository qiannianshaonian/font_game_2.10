{
  "code": "import { Sprite } from \"./Sprite\";\r\nimport { SpriteConst } from \"./SpriteConst\";\r\nimport { TextStyle } from \"./css/TextStyle\";\r\nimport { Event } from \"../events/Event\";\r\nimport { Point } from \"../maths/Point\";\r\nimport { Rectangle } from \"../maths/Rectangle\";\r\nimport { WordText } from \"../utils/WordText\";\r\nimport { ILaya } from \"../../ILaya\";\r\nimport { ClassUtils } from \"../utils/ClassUtils\";\r\nexport class Text extends Sprite {\r\n    constructor() {\r\n        super();\r\n        this._textWidth = 0;\r\n        this._textHeight = 0;\r\n        this._lines = [];\r\n        this._lineWidths = [];\r\n        this._startX = 0;\r\n        this._startY = 0;\r\n        this._charSize = {};\r\n        this._valign = \"top\";\r\n        this._fontSize = Text.defaultFontSize;\r\n        this._font = Text.defaultFont;\r\n        this._color = \"#000000\";\r\n        this._singleCharRender = false;\r\n        this.overflow = Text.VISIBLE;\r\n        this._style = TextStyle.EMPTY;\r\n    }\r\n    static defaultFontStr() {\r\n        return Text.defaultFontSize + \"px \" + Text.defaultFont;\r\n    }\r\n    getStyle() {\r\n        this._style === TextStyle.EMPTY && (this._style = TextStyle.create());\r\n        return this._style;\r\n    }\r\n    _getTextStyle() {\r\n        if (this._style === TextStyle.EMPTY) {\r\n            this._style = TextStyle.create();\r\n        }\r\n        return this._style;\r\n    }\r\n    static registerBitmapFont(name, bitmapFont) {\r\n        Text._bitmapFonts || (Text._bitmapFonts = {});\r\n        Text._bitmapFonts[name] = bitmapFont;\r\n    }\r\n    static unregisterBitmapFont(name, destroy = true) {\r\n        if (Text._bitmapFonts && Text._bitmapFonts[name]) {\r\n            var tBitmapFont = Text._bitmapFonts[name];\r\n            if (destroy)\r\n                tBitmapFont.destroy();\r\n            delete Text._bitmapFonts[name];\r\n        }\r\n    }\r\n    destroy(destroyChild = true) {\r\n        super.destroy(destroyChild);\r\n        this._clipPoint = null;\r\n        this._lines = null;\r\n        this._lineWidths = null;\r\n        this._words && this._words.forEach(function (w) {\r\n            w.cleanCache();\r\n        });\r\n        this._words = null;\r\n        this._charSize = null;\r\n    }\r\n    _getBoundPointsM(ifRotate = false) {\r\n        var rec = Rectangle.TEMP;\r\n        rec.setTo(0, 0, this.width, this.height);\r\n        return rec._getBoundPoints();\r\n    }\r\n    getGraphicBounds(realSize = false) {\r\n        var rec = Rectangle.TEMP;\r\n        rec.setTo(0, 0, this.width, this.height);\r\n        return rec;\r\n    }\r\n    get width() {\r\n        if (this._width)\r\n            return this._width;\r\n        return this.textWidth + this.padding[1] + this.padding[3];\r\n    }\r\n    set width(value) {\r\n        if (value != this._width) {\r\n            super.set_width(value);\r\n            this.isChanged = true;\r\n            if (this.borderColor) {\r\n                this._setBorderStyleColor(0, 0, this.width, this.height, this.borderColor, 1);\r\n            }\r\n        }\r\n    }\r\n    _getCSSStyle() {\r\n        return this._style;\r\n    }\r\n    get height() {\r\n        if (this._height)\r\n            return this._height;\r\n        return this.textHeight;\r\n    }\r\n    set height(value) {\r\n        if (value != this._height) {\r\n            super.set_height(value);\r\n            this.isChanged = true;\r\n            if (this.borderColor) {\r\n                this._setBorderStyleColor(0, 0, this.width, this.height, this.borderColor, 1);\r\n            }\r\n        }\r\n    }\r\n    get textWidth() {\r\n        this._isChanged && ILaya.systemTimer.runCallLater(this, this.typeset);\r\n        return this._textWidth;\r\n    }\r\n    get textHeight() {\r\n        this._isChanged && ILaya.systemTimer.runCallLater(this, this.typeset);\r\n        return this._textHeight;\r\n    }\r\n    get text() {\r\n        return this._text || \"\";\r\n    }\r\n    get_text() {\r\n        return this._text || \"\";\r\n    }\r\n    set_text(value) {\r\n        if (this._text !== value) {\r\n            this.lang(value + \"\");\r\n            this.isChanged = true;\r\n            this.event(Event.CHANGE);\r\n            if (this.borderColor) {\r\n                this._setBorderStyleColor(0, 0, this.width, this.height, this.borderColor, 1);\r\n            }\r\n        }\r\n    }\r\n    set text(value) {\r\n        this.set_text(value);\r\n    }\r\n    lang(text, arg1 = null, arg2 = null, arg3 = null, arg4 = null, arg5 = null, arg6 = null, arg7 = null, arg8 = null, arg9 = null, arg10 = null) {\r\n        text = Text.langPacks && Text.langPacks[text] ? Text.langPacks[text] : text;\r\n        if (arguments.length < 2) {\r\n            this._text = text;\r\n        }\r\n        else {\r\n            for (var i = 0, n = arguments.length; i < n; i++) {\r\n                text = text.replace(\"{\" + i + \"}\", arguments[i + 1]);\r\n            }\r\n            this._text = text;\r\n        }\r\n    }\r\n    get font() {\r\n        return this._font;\r\n    }\r\n    set font(value) {\r\n        if (this._style.currBitmapFont) {\r\n            this._getTextStyle().currBitmapFont = null;\r\n            this.scale(1, 1);\r\n        }\r\n        if (Text._bitmapFonts && Text._bitmapFonts[value]) {\r\n            this._getTextStyle().currBitmapFont = Text._bitmapFonts[value];\r\n        }\r\n        this._font = value;\r\n        this.isChanged = true;\r\n    }\r\n    get fontSize() {\r\n        return this._fontSize;\r\n    }\r\n    set fontSize(value) {\r\n        if (this._fontSize != value) {\r\n            this._fontSize = value;\r\n            this.isChanged = true;\r\n        }\r\n    }\r\n    get bold() {\r\n        return this._style.bold;\r\n    }\r\n    set bold(value) {\r\n        this._getTextStyle().bold = value;\r\n        this.isChanged = true;\r\n    }\r\n    get color() {\r\n        return this._color;\r\n    }\r\n    set color(value) {\r\n        this.set_color(value);\r\n    }\r\n    get_color() {\r\n        return this._color;\r\n    }\r\n    set_color(value) {\r\n        if (this._color != value) {\r\n            this._color = value;\r\n            if (!this._isChanged && this._graphics) {\r\n                this._graphics.replaceTextColor(this.color);\r\n            }\r\n            else {\r\n                this.isChanged = true;\r\n            }\r\n        }\r\n    }\r\n    get italic() {\r\n        return this._style.italic;\r\n    }\r\n    set italic(value) {\r\n        this._getTextStyle().italic = value;\r\n        this.isChanged = true;\r\n    }\r\n    get align() {\r\n        return this._style.align;\r\n    }\r\n    set align(value) {\r\n        this._getTextStyle().align = value;\r\n        this.isChanged = true;\r\n    }\r\n    get valign() {\r\n        return this._valign;\r\n    }\r\n    set valign(value) {\r\n        this._valign = value;\r\n        this.isChanged = true;\r\n    }\r\n    get wordWrap() {\r\n        return this._style.wordWrap;\r\n    }\r\n    set wordWrap(value) {\r\n        this._getTextStyle().wordWrap = value;\r\n        this.isChanged = true;\r\n    }\r\n    get leading() {\r\n        return this._style.leading;\r\n    }\r\n    set leading(value) {\r\n        this._getTextStyle().leading = value;\r\n        this.isChanged = true;\r\n    }\r\n    get padding() {\r\n        return this._style.padding;\r\n    }\r\n    set padding(value) {\r\n        if (typeof (value) == 'string') {\r\n            var arr;\r\n            arr = value.split(\",\");\r\n            var i, len;\r\n            len = arr.length;\r\n            while (arr.length < 4) {\r\n                arr.push(0);\r\n            }\r\n            for (i = 0; i < len; i++) {\r\n                arr[i] = parseFloat(arr[i]) || 0;\r\n            }\r\n            value = arr;\r\n        }\r\n        this._getTextStyle().padding = value;\r\n        this.isChanged = true;\r\n    }\r\n    get bgColor() {\r\n        return this._style.bgColor;\r\n    }\r\n    set bgColor(value) {\r\n        this.set_bgColor(value);\r\n    }\r\n    set_bgColor(value) {\r\n        this._getTextStyle().bgColor = value;\r\n        this._renderType |= SpriteConst.STYLE;\r\n        this._setBgStyleColor(0, 0, this.width, this.height, value);\r\n        this._setRenderType(this._renderType);\r\n        this.isChanged = true;\r\n    }\r\n    get_bgColor() {\r\n        return this._style.bgColor;\r\n    }\r\n    get borderColor() {\r\n        return this._style.borderColor;\r\n    }\r\n    set borderColor(value) {\r\n        this._getTextStyle().borderColor = value;\r\n        this._renderType |= SpriteConst.STYLE;\r\n        this._setBorderStyleColor(0, 0, this.width, this.height, value, 1);\r\n        this._setRenderType(this._renderType);\r\n        this.isChanged = true;\r\n    }\r\n    get stroke() {\r\n        return this._style.stroke;\r\n    }\r\n    set stroke(value) {\r\n        this._getTextStyle().stroke = value;\r\n        this.isChanged = true;\r\n    }\r\n    get strokeColor() {\r\n        return this._style.strokeColor;\r\n    }\r\n    set strokeColor(value) {\r\n        this._getTextStyle().strokeColor = value;\r\n        this.isChanged = true;\r\n    }\r\n    set isChanged(value) {\r\n        if (this._isChanged !== value) {\r\n            this._isChanged = value;\r\n            value && ILaya.systemTimer.callLater(this, this.typeset);\r\n        }\r\n    }\r\n    _getContextFont() {\r\n        return (this.italic ? \"italic \" : \"\") + (this.bold ? \"bold \" : \"\") + this.fontSize + \"px \" + (ILaya.Browser.onIPhone ? (Text.fontFamilyMap[this.font] || this.font) : this.font);\r\n    }\r\n    _isPassWordMode() {\r\n        var style = this._style;\r\n        var password = style.asPassword;\r\n        if ((\"prompt\" in this) && this['prompt'] == this._text)\r\n            password = false;\r\n        return password;\r\n    }\r\n    _getPassWordTxt(txt) {\r\n        var len = txt.length;\r\n        var word;\r\n        word = \"\";\r\n        for (var j = len; j > 0; j--) {\r\n            word += \"●\";\r\n        }\r\n        return word;\r\n    }\r\n    _renderText() {\r\n        var padding = this.padding;\r\n        var visibleLineCount = this._lines.length;\r\n        if (this.overflow != Text.VISIBLE) {\r\n            visibleLineCount = Math.min(visibleLineCount, Math.floor((this.height - padding[0] - padding[2]) / (this.leading + this._charSize.height)) + 1);\r\n        }\r\n        var beginLine = this.scrollY / (this._charSize.height + this.leading) | 0;\r\n        var graphics = this.graphics;\r\n        graphics.clear(true);\r\n        var ctxFont = this._getContextFont();\r\n        ILaya.Browser.context.font = ctxFont;\r\n        var startX = padding[3];\r\n        var textAlgin = \"left\";\r\n        var lines = this._lines;\r\n        var lineHeight = this.leading + this._charSize.height;\r\n        var tCurrBitmapFont = this._style.currBitmapFont;\r\n        if (tCurrBitmapFont) {\r\n            lineHeight = this.leading + tCurrBitmapFont.getMaxHeight();\r\n        }\r\n        var startY = padding[0];\r\n        if ((!tCurrBitmapFont) && this._width > 0 && this._textWidth <= this._width) {\r\n            if (this.align == \"right\") {\r\n                textAlgin = \"right\";\r\n                startX = this._width - padding[1];\r\n            }\r\n            else if (this.align == \"center\") {\r\n                textAlgin = \"center\";\r\n                startX = this._width * 0.5 + padding[3] - padding[1];\r\n            }\r\n        }\r\n        let bitmapScale = 1;\r\n        if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize) {\r\n            bitmapScale = tCurrBitmapFont.fontSize / this.fontSize;\r\n        }\r\n        if (this._height > 0) {\r\n            var tempVAlign = (this._textHeight > this._height) ? \"top\" : this.valign;\r\n            if (tempVAlign === \"middle\")\r\n                startY = (this._height - visibleLineCount / bitmapScale * lineHeight) * 0.5 + padding[0] - padding[2];\r\n            else if (tempVAlign === \"bottom\")\r\n                startY = this._height - visibleLineCount / bitmapScale * lineHeight - padding[2];\r\n        }\r\n        if (this._clipPoint) {\r\n            graphics.save();\r\n            if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize) {\r\n                var tClipWidth;\r\n                var tClipHeight;\r\n                this._width ? tClipWidth = (this._width - padding[3] - padding[1]) : tClipWidth = this._textWidth;\r\n                this._height ? tClipHeight = (this._height - padding[0] - padding[2]) : tClipHeight = this._textHeight;\r\n                tClipWidth *= bitmapScale;\r\n                tClipHeight *= bitmapScale;\r\n                graphics.clipRect(padding[3], padding[0], tClipWidth, tClipHeight);\r\n            }\r\n            else {\r\n                graphics.clipRect(padding[3], padding[0], this._width ? (this._width - padding[3] - padding[1]) : this._textWidth, this._height ? (this._height - padding[0] - padding[2]) : this._textHeight);\r\n            }\r\n            this.repaint();\r\n        }\r\n        var style = this._style;\r\n        var password = style.asPassword;\r\n        if ((\"prompt\" in this) && this['prompt'] == this._text)\r\n            password = false;\r\n        var x = 0, y = 0;\r\n        var end = Math.min(this._lines.length, visibleLineCount + beginLine) || 1;\r\n        for (var i = beginLine; i < end; i++) {\r\n            var word = lines[i];\r\n            var _word;\r\n            if (password) {\r\n                word = \"\";\r\n                for (var j = word.length; j > 0; j--) {\r\n                    word += \"●\";\r\n                }\r\n            }\r\n            if (word == null)\r\n                word = \"\";\r\n            x = startX - (this._clipPoint ? this._clipPoint.x : 0);\r\n            y = startY + lineHeight * i - (this._clipPoint ? this._clipPoint.y : 0);\r\n            this.underline && this._drawUnderline(textAlgin, x, y, i);\r\n            if (tCurrBitmapFont) {\r\n                var tWidth = this.width;\r\n                if (tCurrBitmapFont.autoScaleSize) {\r\n                    tWidth = this.width * bitmapScale;\r\n                    x *= bitmapScale;\r\n                    y *= bitmapScale;\r\n                }\r\n                tCurrBitmapFont._drawText(word, this, x, y, this.align, tWidth);\r\n            }\r\n            else {\r\n                this._words || (this._words = []);\r\n                if (this._words.length > (i - beginLine)) {\r\n                    _word = this._words[i - beginLine];\r\n                }\r\n                else {\r\n                    _word = new WordText();\r\n                    this._words.push(_word);\r\n                }\r\n                _word.setText(word);\r\n                _word.splitRender = this._singleCharRender;\r\n                style.stroke ? graphics.fillBorderText(_word, x, y, ctxFont, this.color, textAlgin, style.stroke, style.strokeColor) : graphics.fillText(_word, x, y, ctxFont, this.color, textAlgin);\r\n            }\r\n        }\r\n        if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize) {\r\n            var tScale = 1 / bitmapScale;\r\n            this.scale(tScale, tScale);\r\n        }\r\n        if (this._clipPoint)\r\n            graphics.restore();\r\n        this._startX = startX;\r\n        this._startY = startY;\r\n    }\r\n    _drawUnderline(align, x, y, lineIndex) {\r\n        var lineWidth = this._lineWidths[lineIndex];\r\n        switch (align) {\r\n            case 'center':\r\n                x -= lineWidth / 2;\r\n                break;\r\n            case 'right':\r\n                x -= lineWidth;\r\n                break;\r\n            case 'left':\r\n            default:\r\n                break;\r\n        }\r\n        y += this._charSize.height;\r\n        this._graphics.drawLine(x, y, x + lineWidth, y, this.underlineColor || this.color, 1);\r\n    }\r\n    typeset() {\r\n        this._isChanged = false;\r\n        if (!this._text) {\r\n            this._clipPoint = null;\r\n            this._textWidth = this._textHeight = 0;\r\n            this.graphics.clear(true);\r\n            return;\r\n        }\r\n        if (ILaya.Render.isConchApp) {\r\n            window.conchTextCanvas.font = this._getContextFont();\r\n            ;\r\n        }\r\n        else {\r\n            ILaya.Browser.context.font = this._getContextFont();\r\n        }\r\n        this._lines.length = 0;\r\n        this._lineWidths.length = 0;\r\n        if (this._isPassWordMode()) {\r\n            this._parseLines(this._getPassWordTxt(this._text));\r\n        }\r\n        else\r\n            this._parseLines(this._text);\r\n        this._evalTextSize();\r\n        if (this._checkEnabledViewportOrNot())\r\n            this._clipPoint || (this._clipPoint = new Point(0, 0));\r\n        else\r\n            this._clipPoint = null;\r\n        this._renderText();\r\n    }\r\n    _evalTextSize() {\r\n        var nw, nh;\r\n        nw = Math.max.apply(this, this._lineWidths);\r\n        let bmpFont = this._style.currBitmapFont;\r\n        if (bmpFont) {\r\n            let h = bmpFont.getMaxHeight();\r\n            if (bmpFont.autoScaleSize) {\r\n                h = this.fontSize;\r\n            }\r\n            nh = this._lines.length * (h + this.leading) + this.padding[0] + this.padding[2];\r\n        }\r\n        else {\r\n            nh = this._lines.length * (this._charSize.height + this.leading) + this.padding[0] + this.padding[2];\r\n            if (this._lines.length) {\r\n                nh -= this.leading;\r\n            }\r\n        }\r\n        if (nw != this._textWidth || nh != this._textHeight) {\r\n            this._textWidth = nw;\r\n            this._textHeight = nh;\r\n        }\r\n    }\r\n    _checkEnabledViewportOrNot() {\r\n        return this.overflow == Text.SCROLL && ((this._width > 0 && this._textWidth > this._width) || (this._height > 0 && this._textHeight > this._height));\r\n    }\r\n    changeText(text) {\r\n        if (this._text !== text) {\r\n            this.lang(text + \"\");\r\n            if (this._graphics && this._graphics.replaceText(this._text)) {\r\n            }\r\n            else {\r\n                this.typeset();\r\n            }\r\n        }\r\n    }\r\n    _parseLines(text) {\r\n        var needWordWrapOrTruncate = this.wordWrap || this.overflow == Text.HIDDEN;\r\n        if (needWordWrapOrTruncate) {\r\n            var wordWrapWidth = this._getWordWrapWidth();\r\n        }\r\n        var bitmapFont = this._style.currBitmapFont;\r\n        if (bitmapFont) {\r\n            this._charSize.width = bitmapFont.getMaxWidth();\r\n            this._charSize.height = bitmapFont.getMaxHeight();\r\n        }\r\n        else {\r\n            var measureResult = null;\r\n            if (ILaya.Render.isConchApp) {\r\n                measureResult = window.conchTextCanvas.measureText(Text._testWord);\r\n            }\r\n            else {\r\n                measureResult = ILaya.Browser.context.measureText(Text._testWord);\r\n            }\r\n            if (!measureResult)\r\n                measureResult = { width: 100 };\r\n            this._charSize.width = measureResult.width;\r\n            this._charSize.height = (measureResult.height || this.fontSize);\r\n        }\r\n        var lines = text.replace(/\\r\\n/g, \"\\n\").split(\"\\n\");\r\n        for (var i = 0, n = lines.length; i < n; i++) {\r\n            var line = lines[i];\r\n            if (needWordWrapOrTruncate)\r\n                this._parseLine(line, wordWrapWidth);\r\n            else {\r\n                this._lineWidths.push(this._getTextWidth(line));\r\n                this._lines.push(line);\r\n            }\r\n        }\r\n    }\r\n    _parseLine(line, wordWrapWidth) {\r\n        var lines = this._lines;\r\n        var maybeIndex = 0;\r\n        var charsWidth = 0;\r\n        var wordWidth = 0;\r\n        var startIndex = 0;\r\n        charsWidth = this._getTextWidth(line);\r\n        if (charsWidth <= wordWrapWidth) {\r\n            lines.push(line);\r\n            this._lineWidths.push(charsWidth);\r\n            return;\r\n        }\r\n        charsWidth = this._charSize.width;\r\n        maybeIndex = Math.floor(wordWrapWidth / charsWidth);\r\n        (maybeIndex == 0) && (maybeIndex = 1);\r\n        charsWidth = this._getTextWidth(line.substring(0, maybeIndex));\r\n        wordWidth = charsWidth;\r\n        for (var j = maybeIndex, m = line.length; j < m; j++) {\r\n            charsWidth = this._getTextWidth(line.charAt(j));\r\n            wordWidth += charsWidth;\r\n            if (wordWidth > wordWrapWidth) {\r\n                if (this.wordWrap) {\r\n                    var newLine = line.substring(startIndex, j);\r\n                    if (newLine.charCodeAt(newLine.length - 1) < 255) {\r\n                        var execResult = /(?:\\w|-)+$/.exec(newLine);\r\n                        if (execResult) {\r\n                            j = execResult.index + startIndex;\r\n                            if (execResult.index == 0)\r\n                                j += newLine.length;\r\n                            else\r\n                                newLine = line.substring(startIndex, j);\r\n                        }\r\n                    }\r\n                    lines.push(newLine);\r\n                    this._lineWidths.push(wordWidth - charsWidth);\r\n                    startIndex = j;\r\n                    if (j + maybeIndex < m) {\r\n                        j += maybeIndex;\r\n                        charsWidth = this._getTextWidth(line.substring(startIndex, j));\r\n                        wordWidth = charsWidth;\r\n                        j--;\r\n                    }\r\n                    else {\r\n                        lines.push(line.substring(startIndex, m));\r\n                        this._lineWidths.push(this._getTextWidth(lines[lines.length - 1]));\r\n                        startIndex = -1;\r\n                        break;\r\n                    }\r\n                }\r\n                else if (this.overflow == Text.HIDDEN) {\r\n                    lines.push(line.substring(0, j));\r\n                    this._lineWidths.push(this._getTextWidth(lines[lines.length - 1]));\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        if (this.wordWrap && startIndex != -1) {\r\n            lines.push(line.substring(startIndex, m));\r\n            this._lineWidths.push(this._getTextWidth(lines[lines.length - 1]));\r\n        }\r\n    }\r\n    _getTextWidth(text) {\r\n        var bitmapFont = this._style.currBitmapFont;\r\n        if (bitmapFont)\r\n            return bitmapFont.getTextWidth(text);\r\n        else {\r\n            if (ILaya.Render.isConchApp) {\r\n                return window.conchTextCanvas.measureText(text).width;\r\n                ;\r\n            }\r\n            else {\r\n                let ret = ILaya.Browser.context.measureText(text) || { width: 100 };\r\n                return ret.width;\r\n            }\r\n        }\r\n    }\r\n    _getWordWrapWidth() {\r\n        var p = this.padding;\r\n        var w;\r\n        var bitmapFont = this._style.currBitmapFont;\r\n        if (bitmapFont && bitmapFont.autoScaleSize)\r\n            w = this._width * (bitmapFont.fontSize / this.fontSize);\r\n        else\r\n            w = this._width;\r\n        if (w <= 0) {\r\n            w = this.wordWrap ? 100 : ILaya.Browser.width;\r\n        }\r\n        w <= 0 && (w = 100);\r\n        return w - p[3] - p[1];\r\n    }\r\n    getCharPoint(charIndex, out = null) {\r\n        this._isChanged && ILaya.systemTimer.runCallLater(this, this.typeset);\r\n        var len = 0, lines = this._lines, startIndex = 0;\r\n        for (var i = 0, n = lines.length; i < n; i++) {\r\n            len += lines[i].length;\r\n            if (charIndex < len) {\r\n                var line = i;\r\n                break;\r\n            }\r\n            startIndex = len;\r\n        }\r\n        var ctxFont = (this.italic ? \"italic \" : \"\") + (this.bold ? \"bold \" : \"\") + this.fontSize + \"px \" + this.font;\r\n        ILaya.Browser.context.font = ctxFont;\r\n        var width = this._getTextWidth(this._text.substring(startIndex, charIndex));\r\n        var point = out || new Point();\r\n        return point.setTo(this._startX + width - (this._clipPoint ? this._clipPoint.x : 0), this._startY + line * (this._charSize.height + this.leading) - (this._clipPoint ? this._clipPoint.y : 0));\r\n    }\r\n    set scrollX(value) {\r\n        if (this.overflow != Text.SCROLL || (this.textWidth < this._width || !this._clipPoint))\r\n            return;\r\n        value = value < this.padding[3] ? this.padding[3] : value;\r\n        var maxScrollX = this._textWidth - this._width;\r\n        value = value > maxScrollX ? maxScrollX : value;\r\n        this._clipPoint.x = value;\r\n        this._renderText();\r\n    }\r\n    get scrollX() {\r\n        if (!this._clipPoint)\r\n            return 0;\r\n        return this._clipPoint.x;\r\n    }\r\n    set scrollY(value) {\r\n        if (this.overflow != Text.SCROLL || (this.textHeight < this._height || !this._clipPoint))\r\n            return;\r\n        value = value < this.padding[0] ? this.padding[0] : value;\r\n        var maxScrollY = this._textHeight - this._height;\r\n        value = value > maxScrollY ? maxScrollY : value;\r\n        this._clipPoint.y = value;\r\n        this._renderText();\r\n    }\r\n    get scrollY() {\r\n        if (!this._clipPoint)\r\n            return 0;\r\n        return this._clipPoint.y;\r\n    }\r\n    get maxScrollX() {\r\n        return (this.textWidth < this._width) ? 0 : this._textWidth - this._width;\r\n    }\r\n    get maxScrollY() {\r\n        return (this.textHeight < this._height) ? 0 : this._textHeight - this._height;\r\n    }\r\n    get lines() {\r\n        if (this._isChanged)\r\n            this.typeset();\r\n        return this._lines;\r\n    }\r\n    get underlineColor() {\r\n        return this._style.underlineColor;\r\n    }\r\n    set underlineColor(value) {\r\n        this._getTextStyle().underlineColor = value;\r\n        if (!this._isChanged)\r\n            this._renderText();\r\n    }\r\n    get underline() {\r\n        return this._style.underline;\r\n    }\r\n    set underline(value) {\r\n        this._getTextStyle().underline = value;\r\n    }\r\n    set singleCharRender(value) {\r\n        this._singleCharRender = value;\r\n    }\r\n    get singleCharRender() {\r\n        return this._singleCharRender;\r\n    }\r\n}\r\nText.VISIBLE = \"visible\";\r\nText.SCROLL = \"scroll\";\r\nText.HIDDEN = \"hidden\";\r\nText.defaultFontSize = 12;\r\nText.defaultFont = \"Arial\";\r\nText.isComplexText = false;\r\nText.fontFamilyMap = { \"报隶\": \"报隶-简\", \"黑体\": \"黑体-简\", \"楷体\": \"楷体-简\", \"兰亭黑\": \"兰亭黑-简\", \"隶变\": \"隶变-简\", \"凌慧体\": \"凌慧体-简\", \"翩翩体\": \"翩翩体-简\", \"苹方\": \"苹方-简\", \"手札体\": \"手札体-简\", \"宋体\": \"宋体-简\", \"娃娃体\": \"娃娃体-简\", \"魏碑\": \"魏碑-简\", \"行楷\": \"行楷-简\", \"雅痞\": \"雅痞-简\", \"圆体\": \"圆体-简\" };\r\nText._testWord = \"游\";\r\nText.CharacterCache = true;\r\nText.RightToLeft = false;\r\nILaya.regClass(Text);\r\nClassUtils.regClass(\"laya.display.Text\", Text);\r\nClassUtils.regClass(\"Laya.Text\", Text);\r\n",
  "references": [
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/display/Sprite.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/display/BitmapFont.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/display/SpriteConst.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/display/Graphics.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/display/css/SpriteStyle.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/display/css/TextStyle.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/events/Event.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/maths/Point.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/maths/Rectangle.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/utils/WordText.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/utils/Timer.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/ILaya.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/utils/ClassUtils.ts"
  ],
  "dts": {
    "name": "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/display/Text.d.ts",
    "writeByteOrderMark": false,
    "text": "import { Sprite } from \"./Sprite\";\r\nimport { BitmapFont } from \"./BitmapFont\";\r\nimport { SpriteStyle } from \"./css/SpriteStyle\";\r\nimport { TextStyle } from \"./css/TextStyle\";\r\nimport { Point } from \"../maths/Point\";\r\nimport { Rectangle } from \"../maths/Rectangle\";\r\nimport { WordText } from \"../utils/WordText\";\r\nexport declare class Text extends Sprite {\r\n    static VISIBLE: string;\r\n    static SCROLL: string;\r\n    static HIDDEN: string;\r\n    static defaultFontSize: number;\r\n    static defaultFont: string;\r\n    static defaultFontStr(): string;\r\n    static langPacks: any;\r\n    static isComplexText: boolean;\r\n    static fontFamilyMap: any;\r\n    static _testWord: string;\r\n    private static _bitmapFonts;\r\n    static CharacterCache: boolean;\r\n    static RightToLeft: boolean;\r\n    private _clipPoint;\r\n    protected _text: string;\r\n    protected _isChanged: boolean;\r\n    protected _textWidth: number;\r\n    protected _textHeight: number;\r\n    protected _lines: any[] | null;\r\n    protected _lineWidths: number[] | null;\r\n    protected _startX: number;\r\n    protected _startY: number;\r\n    protected _words: WordText[] | null;\r\n    protected _charSize: any;\r\n    protected _valign: string;\r\n    _fontSize: number;\r\n    _font: string;\r\n    _color: string;\r\n    private _singleCharRender;\r\n    overflow: string;\r\n    constructor();\r\n    getStyle(): SpriteStyle;\r\n    protected _getTextStyle(): TextStyle;\r\n    static registerBitmapFont(name: string, bitmapFont: BitmapFont): void;\r\n    static unregisterBitmapFont(name: string, destroy?: boolean): void;\r\n    destroy(destroyChild?: boolean): void;\r\n    _getBoundPointsM(ifRotate?: boolean): any[];\r\n    getGraphicBounds(realSize?: boolean): Rectangle;\r\n    width: number;\r\n    _getCSSStyle(): TextStyle;\r\n    height: number;\r\n    readonly textWidth: number;\r\n    readonly textHeight: number;\r\n    text: string;\r\n    get_text(): string;\r\n    set_text(value: string): void;\r\n    lang(text: string, arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any, arg9?: any, arg10?: any): void;\r\n    font: string;\r\n    fontSize: number;\r\n    bold: boolean;\r\n    color: string;\r\n    get_color(): string;\r\n    set_color(value: string): void;\r\n    italic: boolean;\r\n    align: string;\r\n    valign: string;\r\n    wordWrap: boolean;\r\n    leading: number;\r\n    padding: any[];\r\n    bgColor: string;\r\n    set_bgColor(value: string): void;\r\n    get_bgColor(): string;\r\n    borderColor: string;\r\n    stroke: number;\r\n    strokeColor: string;\r\n    protected isChanged: boolean;\r\n    protected _getContextFont(): string;\r\n    protected _isPassWordMode(): boolean;\r\n    protected _getPassWordTxt(txt: string): string;\r\n    protected _renderText(): void;\r\n    private _drawUnderline;\r\n    typeset(): void;\r\n    private _evalTextSize;\r\n    private _checkEnabledViewportOrNot;\r\n    changeText(text: string): void;\r\n    protected _parseLines(text: string): void;\r\n    protected _parseLine(line: string, wordWrapWidth: number): void;\r\n    private _getTextWidth;\r\n    private _getWordWrapWidth;\r\n    getCharPoint(charIndex: number, out?: Point): Point;\r\n    scrollX: number;\r\n    scrollY: number;\r\n    readonly maxScrollX: number;\r\n    readonly maxScrollY: number;\r\n    readonly lines: any[];\r\n    underlineColor: string;\r\n    underline: boolean;\r\n    singleCharRender: boolean;\r\n}\r\n"
  }
}

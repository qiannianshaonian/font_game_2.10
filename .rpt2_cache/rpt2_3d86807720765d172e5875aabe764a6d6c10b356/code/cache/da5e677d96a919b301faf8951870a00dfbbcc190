{
  "code": "import { AnimationParser01 } from \"./AnimationParser01\";\r\nimport { AnimationParser02 } from \"./AnimationParser02\";\r\nimport { Resource } from \"../resource/Resource\";\r\nimport { MathUtil } from \"../maths/MathUtil\";\r\nimport { IAniLib } from \"./AniLibPack\";\r\nimport { Byte } from \"../utils/Byte\";\r\nimport { BezierLerp } from \"./math/BezierLerp\";\r\nexport class AnimationTemplet extends Resource {\r\n    constructor() {\r\n        super();\r\n        this._anis = [];\r\n        this._aniMap = {};\r\n        this.unfixedLastAniIndex = -1;\r\n        this._fullFrames = null;\r\n        this._boneCurKeyFrm = [];\r\n    }\r\n    static _LinearInterpolation_0(bone, index, out, outOfs, data, dt, dData, duration, nextData, interData = null) {\r\n        out[outOfs] = data[index] + dt * dData[index];\r\n        return 1;\r\n    }\r\n    static _QuaternionInterpolation_1(bone, index, out, outOfs, data, dt, dData, duration, nextData, interData = null) {\r\n        var amount = duration === 0 ? 0 : dt / duration;\r\n        MathUtil.slerpQuaternionArray(data, index, nextData, index, amount, out, outOfs);\r\n        return 4;\r\n    }\r\n    static _AngleInterpolation_2(bone, index, out, outOfs, data, dt, dData, duration, nextData, interData = null) {\r\n        return 0;\r\n    }\r\n    static _RadiansInterpolation_3(bone, index, out, outOfs, data, dt, dData, duration, nextData, interData = null) {\r\n        return 0;\r\n    }\r\n    static _Matrix4x4Interpolation_4(bone, index, out, outOfs, data, dt, dData, duration, nextData, interData = null) {\r\n        for (var i = 0; i < 16; i++, index++)\r\n            out[outOfs + i] = data[index] + dt * dData[index];\r\n        return 16;\r\n    }\r\n    static _NoInterpolation_5(bone, index, out, outOfs, data, dt, dData, duration, nextData, interData = null) {\r\n        out[outOfs] = data[index];\r\n        return 1;\r\n    }\r\n    static _BezierInterpolation_6(bone, index, out, outOfs, data, dt, dData, duration, nextData, interData = null, offset = 0) {\r\n        out[outOfs] = data[index] + (nextData[index] - data[index]) * BezierLerp.getBezierRate(dt / duration, interData[offset], interData[offset + 1], interData[offset + 2], interData[offset + 3]);\r\n        return 5;\r\n    }\r\n    static _BezierInterpolation_7(bone, index, out, outOfs, data, dt, dData, duration, nextData, interData = null, offset = 0) {\r\n        out[outOfs] = interData[offset + 4] + interData[offset + 5] * BezierLerp.getBezierRate((dt * 0.001 + interData[offset + 6]) / interData[offset + 7], interData[offset], interData[offset + 1], interData[offset + 2], interData[offset + 3]);\r\n        return 9;\r\n    }\r\n    parse(data) {\r\n        var reader = new Byte(data);\r\n        this._aniVersion = reader.readUTFString();\r\n        AnimationParser01.parse(this, reader);\r\n    }\r\n    _calculateKeyFrame(node, keyframeCount, keyframeDataCount) {\r\n        var keyFrames = node.keyFrame;\r\n        keyFrames[keyframeCount] = keyFrames[0];\r\n        for (var i = 0; i < keyframeCount; i++) {\r\n            var keyFrame = keyFrames[i];\r\n            for (var j = 0; j < keyframeDataCount; j++) {\r\n                keyFrame.dData[j] = (keyFrame.duration === 0) ? 0 : (keyFrames[i + 1].data[j] - keyFrame.data[j]) / keyFrame.duration;\r\n                keyFrame.nextData[j] = keyFrames[i + 1].data[j];\r\n            }\r\n        }\r\n        keyFrames.length--;\r\n    }\r\n    _onAsynLoaded(data, propertyParams = null) {\r\n        var reader = new Byte(data);\r\n        this._aniVersion = reader.readUTFString();\r\n        switch (this._aniVersion) {\r\n            case \"LAYAANIMATION:02\":\r\n                AnimationParser02.parse(this, reader);\r\n                break;\r\n            default:\r\n                AnimationParser01.parse(this, reader);\r\n        }\r\n    }\r\n    getAnimationCount() {\r\n        return this._anis.length;\r\n    }\r\n    getAnimation(aniIndex) {\r\n        return this._anis[aniIndex];\r\n    }\r\n    getAniDuration(aniIndex) {\r\n        return this._anis[aniIndex].playTime;\r\n    }\r\n    getNodes(aniIndex) {\r\n        return this._anis[aniIndex].nodes;\r\n    }\r\n    getNodeIndexWithName(aniIndex, name) {\r\n        return this._anis[aniIndex].bone3DMap[name];\r\n    }\r\n    getNodeCount(aniIndex) {\r\n        return this._anis[aniIndex].nodes.length;\r\n    }\r\n    getTotalkeyframesLength(aniIndex) {\r\n        return this._anis[aniIndex].totalKeyframeDatasLength;\r\n    }\r\n    getPublicExtData() {\r\n        return this._publicExtData;\r\n    }\r\n    getAnimationDataWithCache(key, cacheDatas, aniIndex, frameIndex) {\r\n        var aniDatas = cacheDatas[aniIndex];\r\n        if (!aniDatas) {\r\n            return null;\r\n        }\r\n        else {\r\n            var keyDatas = aniDatas[key];\r\n            if (!keyDatas)\r\n                return null;\r\n            else {\r\n                return keyDatas[frameIndex];\r\n            }\r\n        }\r\n    }\r\n    setAnimationDataWithCache(key, cacheDatas, aniIndex, frameIndex, data) {\r\n        var aniDatas = (cacheDatas[aniIndex]) || (cacheDatas[aniIndex] = {});\r\n        var aniDatasCache = (aniDatas[key]) || (aniDatas[key] = []);\r\n        aniDatasCache[frameIndex] = data;\r\n    }\r\n    getNodeKeyFrame(nodeframes, nodeid, tm) {\r\n        var cid = this._boneCurKeyFrm[nodeid];\r\n        var frmNum = nodeframes.length;\r\n        if (cid == void 0 || cid >= frmNum) {\r\n            cid = this._boneCurKeyFrm[nodeid] = 0;\r\n        }\r\n        var kinfo = nodeframes[cid];\r\n        var curFrmTm = kinfo.startTime;\r\n        var dt = tm - curFrmTm;\r\n        if (dt == 0 || (dt > 0 && kinfo.duration > dt)) {\r\n            return cid;\r\n        }\r\n        var i = 0;\r\n        if (dt > 0) {\r\n            tm = tm + 0.01;\r\n            for (i = cid + 1; i < frmNum; i++) {\r\n                kinfo = nodeframes[i];\r\n                if (kinfo.startTime <= tm && kinfo.startTime + kinfo.duration > tm) {\r\n                    this._boneCurKeyFrm[nodeid] = i;\r\n                    return i;\r\n                }\r\n            }\r\n            return frmNum - 1;\r\n        }\r\n        else {\r\n            for (i = 0; i < cid; i++) {\r\n                kinfo = nodeframes[i];\r\n                if (kinfo.startTime <= tm && kinfo.startTime + kinfo.duration > tm) {\r\n                    this._boneCurKeyFrm[nodeid] = i;\r\n                    return i;\r\n                }\r\n            }\r\n            return cid;\r\n        }\r\n        return 0;\r\n    }\r\n    getOriginalData(aniIndex, originalData, nodesFrameIndices, frameIndex, playCurTime) {\r\n        var oneAni = this._anis[aniIndex];\r\n        var nodes = oneAni.nodes;\r\n        var curKFrm = this._boneCurKeyFrm;\r\n        if (curKFrm.length < nodes.length) {\r\n            curKFrm.length = nodes.length;\r\n        }\r\n        var j = 0;\r\n        for (var i = 0, n = nodes.length, outOfs = 0; i < n; i++) {\r\n            var node = nodes[i];\r\n            var key;\r\n            var kfrm = node.keyFrame;\r\n            key = kfrm[this.getNodeKeyFrame(kfrm, i, playCurTime)];\r\n            node.dataOffset = outOfs;\r\n            var dt = playCurTime - key.startTime;\r\n            var lerpType = node.lerpType;\r\n            if (lerpType) {\r\n                switch (lerpType) {\r\n                    case 0:\r\n                    case 1:\r\n                        for (j = 0; j < node.keyframeWidth;)\r\n                            j += node.interpolationMethod[j](node, j, originalData, outOfs + j, key.data, dt, key.dData, key.duration, key.nextData);\r\n                        break;\r\n                    case 2:\r\n                        var interpolationData = key.interpolationData;\r\n                        var interDataLen = interpolationData.length;\r\n                        var dataIndex = 0;\r\n                        for (j = 0; j < interDataLen;) {\r\n                            var type = interpolationData[j];\r\n                            switch (type) {\r\n                                case 6:\r\n                                    j += AnimationTemplet.interpolation[type](node, dataIndex, originalData, outOfs + dataIndex, key.data, dt, key.dData, key.duration, key.nextData, interpolationData, j + 1);\r\n                                    break;\r\n                                case 7:\r\n                                    j += AnimationTemplet.interpolation[type](node, dataIndex, originalData, outOfs + dataIndex, key.data, dt, key.dData, key.duration, key.nextData, interpolationData, j + 1);\r\n                                    break;\r\n                                default:\r\n                                    j += AnimationTemplet.interpolation[type](node, dataIndex, originalData, outOfs + dataIndex, key.data, dt, key.dData, key.duration, key.nextData);\r\n                            }\r\n                            dataIndex++;\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n            else {\r\n                for (j = 0; j < node.keyframeWidth;)\r\n                    j += node.interpolationMethod[j](node, j, originalData, outOfs + j, key.data, dt, key.dData, key.duration, key.nextData);\r\n            }\r\n            outOfs += node.keyframeWidth;\r\n        }\r\n    }\r\n    getNodesCurrentFrameIndex(aniIndex, playCurTime) {\r\n        var ani = this._anis[aniIndex];\r\n        var nodes = ani.nodes;\r\n        if (aniIndex !== this.unfixedLastAniIndex) {\r\n            this.unfixedCurrentFrameIndexes = new Uint32Array(nodes.length);\r\n            this.unfixedCurrentTimes = new Float32Array(nodes.length);\r\n            this.unfixedLastAniIndex = aniIndex;\r\n        }\r\n        for (var i = 0, n = nodes.length; i < n; i++) {\r\n            var node = nodes[i];\r\n            if (playCurTime < this.unfixedCurrentTimes[i])\r\n                this.unfixedCurrentFrameIndexes[i] = 0;\r\n            this.unfixedCurrentTimes[i] = playCurTime;\r\n            while ((this.unfixedCurrentFrameIndexes[i] < node.keyFrame.length)) {\r\n                if (node.keyFrame[this.unfixedCurrentFrameIndexes[i]].startTime > this.unfixedCurrentTimes[i])\r\n                    break;\r\n                this.unfixedCurrentFrameIndexes[i]++;\r\n            }\r\n            this.unfixedCurrentFrameIndexes[i]--;\r\n        }\r\n        return this.unfixedCurrentFrameIndexes;\r\n    }\r\n    getOriginalDataUnfixedRate(aniIndex, originalData, playCurTime) {\r\n        var oneAni = this._anis[aniIndex];\r\n        var nodes = oneAni.nodes;\r\n        if (aniIndex !== this.unfixedLastAniIndex) {\r\n            this.unfixedCurrentFrameIndexes = new Uint32Array(nodes.length);\r\n            this.unfixedCurrentTimes = new Float32Array(nodes.length);\r\n            this.unfixedKeyframes = [];\r\n            this.unfixedLastAniIndex = aniIndex;\r\n        }\r\n        var j = 0;\r\n        for (var i = 0, n = nodes.length, outOfs = 0; i < n; i++) {\r\n            var node = nodes[i];\r\n            if (playCurTime < this.unfixedCurrentTimes[i])\r\n                this.unfixedCurrentFrameIndexes[i] = 0;\r\n            this.unfixedCurrentTimes[i] = playCurTime;\r\n            while (this.unfixedCurrentFrameIndexes[i] < node.keyFrame.length) {\r\n                if (node.keyFrame[this.unfixedCurrentFrameIndexes[i]].startTime > this.unfixedCurrentTimes[i])\r\n                    break;\r\n                this.unfixedKeyframes[i] = node.keyFrame[this.unfixedCurrentFrameIndexes[i]];\r\n                this.unfixedCurrentFrameIndexes[i]++;\r\n            }\r\n            var key = this.unfixedKeyframes[i];\r\n            node.dataOffset = outOfs;\r\n            var dt = playCurTime - key.startTime;\r\n            var lerpType = node.lerpType;\r\n            if (lerpType) {\r\n                switch (node.lerpType) {\r\n                    case 0:\r\n                    case 1:\r\n                        for (j = 0; j < node.keyframeWidth;)\r\n                            j += node.interpolationMethod[j](node, j, originalData, outOfs + j, key.data, dt, key.dData, key.duration, key.nextData);\r\n                        break;\r\n                    case 2:\r\n                        var interpolationData = key.interpolationData;\r\n                        var interDataLen = interpolationData.length;\r\n                        var dataIndex = 0;\r\n                        for (j = 0; j < interDataLen;) {\r\n                            var type = interpolationData[j];\r\n                            switch (type) {\r\n                                case 6:\r\n                                    j += AnimationTemplet.interpolation[type](node, dataIndex, originalData, outOfs + dataIndex, key.data, dt, key.dData, key.duration, key.nextData, interpolationData, j + 1);\r\n                                    break;\r\n                                case 7:\r\n                                    j += AnimationTemplet.interpolation[type](node, dataIndex, originalData, outOfs + dataIndex, key.data, dt, key.dData, key.duration, key.nextData, interpolationData, j + 1);\r\n                                    break;\r\n                                default:\r\n                                    j += AnimationTemplet.interpolation[type](node, dataIndex, originalData, outOfs + dataIndex, key.data, dt, key.dData, key.duration, key.nextData);\r\n                            }\r\n                            dataIndex++;\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n            else {\r\n                for (j = 0; j < node.keyframeWidth;)\r\n                    j += node.interpolationMethod[j](node, j, originalData, outOfs + j, key.data, dt, key.dData, key.duration, key.nextData);\r\n            }\r\n            outOfs += node.keyframeWidth;\r\n        }\r\n    }\r\n}\r\nAnimationTemplet.interpolation = [AnimationTemplet._LinearInterpolation_0, AnimationTemplet._QuaternionInterpolation_1, AnimationTemplet._AngleInterpolation_2, AnimationTemplet._RadiansInterpolation_3, AnimationTemplet._Matrix4x4Interpolation_4, AnimationTemplet._NoInterpolation_5, AnimationTemplet._BezierInterpolation_6, AnimationTemplet._BezierInterpolation_7];\r\nIAniLib.AnimationTemplet = AnimationTemplet;\r\n",
  "references": [
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/ani/AnimationNodeContent.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/ani/AnimationContent.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/ani/KeyFramesContent.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/ani/AnimationParser01.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/ani/AnimationParser02.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/resource/Resource.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/maths/MathUtil.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/ani/AniLibPack.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/utils/Byte.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/ani/math/BezierLerp.ts"
  ],
  "dts": {
    "name": "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/ani/AnimationTemplet.d.ts",
    "writeByteOrderMark": false,
    "text": "import { AnimationNodeContent } from \"./AnimationNodeContent\";\r\nimport { AnimationContent } from \"./AnimationContent\";\r\nimport { KeyFramesContent } from \"./KeyFramesContent\";\r\nimport { Resource } from \"../resource/Resource\";\r\nexport declare class AnimationTemplet extends Resource {\r\n    static interpolation: any[];\r\n    private static _LinearInterpolation_0;\r\n    private static _QuaternionInterpolation_1;\r\n    private static _AngleInterpolation_2;\r\n    private static _RadiansInterpolation_3;\r\n    private static _Matrix4x4Interpolation_4;\r\n    private static _NoInterpolation_5;\r\n    private static _BezierInterpolation_6;\r\n    private static _BezierInterpolation_7;\r\n    _aniVersion: string;\r\n    _anis: AnimationContent[];\r\n    _aniMap: any;\r\n    _publicExtData: ArrayBuffer;\r\n    _useParent: boolean;\r\n    protected unfixedCurrentFrameIndexes: Uint32Array;\r\n    protected unfixedCurrentTimes: Float32Array;\r\n    protected unfixedKeyframes: KeyFramesContent[];\r\n    protected unfixedLastAniIndex: number;\r\n    _aniClassName: string;\r\n    _animationDatasCache: any;\r\n    _fullFrames: any[];\r\n    private _boneCurKeyFrm;\r\n    constructor();\r\n    parse(data: ArrayBuffer): void;\r\n    _calculateKeyFrame(node: AnimationNodeContent, keyframeCount: number, keyframeDataCount: number): void;\r\n    _onAsynLoaded(data: any, propertyParams?: any): void;\r\n    getAnimationCount(): number;\r\n    getAnimation(aniIndex: number): any;\r\n    getAniDuration(aniIndex: number): number;\r\n    getNodes(aniIndex: number): any;\r\n    getNodeIndexWithName(aniIndex: number, name: string): number;\r\n    getNodeCount(aniIndex: number): number;\r\n    getTotalkeyframesLength(aniIndex: number): number;\r\n    getPublicExtData(): ArrayBuffer;\r\n    getAnimationDataWithCache(key: any, cacheDatas: any, aniIndex: number, frameIndex: number): Float32Array;\r\n    setAnimationDataWithCache(key: any, cacheDatas: any[], aniIndex: number, frameIndex: number, data: any): void;\r\n    getNodeKeyFrame(nodeframes: KeyFramesContent[], nodeid: number, tm: number): number;\r\n    getOriginalData(aniIndex: number, originalData: Float32Array, nodesFrameIndices: any[], frameIndex: number, playCurTime: number): void;\r\n    getNodesCurrentFrameIndex(aniIndex: number, playCurTime: number): Uint32Array;\r\n    getOriginalDataUnfixedRate(aniIndex: number, originalData: Float32Array, playCurTime: number): void;\r\n}\r\n"
  }
}

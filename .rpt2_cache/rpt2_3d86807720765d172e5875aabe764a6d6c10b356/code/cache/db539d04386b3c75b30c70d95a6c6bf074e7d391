{
  "code": "import { TextAtlas } from \"./TextAtlas\";\r\nimport { TextTexture } from \"./TextTexture\";\r\nimport { Point } from \"../../maths/Point\";\r\nimport { RenderInfo } from \"../../renders/RenderInfo\";\r\nimport { Texture } from \"../../resource/Texture\";\r\nimport { FontInfo } from \"../../utils/FontInfo\";\r\nimport { WordText } from \"../../utils/WordText\";\r\nimport { CharRenderInfo } from \"./CharRenderInfo\";\r\nimport { CharRender_Canvas } from \"./CharRender_Canvas\";\r\nimport { CharRender_Native } from \"./CharRender_Native\";\r\nimport { ILaya } from \"../../../ILaya\";\r\nexport class TextRender {\r\n    constructor() {\r\n        this.fontSizeInfo = {};\r\n        this.mapFont = {};\r\n        this.fontID = 0;\r\n        this.mapColor = [];\r\n        this.colorID = 0;\r\n        this.fontScaleX = 1.0;\r\n        this.fontScaleY = 1.0;\r\n        this._curStrPos = 0;\r\n        this.textAtlases = [];\r\n        this.isoTextures = [];\r\n        this.lastFont = null;\r\n        this.fontSizeW = 0;\r\n        this.fontSizeH = 0;\r\n        this.fontSizeOffX = 0;\r\n        this.fontSizeOffY = 0;\r\n        this.renderPerChar = true;\r\n        this.tmpAtlasPos = new Point();\r\n        this.textureMem = 0;\r\n        ILaya.TextAtlas = TextAtlas;\r\n        var bugIOS = false;\r\n        var miniadp = ILaya.Laya['MiniAdpter'];\r\n        if (miniadp && miniadp.systemInfo && miniadp.systemInfo.system) {\r\n            bugIOS = miniadp.systemInfo.system.toLowerCase() === 'ios 10.1.1';\r\n        }\r\n        if ((ILaya.Browser.onMiniGame || ILaya.Browser.onTTMiniGame || ILaya.Browser.onBLMiniGame || ILaya.Browser.onAlipayMiniGame || ILaya.Browser.onTBMiniGame) && !bugIOS)\r\n            TextRender.isWan1Wan = true;\r\n        this.charRender = ILaya.Render.isConchApp ? (new CharRender_Native()) : (new CharRender_Canvas(2048, 2048, TextRender.scaleFontWithCtx, !TextRender.isWan1Wan, false));\r\n        TextRender.textRenderInst = this;\r\n        ILaya.Laya['textRender'] = this;\r\n        TextRender.atlasWidth2 = TextRender.atlasWidth * TextRender.atlasWidth;\r\n    }\r\n    setFont(font) {\r\n        if (this.lastFont == font)\r\n            return;\r\n        this.lastFont = font;\r\n        var fontsz = this.getFontSizeInfo(font._family);\r\n        var offx = fontsz >> 24;\r\n        var offy = (fontsz >> 16) & 0xff;\r\n        var fw = (fontsz >> 8) & 0xff;\r\n        var fh = fontsz & 0xff;\r\n        var k = font._size / TextRender.standardFontSize;\r\n        this.fontSizeOffX = Math.ceil(offx * k);\r\n        this.fontSizeOffY = Math.ceil(offy * k);\r\n        this.fontSizeW = Math.ceil(fw * k);\r\n        this.fontSizeH = Math.ceil(fh * k);\r\n        if (font._font.indexOf('italic') >= 0) {\r\n            this.fontStr = font._font.replace('italic', '');\r\n        }\r\n        else {\r\n            this.fontStr = font._font;\r\n        }\r\n    }\r\n    getNextChar(str) {\r\n        var len = str.length;\r\n        var start = this._curStrPos;\r\n        if (!str.substring)\r\n            return null;\r\n        if (start >= len)\r\n            return null;\r\n        var i = start;\r\n        var state = 0;\r\n        for (; i < len; i++) {\r\n            var c = str.charCodeAt(i);\r\n            if ((c >>> 11) == 0x1b) {\r\n                if (state == 1)\r\n                    break;\r\n                state = 1;\r\n                i++;\r\n            }\r\n            else if (c === 0xfe0e || c === 0xfe0f) {\r\n            }\r\n            else if (c == 0x200d) {\r\n                state = 2;\r\n            }\r\n            else {\r\n                if (state == 0)\r\n                    state = 1;\r\n                else if (state == 1)\r\n                    break;\r\n                else if (state == 2) {\r\n                }\r\n            }\r\n        }\r\n        this._curStrPos = i;\r\n        return str.substring(start, i);\r\n    }\r\n    filltext(ctx, data, x, y, fontStr, color, strokeColor, lineWidth, textAlign, underLine = 0) {\r\n        if (data.length <= 0)\r\n            return;\r\n        var font = FontInfo.Parse(fontStr);\r\n        var nTextAlign = 0;\r\n        switch (textAlign) {\r\n            case 'center':\r\n                nTextAlign = ILaya.Context.ENUM_TEXTALIGN_CENTER;\r\n                break;\r\n            case 'right':\r\n                nTextAlign = ILaya.Context.ENUM_TEXTALIGN_RIGHT;\r\n                break;\r\n        }\r\n        this._fast_filltext(ctx, data, null, x, y, font, color, strokeColor, lineWidth, nTextAlign, underLine);\r\n    }\r\n    fillWords(ctx, data, x, y, fontStr, color, strokeColor, lineWidth) {\r\n        if (!data)\r\n            return;\r\n        if (data.length <= 0)\r\n            return;\r\n        var font = typeof (fontStr) === 'string' ? FontInfo.Parse(fontStr) : fontStr;\r\n        this._fast_filltext(ctx, null, data, x, y, font, color, strokeColor, lineWidth, 0, 0);\r\n    }\r\n    _fast_filltext(ctx, data, htmlchars, x, y, font, color, strokeColor, lineWidth, textAlign, underLine = 0) {\r\n        if (data && !(data.length >= 1))\r\n            return;\r\n        if (htmlchars && htmlchars.length < 1)\r\n            return;\r\n        if (lineWidth < 0)\r\n            lineWidth = 0;\r\n        this.setFont(font);\r\n        this.fontScaleX = this.fontScaleY = 1.0;\r\n        if (TextRender.scaleFontWithCtx) {\r\n            var sx = 1;\r\n            var sy = 1;\r\n            if (!ILaya.Render.isConchApp || (window.conchTextCanvas.scale)) {\r\n                sx = ctx.getMatScaleX();\r\n                sy = ctx.getMatScaleY();\r\n            }\r\n            if (sx < 1e-4 || sy < 1e-1)\r\n                return;\r\n            if (sx > 1)\r\n                this.fontScaleX = sx;\r\n            if (sy > 1)\r\n                this.fontScaleY = sy;\r\n        }\r\n        font._italic && (ctx._italicDeg = 13);\r\n        var wt = data;\r\n        var isWT = !htmlchars && (data instanceof WordText);\r\n        var str = data && data.toString();\r\n        var isHtmlChar = !!htmlchars;\r\n        var sameTexData = isWT ? wt.pageChars : [];\r\n        var strWidth = 0;\r\n        if (isWT) {\r\n            str = wt._text;\r\n            strWidth = wt.width;\r\n            if (strWidth < 0) {\r\n                strWidth = wt.width = this.charRender.getWidth(this.fontStr, str);\r\n            }\r\n        }\r\n        else {\r\n            strWidth = str ? this.charRender.getWidth(this.fontStr, str) : 0;\r\n        }\r\n        switch (textAlign) {\r\n            case ILaya.Context.ENUM_TEXTALIGN_CENTER:\r\n                x -= strWidth / 2;\r\n                break;\r\n            case ILaya.Context.ENUM_TEXTALIGN_RIGHT:\r\n                x -= strWidth;\r\n                break;\r\n        }\r\n        if (wt && sameTexData) {\r\n            if (this.hasFreedText(sameTexData)) {\r\n                sameTexData = wt.pageChars = [];\r\n            }\r\n        }\r\n        var ri = null;\r\n        var splitTex = this.renderPerChar = (!isWT) || TextRender.forceSplitRender || isHtmlChar || (isWT && wt.splitRender);\r\n        if (!sameTexData || sameTexData.length < 1) {\r\n            if (isWT) {\r\n                wt.scalex = this.fontScaleX;\r\n                wt.scaley = this.fontScaleY;\r\n            }\r\n            if (splitTex) {\r\n                var stx = 0;\r\n                var sty = 0;\r\n                this._curStrPos = 0;\r\n                var curstr;\r\n                while (true) {\r\n                    if (htmlchars) {\r\n                        var chc = htmlchars[this._curStrPos++];\r\n                        if (chc) {\r\n                            curstr = chc.char;\r\n                            stx = chc.x;\r\n                            sty = chc.y;\r\n                        }\r\n                        else {\r\n                            curstr = null;\r\n                        }\r\n                    }\r\n                    else {\r\n                        curstr = this.getNextChar(str);\r\n                    }\r\n                    if (!curstr)\r\n                        break;\r\n                    ri = this.getCharRenderInfo(curstr, font, color, strokeColor, lineWidth, false);\r\n                    if (!ri) {\r\n                        break;\r\n                    }\r\n                    if (ri.isSpace) {\r\n                    }\r\n                    else {\r\n                        var add = sameTexData[ri.tex.id];\r\n                        if (!add) {\r\n                            var o1 = { texgen: ri.tex.genID, tex: ri.tex, words: [] };\r\n                            sameTexData[ri.tex.id] = o1;\r\n                            add = o1.words;\r\n                        }\r\n                        else {\r\n                            add = add.words;\r\n                        }\r\n                        add.push({ ri: ri, x: stx, y: sty, w: ri.bmpWidth / this.fontScaleX, h: ri.bmpHeight / this.fontScaleY });\r\n                        stx += ri.width;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                var margin = ILaya.Render.isConchApp ? 0 : (font._size / 3 | 0);\r\n                var isotex = TextRender.noAtlas || (strWidth + margin + margin) * this.fontScaleX > TextRender.atlasWidth;\r\n                ri = this.getCharRenderInfo(str, font, color, strokeColor, lineWidth, isotex);\r\n                sameTexData[0] = { texgen: ri.tex.genID, tex: ri.tex, words: [{ ri: ri, x: 0, y: 0, w: ri.bmpWidth / this.fontScaleX, h: ri.bmpHeight / this.fontScaleY }] };\r\n            }\r\n        }\r\n        this._drawResortedWords(ctx, x, y, sameTexData);\r\n        ctx._italicDeg = 0;\r\n    }\r\n    _drawResortedWords(ctx, startx, starty, samePagesData) {\r\n        var isLastRender = ctx._charSubmitCache ? ctx._charSubmitCache._enable : false;\r\n        var mat = ctx._curMat;\r\n        var slen = samePagesData.length;\r\n        for (var id in samePagesData) {\r\n            var dt = samePagesData[id];\r\n            if (!dt)\r\n                continue;\r\n            var pri = dt.words;\r\n            var pisz = pri.length;\r\n            if (pisz <= 0)\r\n                continue;\r\n            var tex = samePagesData[id].tex;\r\n            for (var j = 0; j < pisz; j++) {\r\n                var riSaved = pri[j];\r\n                var ri = riSaved.ri;\r\n                if (ri.isSpace)\r\n                    continue;\r\n                ri.touch();\r\n                ctx.drawTexAlign = true;\r\n                if (ILaya.Render.isConchApp) {\r\n                    ctx._drawTextureM(tex.texture, startx + riSaved.x - ri.orix, starty + riSaved.y - ri.oriy, riSaved.w, riSaved.h, null, 1.0, ri.uv);\r\n                }\r\n                else {\r\n                    let t = tex;\r\n                    ctx._inner_drawTexture(t.texture, t.id, startx + riSaved.x - ri.orix, starty + riSaved.y - ri.oriy, riSaved.w, riSaved.h, mat, ri.uv, 1.0, isLastRender);\r\n                }\r\n                if (ctx.touches) {\r\n                    ctx.touches.push(ri);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    hasFreedText(txts) {\r\n        for (let i in txts) {\r\n            var pri = txts[i];\r\n            if (!pri)\r\n                continue;\r\n            var tex = pri.tex;\r\n            if (tex.__destroyed || tex.genID != pri.texgen) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    getCharRenderInfo(str, font, color, strokeColor, lineWidth, isoTexture = false) {\r\n        var fid = this.mapFont[font._family];\r\n        if (fid == undefined) {\r\n            this.mapFont[font._family] = fid = this.fontID++;\r\n        }\r\n        var key = str + '_' + fid + '_' + font._size + '_' + color;\r\n        if (lineWidth > 0)\r\n            key += '_' + strokeColor + lineWidth;\r\n        if (font._bold)\r\n            key += 'P';\r\n        if (this.fontScaleX != 1 || this.fontScaleY != 1) {\r\n            key += (this.fontScaleX * 20 | 0) + '_' + (this.fontScaleY * 20 | 0);\r\n        }\r\n        var i = 0;\r\n        var sz = this.textAtlases.length;\r\n        var ri;\r\n        var atlas;\r\n        if (!isoTexture) {\r\n            for (i = 0; i < sz; i++) {\r\n                atlas = this.textAtlases[i];\r\n                ri = atlas.charMaps[key];\r\n                if (ri) {\r\n                    ri.touch();\r\n                    return ri;\r\n                }\r\n            }\r\n        }\r\n        ri = new CharRenderInfo();\r\n        this.charRender.scale(this.fontScaleX, this.fontScaleY);\r\n        ri.char = str;\r\n        ri.height = font._size;\r\n        var margin = ILaya.Render.isConchApp ? 0 : (font._size / 3 | 0);\r\n        var imgdt = null;\r\n        if (!lineWidth) {\r\n            lineWidth = 0;\r\n        }\r\n        var w1 = Math.ceil((this.charRender.getWidth(this.fontStr, str) + 2 * lineWidth) * this.fontScaleX);\r\n        if (w1 > this.charRender.canvasWidth) {\r\n            this.charRender.canvasWidth = Math.min(2048, w1 + margin * 2);\r\n        }\r\n        if (isoTexture) {\r\n            this.charRender.fontsz = font._size;\r\n            imgdt = this.charRender.getCharBmp(str, this.fontStr, lineWidth, color, strokeColor, ri, margin, margin, margin, margin, null);\r\n            if (imgdt) {\r\n                var tex = TextTexture.getTextTexture(imgdt.width, imgdt.height);\r\n                tex.addChar(imgdt, 0, 0, ri.uv);\r\n                ri.tex = tex;\r\n                ri.orix = margin;\r\n                ri.oriy = margin;\r\n                tex.ri = ri;\r\n                this.isoTextures.push(tex);\r\n            }\r\n        }\r\n        else {\r\n            var len = str.length;\r\n            if (len > 1) {\r\n            }\r\n            var lineExt = lineWidth * 1;\r\n            var fw = Math.ceil((this.fontSizeW + lineExt * 2) * this.fontScaleX);\r\n            var fh = Math.ceil((this.fontSizeH + lineExt * 2) * this.fontScaleY);\r\n            TextRender.imgdtRect[0] = ((margin - this.fontSizeOffX - lineExt) * this.fontScaleX) | 0;\r\n            TextRender.imgdtRect[1] = ((margin - this.fontSizeOffY - lineExt) * this.fontScaleY) | 0;\r\n            if (this.renderPerChar || len == 1) {\r\n                TextRender.imgdtRect[2] = Math.max(w1, fw);\r\n                TextRender.imgdtRect[3] = Math.max(w1, fh);\r\n            }\r\n            else {\r\n                TextRender.imgdtRect[2] = -1;\r\n                TextRender.imgdtRect[3] = fh;\r\n            }\r\n            this.charRender.fontsz = font._size;\r\n            imgdt = this.charRender.getCharBmp(str, this.fontStr, lineWidth, color, strokeColor, ri, margin, margin, margin, margin, TextRender.imgdtRect);\r\n            if (imgdt) {\r\n                atlas = this.addBmpData(imgdt, ri);\r\n                if (TextRender.isWan1Wan) {\r\n                    ri.orix = margin;\r\n                    ri.oriy = margin;\r\n                }\r\n                else {\r\n                    ri.orix = (this.fontSizeOffX + lineExt);\r\n                    ri.oriy = (this.fontSizeOffY + lineExt);\r\n                }\r\n                atlas.charMaps[key] = ri;\r\n            }\r\n        }\r\n        return ri;\r\n    }\r\n    addBmpData(data, ri) {\r\n        var w = data.width;\r\n        var h = data.height;\r\n        var sz = this.textAtlases.length;\r\n        var atlas;\r\n        var find = false;\r\n        for (var i = 0; i < sz; i++) {\r\n            atlas = this.textAtlases[i];\r\n            find = atlas.getAEmpty(w, h, this.tmpAtlasPos);\r\n            if (find) {\r\n                break;\r\n            }\r\n        }\r\n        if (!find) {\r\n            atlas = new TextAtlas();\r\n            this.textAtlases.push(atlas);\r\n            find = atlas.getAEmpty(w, h, this.tmpAtlasPos);\r\n            if (!find) {\r\n                throw 'err1';\r\n            }\r\n            this.cleanAtlases();\r\n        }\r\n        if (find) {\r\n            atlas.texture.addChar(data, this.tmpAtlasPos.x, this.tmpAtlasPos.y, ri.uv);\r\n            ri.tex = atlas.texture;\r\n        }\r\n        return atlas;\r\n    }\r\n    GC() {\r\n        var i = 0;\r\n        var sz = this.textAtlases.length;\r\n        var dt = 0;\r\n        var destroyDt = TextRender.destroyAtlasDt;\r\n        var totalUsedRate = 0;\r\n        var totalUsedRateAtlas = 0;\r\n        var curloop = RenderInfo.loopCount;\r\n        var maxWasteRateID = -1;\r\n        var maxWasteRate = 0;\r\n        var tex = null;\r\n        var curatlas = null;\r\n        for (; i < sz; i++) {\r\n            curatlas = this.textAtlases[i];\r\n            tex = curatlas.texture;\r\n            if (tex) {\r\n                totalUsedRate += tex.curUsedCovRate;\r\n                totalUsedRateAtlas += tex.curUsedCovRateAtlas;\r\n                var waste = curatlas.usedRate - tex.curUsedCovRateAtlas;\r\n                if (maxWasteRate < waste) {\r\n                    maxWasteRate = waste;\r\n                    maxWasteRateID = i;\r\n                }\r\n            }\r\n            dt = curloop - curatlas.texture.lastTouchTm;\r\n            if (dt > destroyDt) {\r\n                TextRender.showLog && console.log('TextRender GC delete atlas ' + tex ? curatlas.texture.id : 'unk');\r\n                curatlas.destroy();\r\n                this.textAtlases[i] = this.textAtlases[sz - 1];\r\n                sz--;\r\n                i--;\r\n                maxWasteRateID = -1;\r\n            }\r\n        }\r\n        this.textAtlases.length = sz;\r\n        sz = this.isoTextures.length;\r\n        for (i = 0; i < sz; i++) {\r\n            tex = this.isoTextures[i];\r\n            dt = curloop - tex.lastTouchTm;\r\n            if (dt > TextRender.destroyUnusedTextureDt) {\r\n                tex.ri.deleted = true;\r\n                tex.ri.tex = null;\r\n                tex.destroy();\r\n                this.isoTextures[i] = this.isoTextures[sz - 1];\r\n                sz--;\r\n                i--;\r\n            }\r\n        }\r\n        this.isoTextures.length = sz;\r\n        var needGC = this.textAtlases.length > 1 && this.textAtlases.length - totalUsedRateAtlas >= 2;\r\n        if (TextRender.atlasWidth * TextRender.atlasWidth * 4 * this.textAtlases.length > TextRender.cleanMem || needGC || TextRender.simClean) {\r\n            TextRender.simClean = false;\r\n            TextRender.showLog && console.log('清理使用率低的贴图。总使用率:', totalUsedRateAtlas, ':', this.textAtlases.length, '最差贴图:' + maxWasteRateID);\r\n            if (maxWasteRateID >= 0) {\r\n                curatlas = this.textAtlases[maxWasteRateID];\r\n                curatlas.destroy();\r\n                this.textAtlases[maxWasteRateID] = this.textAtlases[this.textAtlases.length - 1];\r\n                this.textAtlases.length = this.textAtlases.length - 1;\r\n            }\r\n        }\r\n        TextTexture.clean();\r\n    }\r\n    cleanAtlases() {\r\n    }\r\n    getCharBmp(c) {\r\n    }\r\n    checkBmpLine(data, l, sx, ex) {\r\n        if (this.bmpData32.buffer != data.data.buffer) {\r\n            this.bmpData32 = new Uint32Array(data.data.buffer);\r\n        }\r\n        var stpos = data.width * l + sx;\r\n        for (var x = sx; x < ex; x++) {\r\n            if (this.bmpData32[stpos++] != 0)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    updateBbx(data, curbbx, onlyH = false) {\r\n        var w = data.width;\r\n        var h = data.height;\r\n        var x = 0;\r\n        var sy = curbbx[1];\r\n        var ey = 0;\r\n        var y = sy;\r\n        if (this.checkBmpLine(data, sy, 0, w)) {\r\n            while (true) {\r\n                y = (sy + ey) / 2 | 0;\r\n                if (y + 1 >= sy) {\r\n                    curbbx[1] = y;\r\n                    break;\r\n                }\r\n                if (this.checkBmpLine(data, y, 0, w)) {\r\n                    sy = y;\r\n                }\r\n                else {\r\n                    ey = y;\r\n                }\r\n            }\r\n        }\r\n        if (curbbx[3] > h)\r\n            curbbx[3] = h;\r\n        else {\r\n            y = sy = curbbx[3];\r\n            ey = h;\r\n            if (this.checkBmpLine(data, sy, 0, w)) {\r\n                while (true) {\r\n                    y = (sy + ey) / 2 | 0;\r\n                    if (y - 1 <= sy) {\r\n                        curbbx[3] = y;\r\n                        break;\r\n                    }\r\n                    if (this.checkBmpLine(data, y, 0, w)) {\r\n                        sy = y;\r\n                    }\r\n                    else {\r\n                        ey = y;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (onlyH)\r\n            return;\r\n        var minx = curbbx[0];\r\n        var stpos = w * curbbx[1];\r\n        for (y = curbbx[1]; y < curbbx[3]; y++) {\r\n            for (x = 0; x < minx; x++) {\r\n                if (this.bmpData32[stpos + x] != 0) {\r\n                    minx = x;\r\n                    break;\r\n                }\r\n            }\r\n            stpos += w;\r\n        }\r\n        curbbx[0] = minx;\r\n        var maxx = curbbx[2];\r\n        stpos = w * curbbx[1];\r\n        for (y = curbbx[1]; y < curbbx[3]; y++) {\r\n            for (x = maxx; x < w; x++) {\r\n                if (this.bmpData32[stpos + x] != 0) {\r\n                    maxx = x;\r\n                    break;\r\n                }\r\n            }\r\n            stpos += w;\r\n        }\r\n        curbbx[2] = maxx;\r\n    }\r\n    getFontSizeInfo(font) {\r\n        var finfo = this.fontSizeInfo[font];\r\n        if (finfo != undefined)\r\n            return finfo;\r\n        var fontstr = 'bold ' + TextRender.standardFontSize + 'px ' + font;\r\n        if (TextRender.isWan1Wan) {\r\n            this.fontSizeW = this.charRender.getWidth(fontstr, '有') * 1.5;\r\n            this.fontSizeH = TextRender.standardFontSize * 1.5;\r\n            var szinfo = this.fontSizeW << 8 | this.fontSizeH;\r\n            this.fontSizeInfo[font] = szinfo;\r\n            return szinfo;\r\n        }\r\n        TextRender.pixelBBX[0] = TextRender.standardFontSize / 2;\r\n        TextRender.pixelBBX[1] = TextRender.standardFontSize / 2;\r\n        TextRender.pixelBBX[2] = TextRender.standardFontSize;\r\n        TextRender.pixelBBX[3] = TextRender.standardFontSize;\r\n        var orix = 16;\r\n        var oriy = 16;\r\n        var marginr = 16;\r\n        var marginb = 16;\r\n        this.charRender.scale(1, 1);\r\n        TextRender.tmpRI.height = TextRender.standardFontSize;\r\n        this.charRender.fontsz = TextRender.standardFontSize;\r\n        var bmpdt = this.charRender.getCharBmp('g', fontstr, 0, 'red', null, TextRender.tmpRI, orix, oriy, marginr, marginb);\r\n        if (ILaya.Render.isConchApp) {\r\n            bmpdt.data = new Uint8ClampedArray(bmpdt.data);\r\n        }\r\n        this.bmpData32 = new Uint32Array(bmpdt.data.buffer);\r\n        this.updateBbx(bmpdt, TextRender.pixelBBX, false);\r\n        bmpdt = this.charRender.getCharBmp('有', fontstr, 0, 'red', null, TextRender.tmpRI, oriy, oriy, marginr, marginb);\r\n        if (ILaya.Render.isConchApp) {\r\n            bmpdt.data = new Uint8ClampedArray(bmpdt.data);\r\n        }\r\n        this.bmpData32 = new Uint32Array(bmpdt.data.buffer);\r\n        if (TextRender.pixelBBX[2] < orix + TextRender.tmpRI.width)\r\n            TextRender.pixelBBX[2] = orix + TextRender.tmpRI.width;\r\n        this.updateBbx(bmpdt, TextRender.pixelBBX, false);\r\n        if (ILaya.Render.isConchApp) {\r\n            orix = 0;\r\n            oriy = 0;\r\n        }\r\n        var xoff = Math.max(orix - TextRender.pixelBBX[0], 0);\r\n        var yoff = Math.max(oriy - TextRender.pixelBBX[1], 0);\r\n        var bbxw = TextRender.pixelBBX[2] - TextRender.pixelBBX[0];\r\n        var bbxh = TextRender.pixelBBX[3] - TextRender.pixelBBX[1];\r\n        var sizeinfo = xoff << 24 | yoff << 16 | bbxw << 8 | bbxh;\r\n        this.fontSizeInfo[font] = sizeinfo;\r\n        return sizeinfo;\r\n    }\r\n    printDbgInfo() {\r\n        console.log('图集个数:' + this.textAtlases.length + ',每个图集大小:' + TextRender.atlasWidth + 'x' + TextRender.atlasWidth, ' 用canvas:', TextRender.isWan1Wan);\r\n        console.log('图集占用空间:' + (TextRender.atlasWidth * TextRender.atlasWidth * 4 / 1024 / 1024 * this.textAtlases.length) + 'M');\r\n        console.log('缓存用到的字体:');\r\n        for (var f in this.mapFont) {\r\n            var fontsz = this.getFontSizeInfo(f);\r\n            var offx = fontsz >> 24;\r\n            var offy = (fontsz >> 16) & 0xff;\r\n            var fw = (fontsz >> 8) & 0xff;\r\n            var fh = fontsz & 0xff;\r\n            console.log('    ' + f, ' off:', offx, offy, ' size:', fw, fh);\r\n        }\r\n        var num = 0;\r\n        console.log('缓存数据:');\r\n        var totalUsedRate = 0;\r\n        var totalUsedRateAtlas = 0;\r\n        this.textAtlases.forEach(function (a) {\r\n            var id = a.texture.id;\r\n            var dt = RenderInfo.loopCount - a.texture.lastTouchTm;\r\n            var dtstr = dt > 0 ? ('' + dt + '帧以前') : '当前帧';\r\n            totalUsedRate += a.texture.curUsedCovRate;\r\n            totalUsedRateAtlas += a.texture.curUsedCovRateAtlas;\r\n            console.log('--图集(id:' + id + ',当前使用率:' + (a.texture.curUsedCovRate * 1000 | 0) + '‰', '当前图集使用率:', (a.texture.curUsedCovRateAtlas * 100 | 0) + '%', '图集使用率:', (a.usedRate * 100 | 0), '%, 使用于:' + dtstr + ')--:');\r\n            for (var k in a.charMaps) {\r\n                var ri = a.charMaps[k];\r\n                console.log('     off:', ri.orix, ri.oriy, ' bmp宽高:', ri.bmpWidth, ri.bmpHeight, '无效:', ri.deleted, 'touchdt:', (RenderInfo.loopCount - ri.touchTick), '位置:', ri.uv[0] * TextRender.atlasWidth | 0, ri.uv[1] * TextRender.atlasWidth | 0, '字符:', ri.char, 'key:', k);\r\n                num++;\r\n            }\r\n        });\r\n        console.log('独立贴图文字(' + this.isoTextures.length + '个):');\r\n        this.isoTextures.forEach(function (tex) {\r\n            console.log('    size:', tex._texW, tex._texH, 'touch间隔:', (RenderInfo.loopCount - tex.lastTouchTm), 'char:', tex.ri.char);\r\n        });\r\n        console.log('总缓存:', num, '总使用率:', totalUsedRate, '总当前图集使用率:', totalUsedRateAtlas);\r\n    }\r\n    showAtlas(n, bgcolor, x, y, w, h) {\r\n        if (!this.textAtlases[n]) {\r\n            console.log('没有这个图集');\r\n            return null;\r\n        }\r\n        var sp = new ILaya.Sprite();\r\n        var texttex = this.textAtlases[n].texture;\r\n        var texture = {\r\n            width: TextRender.atlasWidth,\r\n            height: TextRender.atlasWidth,\r\n            sourceWidth: TextRender.atlasWidth,\r\n            sourceHeight: TextRender.atlasWidth,\r\n            offsetX: 0,\r\n            offsetY: 0,\r\n            getIsReady: function () { return true; },\r\n            _addReference: function () { },\r\n            _removeReference: function () { },\r\n            _getSource: function () { return texttex._getSource(); },\r\n            bitmap: { id: texttex.id },\r\n            _uv: Texture.DEF_UV\r\n        };\r\n        sp.size = function (w, h) {\r\n            this.width = w;\r\n            this.height = h;\r\n            sp.graphics.clear();\r\n            sp.graphics.drawRect(0, 0, sp.width, sp.height, bgcolor);\r\n            sp.graphics.drawTexture(texture, 0, 0, sp.width, sp.height);\r\n            return this;\r\n        };\r\n        sp.graphics.drawRect(0, 0, w, h, bgcolor);\r\n        sp.graphics.drawTexture(texture, 0, 0, w, h);\r\n        sp.pos(x, y);\r\n        ILaya.stage.addChild(sp);\r\n        return sp;\r\n    }\r\n    filltext_native(ctx, data, htmlchars, x, y, fontStr, color, strokeColor, lineWidth, textAlign, underLine = 0) {\r\n        if (data && data.length <= 0)\r\n            return;\r\n        if (htmlchars && htmlchars.length < 1)\r\n            return;\r\n        var font = FontInfo.Parse(fontStr);\r\n        var nTextAlign = 0;\r\n        switch (textAlign) {\r\n            case 'center':\r\n                nTextAlign = ILaya.Context.ENUM_TEXTALIGN_CENTER;\r\n                break;\r\n            case 'right':\r\n                nTextAlign = ILaya.Context.ENUM_TEXTALIGN_RIGHT;\r\n                break;\r\n        }\r\n        return this._fast_filltext(ctx, data, htmlchars, x, y, font, color, strokeColor, lineWidth, nTextAlign, underLine);\r\n    }\r\n}\r\nTextRender.useOldCharBook = false;\r\nTextRender.atlasWidth = 1024;\r\nTextRender.noAtlas = false;\r\nTextRender.forceSplitRender = false;\r\nTextRender.forceWholeRender = false;\r\nTextRender.scaleFontWithCtx = true;\r\nTextRender.standardFontSize = 32;\r\nTextRender.destroyAtlasDt = 10;\r\nTextRender.checkCleanTextureDt = 2000;\r\nTextRender.destroyUnusedTextureDt = 3000;\r\nTextRender.cleanMem = 100 * 1024 * 1024;\r\nTextRender.isWan1Wan = false;\r\nTextRender.showLog = false;\r\nTextRender.debugUV = false;\r\nTextRender.tmpRI = new CharRenderInfo();\r\nTextRender.pixelBBX = [0, 0, 0, 0];\r\nTextRender.imgdtRect = [0, 0, 0, 0];\r\nTextRender.simClean = false;\r\nTextTexture.gTextRender = TextRender;\r\n",
  "references": [
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/webgl/text/TextAtlas.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/webgl/text/TextTexture.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/display/Sprite.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/maths/Matrix.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/maths/Point.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/renders/RenderInfo.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/resource/Context.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/resource/Texture.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/utils/FontInfo.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/utils/HTMLChar.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/utils/WordText.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/webgl/text/CharRenderInfo.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/webgl/text/CharRender_Canvas.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/webgl/text/CharRender_Native.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/webgl/text/ICharRender.ts",
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/ILaya.ts"
  ],
  "dts": {
    "name": "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/webgl/text/TextRender.d.ts",
    "writeByteOrderMark": false,
    "text": "import { TextAtlas } from \"./TextAtlas\";\r\nimport { Sprite } from \"../../display/Sprite\";\r\nimport { Context } from \"../../resource/Context\";\r\nimport { FontInfo } from \"../../utils/FontInfo\";\r\nimport { HTMLChar } from \"../../utils/HTMLChar\";\r\nimport { WordText } from \"../../utils/WordText\";\r\nimport { CharRenderInfo } from \"./CharRenderInfo\";\r\nexport declare class TextRender {\r\n    static useOldCharBook: boolean;\r\n    static atlasWidth: number;\r\n    static noAtlas: boolean;\r\n    static forceSplitRender: boolean;\r\n    static forceWholeRender: boolean;\r\n    static scaleFontWithCtx: boolean;\r\n    static standardFontSize: number;\r\n    static destroyAtlasDt: number;\r\n    static checkCleanTextureDt: number;\r\n    static destroyUnusedTextureDt: number;\r\n    static cleanMem: number;\r\n    static isWan1Wan: boolean;\r\n    static showLog: boolean;\r\n    static debugUV: boolean;\r\n    private fontSizeInfo;\r\n    static atlasWidth2: number;\r\n    private charRender;\r\n    private static tmpRI;\r\n    private static pixelBBX;\r\n    private mapFont;\r\n    private fontID;\r\n    private mapColor;\r\n    private colorID;\r\n    private fontScaleX;\r\n    private fontScaleY;\r\n    private _curStrPos;\r\n    static textRenderInst: TextRender;\r\n    textAtlases: TextAtlas[];\r\n    private isoTextures;\r\n    private bmpData32;\r\n    private static imgdtRect;\r\n    private lastFont;\r\n    private fontSizeW;\r\n    private fontSizeH;\r\n    private fontSizeOffX;\r\n    private fontSizeOffY;\r\n    private renderPerChar;\r\n    private tmpAtlasPos;\r\n    private textureMem;\r\n    private fontStr;\r\n    static simClean: boolean;\r\n    constructor();\r\n    setFont(font: FontInfo): void;\r\n    getNextChar(str: string): string | null;\r\n    filltext(ctx: Context, data: string | WordText, x: number, y: number, fontStr: string, color: string, strokeColor: string, lineWidth: number, textAlign: string, underLine?: number): void;\r\n    fillWords(ctx: Context, data: HTMLChar[], x: number, y: number, fontStr: string | FontInfo, color: string, strokeColor: string | null, lineWidth: number): void;\r\n    _fast_filltext(ctx: Context, data: string | WordText | null, htmlchars: HTMLChar[] | null, x: number, y: number, font: FontInfo, color: string, strokeColor: string | null, lineWidth: number, textAlign: number, underLine?: number): void;\r\n    protected _drawResortedWords(ctx: Context, startx: number, starty: number, samePagesData: any[]): void;\r\n    hasFreedText(txts: any[]): boolean;\r\n    getCharRenderInfo(str: string, font: FontInfo, color: string, strokeColor: string | null, lineWidth: number, isoTexture?: boolean): CharRenderInfo;\r\n    addBmpData(data: ImageData, ri: CharRenderInfo): TextAtlas;\r\n    GC(): void;\r\n    cleanAtlases(): void;\r\n    getCharBmp(c: string): any;\r\n    private checkBmpLine;\r\n    private updateBbx;\r\n    getFontSizeInfo(font: string): number;\r\n    printDbgInfo(): void;\r\n    showAtlas(n: number, bgcolor: string, x: number, y: number, w: number, h: number): Sprite;\r\n    filltext_native(ctx: Context, data: string | WordText, htmlchars: HTMLChar[], x: number, y: number, fontStr: string, color: string, strokeColor: string, lineWidth: number, textAlign: string, underLine?: number): void;\r\n}\r\n"
  }
}

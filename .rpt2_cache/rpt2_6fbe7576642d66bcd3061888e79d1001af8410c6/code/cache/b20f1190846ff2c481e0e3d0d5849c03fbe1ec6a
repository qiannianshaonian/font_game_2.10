{
  "code": "import { EarcutNode } from \"./EarcutNode\";\r\nexport class Earcut {\r\n    static earcut(data, holeIndices, dim) {\r\n        dim = dim || 2;\r\n        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = Earcut.linkedList(data, 0, outerLen, dim, true), triangles = [];\r\n        if (!outerNode)\r\n            return triangles;\r\n        var minX, minY, maxX, maxY, x, y, invSize;\r\n        if (hasHoles)\r\n            outerNode = Earcut.eliminateHoles(data, holeIndices, outerNode, dim);\r\n        if (data.length > 80 * dim) {\r\n            minX = maxX = data[0];\r\n            minY = maxY = data[1];\r\n            for (var i = dim; i < outerLen; i += dim) {\r\n                x = data[i];\r\n                y = data[i + 1];\r\n                if (x < minX)\r\n                    minX = x;\r\n                if (y < minY)\r\n                    minY = y;\r\n                if (x > maxX)\r\n                    maxX = x;\r\n                if (y > maxY)\r\n                    maxY = y;\r\n            }\r\n            invSize = Math.max(maxX - minX, maxY - minY);\r\n            invSize = invSize !== 0 ? 1 / invSize : 0;\r\n        }\r\n        Earcut.earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\r\n        return triangles;\r\n    }\r\n    static linkedList(data, start, end, dim, clockwise) {\r\n        var i, last;\r\n        if (clockwise === (Earcut.signedArea(data, start, end, dim) > 0)) {\r\n            for (i = start; i < end; i += dim)\r\n                last = Earcut.insertNode(i, data[i], data[i + 1], last);\r\n        }\r\n        else {\r\n            for (i = end - dim; i >= start; i -= dim)\r\n                last = Earcut.insertNode(i, data[i], data[i + 1], last);\r\n        }\r\n        if (last && Earcut.equals(last, last.next)) {\r\n            Earcut.removeNode(last);\r\n            last = last.next;\r\n        }\r\n        return last;\r\n    }\r\n    static filterPoints(start, end) {\r\n        if (!start)\r\n            return start;\r\n        if (!end)\r\n            end = start;\r\n        var p = start, again;\r\n        do {\r\n            again = false;\r\n            if (!p.steiner && (Earcut.equals(p, p.next) || Earcut.area(p.prev, p, p.next) === 0)) {\r\n                Earcut.removeNode(p);\r\n                p = end = p.prev;\r\n                if (p === p.next)\r\n                    break;\r\n                again = true;\r\n            }\r\n            else {\r\n                p = p.next;\r\n            }\r\n        } while (again || p !== end);\r\n        return end;\r\n    }\r\n    static earcutLinked(ear, triangles, dim, minX, minY, invSize, pass = null) {\r\n        if (!ear)\r\n            return;\r\n        if (!pass && invSize)\r\n            Earcut.indexCurve(ear, minX, minY, invSize);\r\n        var stop = ear, prev, next;\r\n        while (ear.prev !== ear.next) {\r\n            prev = ear.prev;\r\n            next = ear.next;\r\n            if (invSize ? Earcut.isEarHashed(ear, minX, minY, invSize) : Earcut.isEar(ear)) {\r\n                triangles.push(prev.i / dim);\r\n                triangles.push(ear.i / dim);\r\n                triangles.push(next.i / dim);\r\n                Earcut.removeNode(ear);\r\n                ear = next.next;\r\n                stop = next.next;\r\n                continue;\r\n            }\r\n            ear = next;\r\n            if (ear === stop) {\r\n                if (!pass) {\r\n                    Earcut.earcutLinked(Earcut.filterPoints(ear, null), triangles, dim, minX, minY, invSize, 1);\r\n                }\r\n                else if (pass === 1) {\r\n                    ear = Earcut.cureLocalIntersections(ear, triangles, dim);\r\n                    Earcut.earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\r\n                }\r\n                else if (pass === 2) {\r\n                    Earcut.splitEarcut(ear, triangles, dim, minX, minY, invSize);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    static isEar(ear) {\r\n        var a = ear.prev, b = ear, c = ear.next;\r\n        if (Earcut.area(a, b, c) >= 0)\r\n            return false;\r\n        var p = ear.next.next;\r\n        while (p !== ear.prev) {\r\n            if (Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\r\n                Earcut.area(p.prev, p, p.next) >= 0)\r\n                return false;\r\n            p = p.next;\r\n        }\r\n        return true;\r\n    }\r\n    static isEarHashed(ear, minX, minY, invSize) {\r\n        var a = ear.prev, b = ear, c = ear.next;\r\n        if (Earcut.area(a, b, c) >= 0)\r\n            return false;\r\n        var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\r\n        var minZ = Earcut.zOrder(minTX, minTY, minX, minY, invSize), maxZ = Earcut.zOrder(maxTX, maxTY, minX, minY, invSize);\r\n        var p = ear.nextZ;\r\n        while (p && p.z <= maxZ) {\r\n            if (p !== ear.prev && p !== ear.next &&\r\n                Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\r\n                Earcut.area(p.prev, p, p.next) >= 0)\r\n                return false;\r\n            p = p.nextZ;\r\n        }\r\n        p = ear.prevZ;\r\n        while (p && p.z >= minZ) {\r\n            if (p !== ear.prev && p !== ear.next &&\r\n                Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\r\n                Earcut.area(p.prev, p, p.next) >= 0)\r\n                return false;\r\n            p = p.prevZ;\r\n        }\r\n        return true;\r\n    }\r\n    static cureLocalIntersections(start, triangles, dim) {\r\n        var p = start;\r\n        do {\r\n            var a = p.prev, b = p.next.next;\r\n            if (!Earcut.equals(a, b) && Earcut.intersects(a, p, p.next, b) && Earcut.locallyInside(a, b) && Earcut.locallyInside(b, a)) {\r\n                triangles.push(a.i / dim);\r\n                triangles.push(p.i / dim);\r\n                triangles.push(b.i / dim);\r\n                Earcut.removeNode(p);\r\n                Earcut.removeNode(p.next);\r\n                p = start = b;\r\n            }\r\n            p = p.next;\r\n        } while (p !== start);\r\n        return p;\r\n    }\r\n    static splitEarcut(start, triangles, dim, minX, minY, invSize) {\r\n        var a = start;\r\n        do {\r\n            var b = a.next.next;\r\n            while (b !== a.prev) {\r\n                if (a.i !== b.i && Earcut.isValidDiagonal(a, b)) {\r\n                    var c = Earcut.splitPolygon(a, b);\r\n                    a = Earcut.filterPoints(a, a.next);\r\n                    c = Earcut.filterPoints(c, c.next);\r\n                    Earcut.earcutLinked(a, triangles, dim, minX, minY, invSize);\r\n                    Earcut.earcutLinked(c, triangles, dim, minX, minY, invSize);\r\n                    return;\r\n                }\r\n                b = b.next;\r\n            }\r\n            a = a.next;\r\n        } while (a !== start);\r\n    }\r\n    static eliminateHoles(data, holeIndices, outerNode, dim) {\r\n        var queue = [], i, len, start, end, list;\r\n        for (i = 0, len = holeIndices.length; i < len; i++) {\r\n            start = holeIndices[i] * dim;\r\n            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\r\n            list = Earcut.linkedList(data, start, end, dim, false);\r\n            if (list === list.next)\r\n                list.steiner = true;\r\n            queue.push(Earcut.getLeftmost(list));\r\n        }\r\n        queue.sort(Earcut.compareX);\r\n        for (i = 0; i < queue.length; i++) {\r\n            Earcut.eliminateHole(queue[i], outerNode);\r\n            outerNode = Earcut.filterPoints(outerNode, outerNode.next);\r\n        }\r\n        return outerNode;\r\n    }\r\n    static compareX(a, b) {\r\n        return a.x - b.x;\r\n    }\r\n    static eliminateHole(hole, outerNode) {\r\n        outerNode = Earcut.findHoleBridge(hole, outerNode);\r\n        if (outerNode) {\r\n            var b = Earcut.splitPolygon(outerNode, hole);\r\n            Earcut.filterPoints(b, b.next);\r\n        }\r\n    }\r\n    static findHoleBridge(hole, outerNode) {\r\n        var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;\r\n        do {\r\n            if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\r\n                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\r\n                if (x <= hx && x > qx) {\r\n                    qx = x;\r\n                    if (x === hx) {\r\n                        if (hy === p.y)\r\n                            return p;\r\n                        if (hy === p.next.y)\r\n                            return p.next;\r\n                    }\r\n                    m = p.x < p.next.x ? p : p.next;\r\n                }\r\n            }\r\n            p = p.next;\r\n        } while (p !== outerNode);\r\n        if (!m)\r\n            return null;\r\n        if (hx === qx)\r\n            return m.prev;\r\n        var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;\r\n        p = m.next;\r\n        while (p !== stop) {\r\n            if (hx >= p.x && p.x >= mx && hx !== p.x &&\r\n                Earcut.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\r\n                tan = Math.abs(hy - p.y) / (hx - p.x);\r\n                if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && Earcut.locallyInside(p, hole)) {\r\n                    m = p;\r\n                    tanMin = tan;\r\n                }\r\n            }\r\n            p = p.next;\r\n        }\r\n        return m;\r\n    }\r\n    static indexCurve(start, minX, minY, invSize) {\r\n        var p = start;\r\n        do {\r\n            if (p.z === null)\r\n                p.z = Earcut.zOrder(p.x, p.y, minX, minY, invSize);\r\n            p.prevZ = p.prev;\r\n            p.nextZ = p.next;\r\n            p = p.next;\r\n        } while (p !== start);\r\n        p.prevZ.nextZ = null;\r\n        p.prevZ = null;\r\n        Earcut.sortLinked(p);\r\n    }\r\n    static sortLinked(list) {\r\n        var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;\r\n        do {\r\n            p = list;\r\n            list = null;\r\n            tail = null;\r\n            numMerges = 0;\r\n            while (p) {\r\n                numMerges++;\r\n                q = p;\r\n                pSize = 0;\r\n                for (i = 0; i < inSize; i++) {\r\n                    pSize++;\r\n                    q = q.nextZ;\r\n                    if (!q)\r\n                        break;\r\n                }\r\n                qSize = inSize;\r\n                while (pSize > 0 || (qSize > 0 && q)) {\r\n                    if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\r\n                        e = p;\r\n                        p = p.nextZ;\r\n                        pSize--;\r\n                    }\r\n                    else {\r\n                        e = q;\r\n                        q = q.nextZ;\r\n                        qSize--;\r\n                    }\r\n                    if (tail)\r\n                        tail.nextZ = e;\r\n                    else\r\n                        list = e;\r\n                    e.prevZ = tail;\r\n                    tail = e;\r\n                }\r\n                p = q;\r\n            }\r\n            tail.nextZ = null;\r\n            inSize *= 2;\r\n        } while (numMerges > 1);\r\n        return list;\r\n    }\r\n    static zOrder(x, y, minX, minY, invSize) {\r\n        x = 32767 * (x - minX) * invSize;\r\n        y = 32767 * (y - minY) * invSize;\r\n        x = (x | (x << 8)) & 0x00FF00FF;\r\n        x = (x | (x << 4)) & 0x0F0F0F0F;\r\n        x = (x | (x << 2)) & 0x33333333;\r\n        x = (x | (x << 1)) & 0x55555555;\r\n        y = (y | (y << 8)) & 0x00FF00FF;\r\n        y = (y | (y << 4)) & 0x0F0F0F0F;\r\n        y = (y | (y << 2)) & 0x33333333;\r\n        y = (y | (y << 1)) & 0x55555555;\r\n        return x | (y << 1);\r\n    }\r\n    static getLeftmost(start) {\r\n        var p = start, leftmost = start;\r\n        do {\r\n            if (p.x < leftmost.x)\r\n                leftmost = p;\r\n            p = p.next;\r\n        } while (p !== start);\r\n        return leftmost;\r\n    }\r\n    static pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\r\n        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\r\n            (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\r\n            (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\r\n    }\r\n    static isValidDiagonal(a, b) {\r\n        return a.next.i !== b.i && a.prev.i !== b.i && !Earcut.intersectsPolygon(a, b) &&\r\n            Earcut.locallyInside(a, b) && Earcut.locallyInside(b, a) && Earcut.middleInside(a, b);\r\n    }\r\n    static area(p, q, r) {\r\n        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\r\n    }\r\n    static equals(p1, p2) {\r\n        return p1.x === p2.x && p1.y === p2.y;\r\n    }\r\n    static intersects(p1, q1, p2, q2) {\r\n        if ((Earcut.equals(p1, q1) && Earcut.equals(p2, q2)) ||\r\n            (Earcut.equals(p1, q2) && Earcut.equals(p2, q1)))\r\n            return true;\r\n        return Earcut.area(p1, q1, p2) > 0 !== Earcut.area(p1, q1, q2) > 0 &&\r\n            Earcut.area(p2, q2, p1) > 0 !== Earcut.area(p2, q2, q1) > 0;\r\n    }\r\n    static intersectsPolygon(a, b) {\r\n        var p = a;\r\n        do {\r\n            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\r\n                Earcut.intersects(p, p.next, a, b))\r\n                return true;\r\n            p = p.next;\r\n        } while (p !== a);\r\n        return false;\r\n    }\r\n    static locallyInside(a, b) {\r\n        return Earcut.area(a.prev, a, a.next) < 0 ?\r\n            Earcut.area(a, b, a.next) >= 0 && Earcut.area(a, a.prev, b) >= 0 :\r\n            Earcut.area(a, b, a.prev) < 0 || Earcut.area(a, a.next, b) < 0;\r\n    }\r\n    static middleInside(a, b) {\r\n        var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;\r\n        do {\r\n            if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\r\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\r\n                inside = !inside;\r\n            p = p.next;\r\n        } while (p !== a);\r\n        return inside;\r\n    }\r\n    static splitPolygon(a, b) {\r\n        var a2 = new EarcutNode(a.i, a.x, a.y), b2 = new EarcutNode(b.i, b.x, b.y), an = a.next, bp = b.prev;\r\n        a.next = b;\r\n        b.prev = a;\r\n        a2.next = an;\r\n        an.prev = a2;\r\n        b2.next = a2;\r\n        a2.prev = b2;\r\n        bp.next = b2;\r\n        b2.prev = bp;\r\n        return b2;\r\n    }\r\n    static insertNode(i, x, y, last) {\r\n        var p = new EarcutNode(i, x, y);\r\n        if (!last) {\r\n            p.prev = p;\r\n            p.next = p;\r\n        }\r\n        else {\r\n            p.next = last.next;\r\n            p.prev = last;\r\n            last.next.prev = p;\r\n            last.next = p;\r\n        }\r\n        return p;\r\n    }\r\n    static removeNode(p) {\r\n        p.next.prev = p.prev;\r\n        p.prev.next = p.next;\r\n        if (p.prevZ)\r\n            p.prevZ.nextZ = p.nextZ;\r\n        if (p.nextZ)\r\n            p.nextZ.prevZ = p.prevZ;\r\n    }\r\n    static signedArea(data, start, end, dim) {\r\n        var sum = 0;\r\n        for (var i = start, j = end - dim; i < end; i += dim) {\r\n            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\r\n            j = i;\r\n        }\r\n        return sum;\r\n    }\r\n}\r\n",
  "references": [
    "/Users/zonst/Documents/font_vivo/font_game_2.10/libs/laya/webgl/shapes/EarcutNode.ts"
  ],
  "dts": {
    "name": "/Users/zonst/Documents/font_vivo/font_game_2.10/.rpt2_cache/placeholder/laya/webgl/shapes/Earcut.d.ts",
    "writeByteOrderMark": false,
    "text": "export declare class Earcut {\r\n    static earcut(data: any, holeIndices: any, dim: any): any;\r\n    static linkedList(data: any, start: any, end: any, dim: any, clockwise: any): any;\r\n    static filterPoints(start: any, end: any): any;\r\n    static earcutLinked(ear: any, triangles: any, dim: any, minX: any, minY: any, invSize: any, pass?: any): any;\r\n    static isEar(ear: any): any;\r\n    static isEarHashed(ear: any, minX: any, minY: any, invSize: any): boolean;\r\n    static cureLocalIntersections(start: any, triangles: any, dim: any): any;\r\n    static splitEarcut(start: any, triangles: any, dim: any, minX: any, minY: any, invSize: any): void;\r\n    static eliminateHoles(data: any, holeIndices: any, outerNode: any, dim: any): any;\r\n    static compareX(a: any, b: any): any;\r\n    static eliminateHole(hole: any, outerNode: any): void;\r\n    static findHoleBridge(hole: any, outerNode: any): any;\r\n    static indexCurve(start: any, minX: any, minY: any, invSize: any): void;\r\n    static sortLinked(list: any): any;\r\n    static zOrder(x: any, y: any, minX: any, minY: any, invSize: any): any;\r\n    static getLeftmost(start: any): any;\r\n    static pointInTriangle(ax: any, ay: any, bx: any, by: any, cx: any, cy: any, px: any, py: any): boolean;\r\n    static isValidDiagonal(a: any, b: any): boolean;\r\n    static area(p: any, q: any, r: any): any;\r\n    static equals(p1: any, p2: any): boolean;\r\n    static intersects(p1: any, q1: any, p2: any, q2: any): boolean;\r\n    static intersectsPolygon(a: any, b: any): boolean;\r\n    static locallyInside(a: any, b: any): boolean;\r\n    static middleInside(a: any, b: any): boolean;\r\n    static splitPolygon(a: any, b: any): any;\r\n    static insertNode(i: any, x: any, y: any, last: any): any;\r\n    static removeNode(p: any): void;\r\n    static signedArea(data: any, start: any, end: any, dim: any): any;\r\n}\r\n"
  }
}

{
  "code": "import { ILaya } from \"../../ILaya\";\r\nimport { LayaGL } from \"../layagl/LayaGL\";\r\nimport { Bezier } from \"../maths/Bezier\";\r\nimport { Matrix } from \"../maths/Matrix\";\r\nimport { Point } from \"../maths/Point\";\r\nimport { Rectangle } from \"../maths/Rectangle\";\r\nimport { Stat } from \"../utils/Stat\";\r\nimport { BlendMode } from \"../webgl/canvas/BlendMode\";\r\nimport { DrawStyle } from \"../webgl/canvas/DrawStyle\";\r\nimport { Path } from \"../webgl/canvas/Path\";\r\nimport { SaveBase } from \"../webgl/canvas/save/SaveBase\";\r\nimport { SaveClipRect } from \"../webgl/canvas/save/SaveClipRect\";\r\nimport { SaveMark } from \"../webgl/canvas/save/SaveMark\";\r\nimport { SaveTransform } from \"../webgl/canvas/save/SaveTransform\";\r\nimport { SaveTranslate } from \"../webgl/canvas/save/SaveTranslate\";\r\nimport { WebGLCacheAsNormalCanvas } from \"../webgl/canvas/WebGLCacheAsNormalCanvas\";\r\nimport { BaseShader } from \"../webgl/shader/BaseShader\";\r\nimport { Shader2D } from \"../webgl/shader/d2/Shader2D\";\r\nimport { ShaderDefines2D } from \"../webgl/shader/d2/ShaderDefines2D\";\r\nimport { SkinMeshBuffer } from \"../webgl/shader/d2/skinAnishader/SkinMeshBuffer\";\r\nimport { Value2D } from \"../webgl/shader/d2/value/Value2D\";\r\nimport { BasePoly } from \"../webgl/shapes/BasePoly\";\r\nimport { Earcut } from \"../webgl/shapes/Earcut\";\r\nimport { Submit } from \"../webgl/submit/Submit\";\r\nimport { SubmitBase } from \"../webgl/submit/SubmitBase\";\r\nimport { SubmitCanvas } from \"../webgl/submit/SubmitCanvas\";\r\nimport { SubmitCMD } from \"../webgl/submit/SubmitCMD\";\r\nimport { SubmitKey } from \"../webgl/submit/SubmitKey\";\r\nimport { SubmitTarget } from \"../webgl/submit/SubmitTarget\";\r\nimport { SubmitTexture } from \"../webgl/submit/SubmitTexture\";\r\nimport { CharSubmitCache } from \"../webgl/text/CharSubmitCache\";\r\nimport { TextRender } from \"../webgl/text/TextRender\";\r\nimport { MeshQuadTexture } from \"../webgl/utils/MeshQuadTexture\";\r\nimport { MeshTexture } from \"../webgl/utils/MeshTexture\";\r\nimport { MeshVG } from \"../webgl/utils/MeshVG\";\r\nimport { RenderState2D } from \"../webgl/utils/RenderState2D\";\r\nimport { WebGLContext } from \"../webgl/WebGLContext\";\r\nimport { RenderTexture2D } from \"./RenderTexture2D\";\r\nimport { RenderTextureFormat } from \"./RenderTextureFormat\";\r\nimport { Texture } from \"./Texture\";\r\nimport { Texture2D } from \"./Texture2D\";\r\nexport class Context {\r\n    constructor() {\r\n        this._tmpMatrix = new Matrix();\r\n        this._drawTexToDrawTri_Vert = new Float32Array(8);\r\n        this._drawTexToDrawTri_Index = new Uint16Array([0, 1, 2, 0, 2, 3]);\r\n        this._tempUV = new Float32Array(8);\r\n        this._drawTriUseAbsMatrix = false;\r\n        this._id = ++Context._COUNT;\r\n        this._other = null;\r\n        this._renderNextSubmitIndex = 0;\r\n        this._path = null;\r\n        this._drawCount = 1;\r\n        this._width = Context._MAXSIZE;\r\n        this._height = Context._MAXSIZE;\r\n        this._renderCount = 0;\r\n        this._submits = null;\r\n        this._curSubmit = null;\r\n        this._submitKey = new SubmitKey();\r\n        this._pathMesh = null;\r\n        this._triangleMesh = null;\r\n        this.meshlist = [];\r\n        this._transedPoints = new Array(8);\r\n        this._temp4Points = new Array(8);\r\n        this._clipRect = Context.MAXCLIPRECT;\r\n        this._globalClipMatrix = new Matrix(Context._MAXSIZE, 0, 0, Context._MAXSIZE, 0, 0);\r\n        this._clipInCache = false;\r\n        this._clipInfoID = 0;\r\n        this._clipID_Gen = 0;\r\n        this._lastMatScaleX = 1.0;\r\n        this._lastMatScaleY = 1.0;\r\n        this._lastMat_a = 1.0;\r\n        this._lastMat_b = 0.0;\r\n        this._lastMat_c = 0.0;\r\n        this._lastMat_d = 1.0;\r\n        this._nBlendType = 0;\r\n        this._save = null;\r\n        this._targets = null;\r\n        this._charSubmitCache = null;\r\n        this._saveMark = null;\r\n        this._shader2D = new Shader2D();\r\n        this.sprite = null;\r\n        this._italicDeg = 0;\r\n        this._lastTex = null;\r\n        this._fillColor = 0;\r\n        this._flushCnt = 0;\r\n        this.defTexture = null;\r\n        this._colorFiler = null;\r\n        this.drawTexAlign = false;\r\n        this._incache = false;\r\n        this.isMain = false;\r\n        Context._contextcount++;\r\n        Context._textRender = Context._textRender || new TextRender();\r\n        if (!this.defTexture) {\r\n            var defTex2d = new Texture2D(2, 2);\r\n            defTex2d.setPixels(new Uint8Array(16));\r\n            defTex2d.lock = true;\r\n            this.defTexture = new Texture(defTex2d);\r\n        }\r\n        this._lastTex = this.defTexture;\r\n        this.clear();\r\n    }\r\n    static __init__() {\r\n        Context.MAXCLIPRECT = new Rectangle(0, 0, Context._MAXSIZE, Context._MAXSIZE);\r\n        ContextParams.DEFAULT = new ContextParams();\r\n        WebGLCacheAsNormalCanvas;\r\n    }\r\n    drawImage(...args) {\r\n    }\r\n    getImageData(...args) {\r\n    }\r\n    measureText(text) {\r\n        return null;\r\n    }\r\n    setTransform(...args) {\r\n    }\r\n    $transform(a, b, c, d, tx, ty) {\r\n    }\r\n    get lineJoin() {\r\n        return '';\r\n    }\r\n    set lineJoin(value) {\r\n    }\r\n    get lineCap() {\r\n        return '';\r\n    }\r\n    set lineCap(value) {\r\n    }\r\n    get miterLimit() {\r\n        return '';\r\n    }\r\n    set miterLimit(value) {\r\n    }\r\n    clearRect(x, y, width, height) {\r\n    }\r\n    _drawRect(x, y, width, height, style) {\r\n        Stat.renderBatches++;\r\n        style && (this.fillStyle = style);\r\n        this.fillRect(x, y, width, height, null);\r\n    }\r\n    drawTexture2(x, y, pivotX, pivotY, m, args2) {\r\n    }\r\n    transformByMatrix(matrix, tx, ty) {\r\n        this.transform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx + tx, matrix.ty + ty);\r\n    }\r\n    saveTransform(matrix) {\r\n        this.save();\r\n    }\r\n    restoreTransform(matrix) {\r\n        this.restore();\r\n    }\r\n    drawRect(x, y, width, height, fillColor, lineColor, lineWidth) {\r\n        var ctx = this;\r\n        if (fillColor != null) {\r\n            ctx.fillStyle = fillColor;\r\n            ctx.fillRect(x, y, width, height);\r\n        }\r\n        if (lineColor != null) {\r\n            ctx.strokeStyle = lineColor;\r\n            ctx.lineWidth = lineWidth;\r\n            ctx.strokeRect(x, y, width, height);\r\n        }\r\n    }\r\n    alpha(value) {\r\n        this.globalAlpha *= value;\r\n    }\r\n    _transform(mat, pivotX, pivotY) {\r\n        this.translate(pivotX, pivotY);\r\n        this.transform(mat.a, mat.b, mat.c, mat.d, mat.tx, mat.ty);\r\n        this.translate(-pivotX, -pivotY);\r\n    }\r\n    _rotate(angle, pivotX, pivotY) {\r\n        this.translate(pivotX, pivotY);\r\n        this.rotate(angle);\r\n        this.translate(-pivotX, -pivotY);\r\n    }\r\n    _scale(scaleX, scaleY, pivotX, pivotY) {\r\n        this.translate(pivotX, pivotY);\r\n        this.scale(scaleX, scaleY);\r\n        this.translate(-pivotX, -pivotY);\r\n    }\r\n    _drawLine(x, y, fromX, fromY, toX, toY, lineColor, lineWidth, vid) {\r\n        this.beginPath();\r\n        this.strokeStyle = lineColor;\r\n        this.lineWidth = lineWidth;\r\n        this.moveTo(x + fromX, y + fromY);\r\n        this.lineTo(x + toX, y + toY);\r\n        this.stroke();\r\n    }\r\n    _drawLines(x, y, points, lineColor, lineWidth, vid) {\r\n        this.beginPath();\r\n        this.strokeStyle = lineColor;\r\n        this.lineWidth = lineWidth;\r\n        this.addPath(points.slice(), false, false, x, y);\r\n        this.stroke();\r\n    }\r\n    drawCurves(x, y, points, lineColor, lineWidth) {\r\n        this.beginPath();\r\n        this.strokeStyle = lineColor;\r\n        this.lineWidth = lineWidth;\r\n        this.moveTo(x + points[0], y + points[1]);\r\n        var i = 2, n = points.length;\r\n        while (i < n) {\r\n            this.quadraticCurveTo(x + points[i++], y + points[i++], x + points[i++], y + points[i++]);\r\n        }\r\n        this.stroke();\r\n    }\r\n    _fillAndStroke(fillColor, strokeColor, lineWidth, isConvexPolygon = false) {\r\n        if (fillColor != null) {\r\n            this.fillStyle = fillColor;\r\n            this.fill();\r\n        }\r\n        if (strokeColor != null && lineWidth > 0) {\r\n            this.strokeStyle = strokeColor;\r\n            this.lineWidth = lineWidth;\r\n            this.stroke();\r\n        }\r\n    }\r\n    _drawCircle(x, y, radius, fillColor, lineColor, lineWidth, vid) {\r\n        Stat.renderBatches++;\r\n        this.beginPath(true);\r\n        this.arc(x, y, radius, 0, Context.PI2);\r\n        this.closePath();\r\n        this._fillAndStroke(fillColor, lineColor, lineWidth);\r\n    }\r\n    _drawPie(x, y, radius, startAngle, endAngle, fillColor, lineColor, lineWidth, vid) {\r\n        this.beginPath();\r\n        this.moveTo(x, y);\r\n        this.arc(x, y, radius, startAngle, endAngle);\r\n        this.closePath();\r\n        this._fillAndStroke(fillColor, lineColor, lineWidth);\r\n    }\r\n    _drawPoly(x, y, points, fillColor, lineColor, lineWidth, isConvexPolygon, vid) {\r\n        this.beginPath();\r\n        this.addPath(points.slice(), true, isConvexPolygon, x, y);\r\n        this.closePath();\r\n        this._fillAndStroke(fillColor, lineColor, lineWidth, isConvexPolygon);\r\n    }\r\n    _drawPath(x, y, paths, brush, pen) {\r\n        this.beginPath();\r\n        for (var i = 0, n = paths.length; i < n; i++) {\r\n            var path = paths[i];\r\n            switch (path[0]) {\r\n                case \"moveTo\":\r\n                    this.moveTo(x + path[1], y + path[2]);\r\n                    break;\r\n                case \"lineTo\":\r\n                    this.lineTo(x + path[1], y + path[2]);\r\n                    break;\r\n                case \"arcTo\":\r\n                    this.arcTo(x + path[1], y + path[2], x + path[3], y + path[4], path[5]);\r\n                    break;\r\n                case \"closePath\":\r\n                    this.closePath();\r\n                    break;\r\n            }\r\n        }\r\n        if (brush != null) {\r\n            this.fillStyle = brush.fillStyle;\r\n            this.fill();\r\n        }\r\n        if (pen != null) {\r\n            this.strokeStyle = pen.strokeStyle;\r\n            this.lineWidth = pen.lineWidth || 1;\r\n            this.lineJoin = pen.lineJoin;\r\n            this.lineCap = pen.lineCap;\r\n            this.miterLimit = pen.miterLimit;\r\n            this.stroke();\r\n        }\r\n    }\r\n    static set2DRenderConfig() {\r\n        var gl = LayaGL.instance;\r\n        WebGLContext.setBlend(gl, true);\r\n        WebGLContext.setBlendEquation(gl, gl.FUNC_ADD);\r\n        BlendMode.activeBlendFunction = null;\r\n        WebGLContext.setBlendFunc(gl, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n        WebGLContext.setDepthTest(gl, false);\r\n        WebGLContext.setCullFace(gl, false);\r\n        WebGLContext.setDepthMask(gl, true);\r\n        WebGLContext.setFrontFace(gl, gl.CCW);\r\n        gl.viewport(0, 0, RenderState2D.width, RenderState2D.height);\r\n    }\r\n    clearBG(r, g, b, a) {\r\n        var gl = WebGLContext.mainContext;\r\n        gl.clearColor(r, g, b, a);\r\n        gl.clear(gl.COLOR_BUFFER_BIT);\r\n    }\r\n    _getSubmits() {\r\n        return this._submits;\r\n    }\r\n    _releaseMem(keepRT = false) {\r\n        if (!this._submits)\r\n            return;\r\n        this._curMat && this._curMat.destroy();\r\n        this._curMat = null;\r\n        this._shader2D.destroy();\r\n        this._shader2D = null;\r\n        this._charSubmitCache.clear();\r\n        for (var i = 0, n = this._submits._length; i < n; i++) {\r\n            this._submits[i].releaseRender();\r\n        }\r\n        this._submits.length = 0;\r\n        this._submits._length = 0;\r\n        this._submits = null;\r\n        this._curSubmit = null;\r\n        this._path = null;\r\n        this._save = null;\r\n        var sz;\r\n        for (i = 0, sz = this.meshlist.length; i < sz; i++) {\r\n            var curm = this.meshlist[i];\r\n            curm.destroy();\r\n        }\r\n        this.meshlist.length = 0;\r\n        this.sprite = null;\r\n        if (!keepRT) {\r\n            this._targets && (this._targets.destroy());\r\n            this._targets = null;\r\n        }\r\n    }\r\n    destroy(keepRT = false) {\r\n        --Context._contextcount;\r\n        this.sprite = null;\r\n        this._releaseMem(keepRT);\r\n        this._charSubmitCache && this._charSubmitCache.destroy();\r\n        this._mesh.destroy();\r\n        if (!keepRT) {\r\n            this._targets && this._targets.destroy();\r\n            this._targets = null;\r\n        }\r\n    }\r\n    clear() {\r\n        if (!this._submits) {\r\n            this._other = ContextParams.DEFAULT;\r\n            this._curMat = Matrix.create();\r\n            this._charSubmitCache = new CharSubmitCache();\r\n            this._mesh = MeshQuadTexture.getAMesh(this.isMain);\r\n            this.meshlist.push(this._mesh);\r\n            this._pathMesh = MeshVG.getAMesh(this.isMain);\r\n            this.meshlist.push(this._pathMesh);\r\n            this._triangleMesh = MeshTexture.getAMesh(this.isMain);\r\n            this.meshlist.push(this._triangleMesh);\r\n            this._submits = [];\r\n            this._save = [SaveMark.Create(this)];\r\n            this._save.length = 10;\r\n            this._shader2D = new Shader2D();\r\n        }\r\n        this._submitKey.clear();\r\n        this._mesh.clearVB();\r\n        this._drawCount = 1;\r\n        this._other = ContextParams.DEFAULT;\r\n        this._other.lineWidth = this._shader2D.ALPHA = 1.0;\r\n        this._nBlendType = 0;\r\n        this._clipRect = Context.MAXCLIPRECT;\r\n        this._curSubmit = SubmitBase.RENDERBASE;\r\n        SubmitBase.RENDERBASE._ref = 0xFFFFFF;\r\n        SubmitBase.RENDERBASE._numEle = 0;\r\n        this._shader2D.fillStyle = this._shader2D.strokeStyle = DrawStyle.DEFAULT;\r\n        for (var i = 0, n = this._submits._length; i < n; i++)\r\n            this._submits[i].releaseRender();\r\n        this._submits._length = 0;\r\n        this._curMat.identity();\r\n        this._other.clear();\r\n        this._saveMark = this._save[0];\r\n        this._save._length = 1;\r\n    }\r\n    size(w, h) {\r\n        if (this._width != w || this._height != h) {\r\n            this._width = w;\r\n            this._height = h;\r\n            if (this._targets) {\r\n                this._targets.destroy();\r\n                this._targets = new RenderTexture2D(w, h, RenderTextureFormat.R8G8B8A8, -1);\r\n            }\r\n            if (this.isMain) {\r\n                WebGLContext.mainContext.viewport(0, 0, w, h);\r\n                RenderState2D.width = w;\r\n                RenderState2D.height = h;\r\n            }\r\n        }\r\n        if (w === 0 && h === 0)\r\n            this._releaseMem();\r\n    }\r\n    set asBitmap(value) {\r\n        if (value) {\r\n            let rt = this._targets;\r\n            if (!this._width || !this._height)\r\n                throw Error(\"asBitmap no size!\");\r\n            if (!rt || rt.width != this._width || rt.height != this._height) {\r\n                if (rt) {\r\n                    rt.destroy();\r\n                }\r\n                this._targets = new RenderTexture2D(this._width, this._height, RenderTextureFormat.R8G8B8A8, -1);\r\n            }\r\n        }\r\n        else {\r\n            this._targets && this._targets.destroy();\r\n            this._targets = null;\r\n        }\r\n    }\r\n    getMatScaleX() {\r\n        if (this._lastMat_a == this._curMat.a && this._lastMat_b == this._curMat.b)\r\n            return this._lastMatScaleX;\r\n        this._lastMatScaleX = this._curMat.getScaleX();\r\n        this._lastMat_a = this._curMat.a;\r\n        this._lastMat_b = this._curMat.b;\r\n        return this._lastMatScaleX;\r\n    }\r\n    getMatScaleY() {\r\n        if (this._lastMat_c == this._curMat.c && this._lastMat_d == this._curMat.d)\r\n            return this._lastMatScaleY;\r\n        this._lastMatScaleY = this._curMat.getScaleY();\r\n        this._lastMat_c = this._curMat.c;\r\n        this._lastMat_d = this._curMat.d;\r\n        return this._lastMatScaleY;\r\n    }\r\n    setFillColor(color) {\r\n        this._fillColor = color;\r\n    }\r\n    getFillColor() {\r\n        return this._fillColor;\r\n    }\r\n    set fillStyle(value) {\r\n        if (!this._shader2D.fillStyle.equal(value)) {\r\n            SaveBase.save(this, SaveBase.TYPE_FILESTYLE, this._shader2D, false);\r\n            this._shader2D.fillStyle = DrawStyle.create(value);\r\n            this._submitKey.other = -this._shader2D.fillStyle.toInt();\r\n        }\r\n    }\r\n    get fillStyle() {\r\n        return this._shader2D.fillStyle;\r\n    }\r\n    set globalAlpha(value) {\r\n        value = Math.floor(value * 1000) / 1000;\r\n        if (value != this._shader2D.ALPHA) {\r\n            SaveBase.save(this, SaveBase.TYPE_ALPHA, this._shader2D, false);\r\n            this._shader2D.ALPHA = value;\r\n        }\r\n    }\r\n    get globalAlpha() {\r\n        return this._shader2D.ALPHA;\r\n    }\r\n    set textAlign(value) {\r\n        (this._other.textAlign === value) || (this._other = this._other.make(), SaveBase.save(this, SaveBase.TYPE_TEXTALIGN, this._other, false), this._other.textAlign = value);\r\n    }\r\n    get textAlign() {\r\n        return this._other.textAlign;\r\n    }\r\n    set textBaseline(value) {\r\n        (this._other.textBaseline === value) || (this._other = this._other.make(), SaveBase.save(this, SaveBase.TYPE_TEXTBASELINE, this._other, false), this._other.textBaseline = value);\r\n    }\r\n    get textBaseline() {\r\n        return this._other.textBaseline;\r\n    }\r\n    set globalCompositeOperation(value) {\r\n        var n = BlendMode.TOINT[value];\r\n        n == null || (this._nBlendType === n) || (SaveBase.save(this, SaveBase.TYPE_GLOBALCOMPOSITEOPERATION, this, true), this._curSubmit = SubmitBase.RENDERBASE, this._nBlendType = n);\r\n    }\r\n    get globalCompositeOperation() {\r\n        return BlendMode.NAMES[this._nBlendType];\r\n    }\r\n    set strokeStyle(value) {\r\n        this._shader2D.strokeStyle.equal(value) || (SaveBase.save(this, SaveBase.TYPE_STROKESTYLE, this._shader2D, false), this._shader2D.strokeStyle = DrawStyle.create(value), this._submitKey.other = -this._shader2D.strokeStyle.toInt());\r\n    }\r\n    get strokeStyle() {\r\n        return this._shader2D.strokeStyle;\r\n    }\r\n    translate(x, y) {\r\n        if (x !== 0 || y !== 0) {\r\n            SaveTranslate.save(this);\r\n            if (this._curMat._bTransform) {\r\n                SaveTransform.save(this);\r\n                this._curMat.tx += (x * this._curMat.a + y * this._curMat.c);\r\n                this._curMat.ty += (x * this._curMat.b + y * this._curMat.d);\r\n            }\r\n            else {\r\n                this._curMat.tx = x;\r\n                this._curMat.ty = y;\r\n            }\r\n        }\r\n    }\r\n    set lineWidth(value) {\r\n        (this._other.lineWidth === value) || (this._other = this._other.make(), SaveBase.save(this, SaveBase.TYPE_LINEWIDTH, this._other, false), this._other.lineWidth = value);\r\n    }\r\n    get lineWidth() {\r\n        return this._other.lineWidth;\r\n    }\r\n    save() {\r\n        this._save[this._save._length++] = SaveMark.Create(this);\r\n    }\r\n    restore() {\r\n        var sz = this._save._length;\r\n        var lastBlend = this._nBlendType;\r\n        if (sz < 1)\r\n            return;\r\n        for (var i = sz - 1; i >= 0; i--) {\r\n            var o = this._save[i];\r\n            o.restore(this);\r\n            if (o.isSaveMark()) {\r\n                this._save._length = i;\r\n                return;\r\n            }\r\n        }\r\n        if (lastBlend != this._nBlendType) {\r\n            this._curSubmit = SubmitBase.RENDERBASE;\r\n        }\r\n    }\r\n    set font(str) {\r\n        this._other = this._other.make();\r\n        SaveBase.save(this, SaveBase.TYPE_FONT, this._other, false);\r\n    }\r\n    fillText(txt, x, y, fontStr, color, align, lineWidth = 0, borderColor = \"\") {\r\n        Context._textRender.filltext(this, txt, x, y, fontStr, color, borderColor, lineWidth, align);\r\n    }\r\n    drawText(text, x, y, font, color, textAlign) {\r\n        Context._textRender.filltext(this, text, x, y, font, color, null, 0, textAlign);\r\n    }\r\n    fillWords(words, x, y, fontStr, color) {\r\n        Context._textRender.fillWords(this, words, x, y, fontStr, color, null, 0);\r\n    }\r\n    strokeWord(text, x, y, font, color, lineWidth, textAlign) {\r\n        Context._textRender.filltext(this, text, x, y, font, null, color, lineWidth, textAlign);\r\n    }\r\n    fillBorderText(txt, x, y, font, color, borderColor, lineWidth, textAlign) {\r\n        Context._textRender.filltext(this, txt, x, y, font, color, borderColor, lineWidth, textAlign);\r\n    }\r\n    fillBorderWords(words, x, y, font, color, borderColor, lineWidth) {\r\n        Context._textRender.fillWords(this, words, x, y, font, color, borderColor, lineWidth);\r\n    }\r\n    _fast_filltext(data, x, y, fontObj, color, strokeColor, lineWidth, textAlign, underLine = 0) {\r\n        Context._textRender._fast_filltext(this, data, null, x, y, fontObj, color, strokeColor, lineWidth, textAlign, underLine);\r\n    }\r\n    _fillRect(x, y, width, height, rgba) {\r\n        var submit = this._curSubmit;\r\n        var sameKey = submit && (submit._key.submitType === SubmitBase.KEY_DRAWTEXTURE && submit._key.blendShader === this._nBlendType);\r\n        if (this._mesh.vertNum + 4 > Context._MAXVERTNUM) {\r\n            this._mesh = MeshQuadTexture.getAMesh(this.isMain);\r\n            this.meshlist.push(this._mesh);\r\n            sameKey = false;\r\n        }\r\n        sameKey && (sameKey = sameKey && this.isSameClipInfo(submit));\r\n        this.transformQuad(x, y, width, height, 0, this._curMat, this._transedPoints);\r\n        if (!this.clipedOff(this._transedPoints)) {\r\n            this._mesh.addQuad(this._transedPoints, Texture.NO_UV, rgba, false);\r\n            if (!sameKey) {\r\n                submit = this._curSubmit = SubmitTexture.create(this, this._mesh, Value2D.create(ShaderDefines2D.TEXTURE2D, 0));\r\n                this._submits[this._submits._length++] = submit;\r\n                this._copyClipInfo(submit, this._globalClipMatrix);\r\n                submit.shaderValue.textureHost = this._lastTex;\r\n                submit._key.other = (this._lastTex && this._lastTex.bitmap) ? this._lastTex.bitmap.id : -1;\r\n                submit._renderType = SubmitBase.TYPE_TEXTURE;\r\n            }\r\n            this._curSubmit._numEle += 6;\r\n            this._mesh.indexNum += 6;\r\n            this._mesh.vertNum += 4;\r\n        }\r\n    }\r\n    fillRect(x, y, width, height, fillStyle) {\r\n        var drawstyle = fillStyle ? DrawStyle.create(fillStyle) : this._shader2D.fillStyle;\r\n        var rgba = this.mixRGBandAlpha(drawstyle.toInt());\r\n        this._fillRect(x, y, width, height, rgba);\r\n    }\r\n    fillTexture(texture, x, y, width, height, type, offset, other) {\r\n        if (!texture._getSource()) {\r\n            this.sprite && ILaya.systemTimer.callLater(this, this._repaintSprite);\r\n            return;\r\n        }\r\n        this._fillTexture(texture, texture.width, texture.height, texture.uvrect, x, y, width, height, type, offset.x, offset.y);\r\n    }\r\n    _fillTexture(texture, texw, texh, texuvRect, x, y, width, height, type, offsetx, offsety) {\r\n        var submit = this._curSubmit;\r\n        var sameKey = false;\r\n        if (this._mesh.vertNum + 4 > Context._MAXVERTNUM) {\r\n            this._mesh = MeshQuadTexture.getAMesh(this.isMain);\r\n            this.meshlist.push(this._mesh);\r\n            sameKey = false;\r\n        }\r\n        var repeatx = true;\r\n        var repeaty = true;\r\n        switch (type) {\r\n            case \"repeat\": break;\r\n            case \"repeat-x\":\r\n                repeaty = false;\r\n                break;\r\n            case \"repeat-y\":\r\n                repeatx = false;\r\n                break;\r\n            case \"no-repeat\":\r\n                repeatx = repeaty = false;\r\n                break;\r\n            default: break;\r\n        }\r\n        var uv = this._temp4Points;\r\n        var stu = 0;\r\n        var stv = 0;\r\n        var stx = 0, sty = 0, edx = 0, edy = 0;\r\n        if (offsetx < 0) {\r\n            stx = x;\r\n            stu = (-offsetx % texw) / texw;\r\n        }\r\n        else {\r\n            stx = x + offsetx;\r\n        }\r\n        if (offsety < 0) {\r\n            sty = y;\r\n            stv = (-offsety % texh) / texh;\r\n        }\r\n        else {\r\n            sty = y + offsety;\r\n        }\r\n        edx = x + width;\r\n        edy = y + height;\r\n        (!repeatx) && (edx = Math.min(edx, x + offsetx + texw));\r\n        (!repeaty) && (edy = Math.min(edy, y + offsety + texh));\r\n        if (edx < x || edy < y)\r\n            return;\r\n        if (stx > edx || sty > edy)\r\n            return;\r\n        var edu = (edx - x - offsetx) / texw;\r\n        var edv = (edy - y - offsety) / texh;\r\n        this.transformQuad(stx, sty, edx - stx, edy - sty, 0, this._curMat, this._transedPoints);\r\n        uv[0] = stu;\r\n        uv[1] = stv;\r\n        uv[2] = edu;\r\n        uv[3] = stv;\r\n        uv[4] = edu;\r\n        uv[5] = edv;\r\n        uv[6] = stu;\r\n        uv[7] = edv;\r\n        if (!this.clipedOff(this._transedPoints)) {\r\n            var rgba = this._mixRGBandAlpha(0xffffffff, this._shader2D.ALPHA);\r\n            this._mesh.addQuad(this._transedPoints, uv, rgba, true);\r\n            var sv = Value2D.create(ShaderDefines2D.TEXTURE2D, 0);\r\n            sv.defines.add(ShaderDefines2D.FILLTEXTURE);\r\n            sv.u_TexRange = texuvRect.concat();\r\n            submit = this._curSubmit = SubmitTexture.create(this, this._mesh, sv);\r\n            this._submits[this._submits._length++] = submit;\r\n            this._copyClipInfo(submit, this._globalClipMatrix);\r\n            submit.shaderValue.textureHost = texture;\r\n            submit._renderType = SubmitBase.TYPE_TEXTURE;\r\n            this._curSubmit._numEle += 6;\r\n            this._mesh.indexNum += 6;\r\n            this._mesh.vertNum += 4;\r\n        }\r\n        this.breakNextMerge();\r\n    }\r\n    setColorFilter(filter) {\r\n        SaveBase.save(this, SaveBase.TYPE_COLORFILTER, this, true);\r\n        this._colorFiler = filter;\r\n        this._curSubmit = SubmitBase.RENDERBASE;\r\n    }\r\n    drawTexture(tex, x, y, width, height) {\r\n        this._drawTextureM(tex, x, y, width, height, null, 1, null);\r\n    }\r\n    drawTextures(tex, pos, tx, ty) {\r\n        if (!tex._getSource()) {\r\n            this.sprite && ILaya.systemTimer.callLater(this, this._repaintSprite);\r\n            return;\r\n        }\r\n        var n = pos.length / 2;\r\n        var ipos = 0;\r\n        var bmpid = tex.bitmap.id;\r\n        for (var i = 0; i < n; i++) {\r\n            this._inner_drawTexture(tex, bmpid, pos[ipos++] + tx, pos[ipos++] + ty, 0, 0, null, null, 1.0, false);\r\n        }\r\n    }\r\n    _drawTextureAddSubmit(imgid, tex) {\r\n        var submit = null;\r\n        submit = SubmitTexture.create(this, this._mesh, Value2D.create(ShaderDefines2D.TEXTURE2D, 0));\r\n        this._submits[this._submits._length++] = submit;\r\n        submit.shaderValue.textureHost = tex;\r\n        submit._key.other = imgid;\r\n        submit._renderType = SubmitBase.TYPE_TEXTURE;\r\n        this._curSubmit = submit;\r\n    }\r\n    _drawTextureM(tex, x, y, width, height, m, alpha, uv) {\r\n        var cs = this.sprite;\r\n        if (!tex._getSource(function () {\r\n            if (cs) {\r\n                cs.repaint();\r\n            }\r\n        })) {\r\n            return false;\r\n        }\r\n        return this._inner_drawTexture(tex, tex.bitmap.id, x, y, width, height, m, uv, alpha, false);\r\n    }\r\n    _drawRenderTexture(tex, x, y, width, height, m, alpha, uv) {\r\n        return this._inner_drawTexture(tex, -1, x, y, width, height, m, uv, 1.0, false);\r\n    }\r\n    submitDebugger() {\r\n        this._submits[this._submits._length++] = SubmitCMD.create([], function () { debugger; }, this);\r\n    }\r\n    _copyClipInfo(submit, clipInfo) {\r\n        var cm = submit.shaderValue.clipMatDir;\r\n        cm[0] = clipInfo.a;\r\n        cm[1] = clipInfo.b;\r\n        cm[2] = clipInfo.c;\r\n        cm[3] = clipInfo.d;\r\n        var cmp = submit.shaderValue.clipMatPos;\r\n        cmp[0] = clipInfo.tx;\r\n        cmp[1] = clipInfo.ty;\r\n        submit.clipInfoID = this._clipInfoID;\r\n        if (this._clipInCache) {\r\n            submit.shaderValue.clipOff[0] = 1;\r\n        }\r\n    }\r\n    isSameClipInfo(submit) {\r\n        return (submit.clipInfoID === this._clipInfoID);\r\n    }\r\n    _useNewTex2DSubmit(tex, minVertNum) {\r\n        if (this._mesh.vertNum + minVertNum > Context._MAXVERTNUM) {\r\n            this._mesh = MeshQuadTexture.getAMesh(this.isMain);\r\n            this.meshlist.push(this._mesh);\r\n        }\r\n        var submit = SubmitTexture.create(this, this._mesh, Value2D.create(ShaderDefines2D.TEXTURE2D, 0));\r\n        this._submits[this._submits._length++] = this._curSubmit = submit;\r\n        submit.shaderValue.textureHost = tex;\r\n        this._copyClipInfo(submit, this._globalClipMatrix);\r\n    }\r\n    _drawTexRect(x, y, w, h, uv) {\r\n        this.transformQuad(x, y, w, h, this._italicDeg, this._curMat, this._transedPoints);\r\n        var ops = this._transedPoints;\r\n        ops[0] = (ops[0] + 0.5) | 0;\r\n        ops[1] = (ops[1] + 0.5) | 0;\r\n        ops[2] = (ops[2] + 0.5) | 0;\r\n        ops[3] = (ops[3] + 0.5) | 0;\r\n        ops[4] = (ops[4] + 0.5) | 0;\r\n        ops[5] = (ops[5] + 0.5) | 0;\r\n        ops[6] = (ops[6] + 0.5) | 0;\r\n        ops[7] = (ops[7] + 0.5) | 0;\r\n        if (!this.clipedOff(this._transedPoints)) {\r\n            this._mesh.addQuad(this._transedPoints, uv, this._fillColor, true);\r\n            this._curSubmit._numEle += 6;\r\n            this._mesh.indexNum += 6;\r\n            this._mesh.vertNum += 4;\r\n        }\r\n    }\r\n    drawCallOptimize(enable) {\r\n        this._charSubmitCache.enable(enable, this);\r\n        return enable;\r\n    }\r\n    _inner_drawTexture(tex, imgid, x, y, width, height, m, uv, alpha, lastRender) {\r\n        if (width <= 0 || height <= 0) {\r\n            return false;\r\n        }\r\n        var preKey = this._curSubmit._key;\r\n        uv = uv || tex._uv;\r\n        if (preKey.submitType === SubmitBase.KEY_TRIANGLES && preKey.other === imgid) {\r\n            var tv = this._drawTexToDrawTri_Vert;\r\n            tv[0] = x;\r\n            tv[1] = y;\r\n            tv[2] = x + width, tv[3] = y, tv[4] = x + width, tv[5] = y + height, tv[6] = x, tv[7] = y + height;\r\n            this._drawTriUseAbsMatrix = true;\r\n            var tuv = this._tempUV;\r\n            tuv[0] = uv[0];\r\n            tuv[1] = uv[1];\r\n            tuv[2] = uv[2];\r\n            tuv[3] = uv[3];\r\n            tuv[4] = uv[4];\r\n            tuv[5] = uv[5];\r\n            tuv[6] = uv[6];\r\n            tuv[7] = uv[7];\r\n            this.drawTriangles(tex, 0, 0, tv, tuv, this._drawTexToDrawTri_Index, m, alpha, null, null);\r\n            this._drawTriUseAbsMatrix = false;\r\n            return true;\r\n        }\r\n        var mesh = this._mesh;\r\n        var submit = this._curSubmit;\r\n        var ops = lastRender ? this._charSubmitCache.getPos() : this._transedPoints;\r\n        this.transformQuad(x, y, width || tex.width, height || tex.height, this._italicDeg, m || this._curMat, ops);\r\n        if (this.drawTexAlign) {\r\n            var round = Math.round;\r\n            ops[0] = round(ops[0]);\r\n            ops[1] = round(ops[1]);\r\n            ops[2] = round(ops[2]);\r\n            ops[3] = round(ops[3]);\r\n            ops[4] = round(ops[4]);\r\n            ops[5] = round(ops[5]);\r\n            ops[6] = round(ops[6]);\r\n            ops[7] = round(ops[7]);\r\n            this.drawTexAlign = false;\r\n        }\r\n        var rgba = this._mixRGBandAlpha(0xffffffff, this._shader2D.ALPHA * alpha);\r\n        if (lastRender) {\r\n            this._charSubmitCache.add(this, tex, imgid, ops, uv, rgba);\r\n            return true;\r\n        }\r\n        this._drawCount++;\r\n        var sameKey = imgid >= 0 && preKey.submitType === SubmitBase.KEY_DRAWTEXTURE && preKey.other === imgid;\r\n        sameKey && (sameKey = sameKey && this.isSameClipInfo(submit));\r\n        this._lastTex = tex;\r\n        if (mesh.vertNum + 4 > Context._MAXVERTNUM) {\r\n            mesh = this._mesh = MeshQuadTexture.getAMesh(this.isMain);\r\n            this.meshlist.push(mesh);\r\n            sameKey = false;\r\n        }\r\n        {\r\n            mesh.addQuad(ops, uv, rgba, true);\r\n            if (!sameKey) {\r\n                this._submits[this._submits._length++] = this._curSubmit = submit = SubmitTexture.create(this, mesh, Value2D.create(ShaderDefines2D.TEXTURE2D, 0));\r\n                submit.shaderValue.textureHost = tex;\r\n                submit._key.other = imgid;\r\n                this._copyClipInfo(submit, this._globalClipMatrix);\r\n            }\r\n            submit._numEle += 6;\r\n            mesh.indexNum += 6;\r\n            mesh.vertNum += 4;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    transform4Points(a, m, out) {\r\n        var tx = m.tx;\r\n        var ty = m.ty;\r\n        var ma = m.a;\r\n        var mb = m.b;\r\n        var mc = m.c;\r\n        var md = m.d;\r\n        var a0 = a[0];\r\n        var a1 = a[1];\r\n        var a2 = a[2];\r\n        var a3 = a[3];\r\n        var a4 = a[4];\r\n        var a5 = a[5];\r\n        var a6 = a[6];\r\n        var a7 = a[7];\r\n        if (m._bTransform) {\r\n            out[0] = a0 * ma + a1 * mc + tx;\r\n            out[1] = a0 * mb + a1 * md + ty;\r\n            out[2] = a2 * ma + a3 * mc + tx;\r\n            out[3] = a2 * mb + a3 * md + ty;\r\n            out[4] = a4 * ma + a5 * mc + tx;\r\n            out[5] = a4 * mb + a5 * md + ty;\r\n            out[6] = a6 * ma + a7 * mc + tx;\r\n            out[7] = a6 * mb + a7 * md + ty;\r\n        }\r\n        else {\r\n            out[0] = a0 + tx;\r\n            out[1] = a1 + ty;\r\n            out[2] = a2 + tx;\r\n            out[3] = a3 + ty;\r\n            out[4] = a4 + tx;\r\n            out[5] = a5 + ty;\r\n            out[6] = a6 + tx;\r\n            out[7] = a7 + ty;\r\n        }\r\n    }\r\n    clipedOff(pt) {\r\n        if (this._clipRect.width <= 0 || this._clipRect.height <= 0)\r\n            return true;\r\n        return false;\r\n    }\r\n    transformQuad(x, y, w, h, italicDeg, m, out) {\r\n        var xoff = 0;\r\n        if (italicDeg != 0) {\r\n            xoff = Math.tan(italicDeg * Math.PI / 180) * h;\r\n        }\r\n        var maxx = x + w;\r\n        var maxy = y + h;\r\n        var tx = m.tx;\r\n        var ty = m.ty;\r\n        var ma = m.a;\r\n        var mb = m.b;\r\n        var mc = m.c;\r\n        var md = m.d;\r\n        var a0 = x + xoff;\r\n        var a1 = y;\r\n        var a2 = maxx + xoff;\r\n        var a3 = y;\r\n        var a4 = maxx;\r\n        var a5 = maxy;\r\n        var a6 = x;\r\n        var a7 = maxy;\r\n        if (m._bTransform) {\r\n            out[0] = a0 * ma + a1 * mc + tx;\r\n            out[1] = a0 * mb + a1 * md + ty;\r\n            out[2] = a2 * ma + a3 * mc + tx;\r\n            out[3] = a2 * mb + a3 * md + ty;\r\n            out[4] = a4 * ma + a5 * mc + tx;\r\n            out[5] = a4 * mb + a5 * md + ty;\r\n            out[6] = a6 * ma + a7 * mc + tx;\r\n            out[7] = a6 * mb + a7 * md + ty;\r\n        }\r\n        else {\r\n            out[0] = a0 + tx;\r\n            out[1] = a1 + ty;\r\n            out[2] = a2 + tx;\r\n            out[3] = a3 + ty;\r\n            out[4] = a4 + tx;\r\n            out[5] = a5 + ty;\r\n            out[6] = a6 + tx;\r\n            out[7] = a7 + ty;\r\n        }\r\n    }\r\n    pushRT() {\r\n        this.addRenderObject(SubmitCMD.create(null, RenderTexture2D.pushRT, this));\r\n    }\r\n    popRT() {\r\n        this.addRenderObject(SubmitCMD.create(null, RenderTexture2D.popRT, this));\r\n        this.breakNextMerge();\r\n    }\r\n    useRT(rt) {\r\n        function _use(rt) {\r\n            if (!rt) {\r\n                throw 'error useRT';\r\n            }\r\n            else {\r\n                rt.start();\r\n                rt.clear(0, 0, 0, 0);\r\n            }\r\n        }\r\n        this.addRenderObject(SubmitCMD.create([rt], _use, this));\r\n        this.breakNextMerge();\r\n    }\r\n    RTRestore(rt) {\r\n        function _restore(rt) {\r\n            rt.restore();\r\n        }\r\n        this.addRenderObject(SubmitCMD.create([rt], _restore, this));\r\n        this.breakNextMerge();\r\n    }\r\n    breakNextMerge() {\r\n        this._curSubmit = SubmitBase.RENDERBASE;\r\n    }\r\n    _repaintSprite() {\r\n        this.sprite && this.sprite.repaint();\r\n    }\r\n    drawTextureWithTransform(tex, x, y, width, height, transform, tx, ty, alpha, blendMode, colorfilter = null, uv) {\r\n        var oldcomp;\r\n        var curMat = this._curMat;\r\n        if (blendMode) {\r\n            oldcomp = this.globalCompositeOperation;\r\n            this.globalCompositeOperation = blendMode;\r\n        }\r\n        var oldColorFilter = this._colorFiler;\r\n        if (colorfilter) {\r\n            this.setColorFilter(colorfilter);\r\n        }\r\n        if (!transform) {\r\n            this._drawTextureM(tex, x + tx, y + ty, width, height, curMat, alpha, uv);\r\n            if (blendMode) {\r\n                this.globalCompositeOperation = oldcomp;\r\n            }\r\n            if (colorfilter) {\r\n                this.setColorFilter(oldColorFilter);\r\n            }\r\n            return;\r\n        }\r\n        var tmpMat = this._tmpMatrix;\r\n        tmpMat.a = transform.a;\r\n        tmpMat.b = transform.b;\r\n        tmpMat.c = transform.c;\r\n        tmpMat.d = transform.d;\r\n        tmpMat.tx = transform.tx + tx;\r\n        tmpMat.ty = transform.ty + ty;\r\n        tmpMat._bTransform = transform._bTransform;\r\n        if (transform && curMat._bTransform) {\r\n            Matrix.mul(tmpMat, curMat, tmpMat);\r\n            transform = tmpMat;\r\n            transform._bTransform = true;\r\n        }\r\n        else {\r\n            tmpMat.tx += curMat.tx;\r\n            tmpMat.ty += curMat.ty;\r\n            transform = tmpMat;\r\n        }\r\n        this._drawTextureM(tex, x, y, width, height, transform, alpha, uv);\r\n        if (blendMode) {\r\n            this.globalCompositeOperation = oldcomp;\r\n        }\r\n        if (colorfilter) {\r\n            this.setColorFilter(oldColorFilter);\r\n        }\r\n    }\r\n    _flushToTarget(context, target) {\r\n        RenderState2D.worldScissorTest = false;\r\n        var gl = LayaGL.instance;\r\n        gl.disable(gl.SCISSOR_TEST);\r\n        var preAlpha = RenderState2D.worldAlpha;\r\n        var preMatrix4 = RenderState2D.worldMatrix4;\r\n        var preMatrix = RenderState2D.worldMatrix;\r\n        var preShaderDefines = RenderState2D.worldShaderDefines;\r\n        RenderState2D.worldMatrix = Matrix.EMPTY;\r\n        RenderState2D.restoreTempArray();\r\n        RenderState2D.worldMatrix4 = RenderState2D.TEMPMAT4_ARRAY;\r\n        RenderState2D.worldAlpha = 1;\r\n        BaseShader.activeShader = null;\r\n        target.start();\r\n        if (context._submits._length > 0)\r\n            target.clear(0, 0, 0, 0);\r\n        context._curSubmit = SubmitBase.RENDERBASE;\r\n        context.flush();\r\n        context.clear();\r\n        target.restore();\r\n        context._curSubmit = SubmitBase.RENDERBASE;\r\n        BaseShader.activeShader = null;\r\n        RenderState2D.worldAlpha = preAlpha;\r\n        RenderState2D.worldMatrix4 = preMatrix4;\r\n        RenderState2D.worldMatrix = preMatrix;\r\n    }\r\n    drawCanvas(canvas, x, y, width, height) {\r\n        if (!canvas)\r\n            return;\r\n        var src = canvas.context;\r\n        var submit;\r\n        if (src._targets) {\r\n            if (src._submits._length > 0) {\r\n                submit = SubmitCMD.create([src, src._targets], this._flushToTarget, this);\r\n                this._submits[this._submits._length++] = submit;\r\n            }\r\n            this._drawRenderTexture(src._targets, x, y, width, height, null, 1.0, RenderTexture2D.flipyuv);\r\n            this._curSubmit = SubmitBase.RENDERBASE;\r\n        }\r\n        else {\r\n            var canv = canvas;\r\n            if (canv.touches) {\r\n                canv.touches.forEach(function (v) { v.touch(); });\r\n            }\r\n            submit = SubmitCanvas.create(canvas, this._shader2D.ALPHA, this._shader2D.filters);\r\n            this._submits[this._submits._length++] = submit;\r\n            submit._key.clear();\r\n            var mat = submit._matrix;\r\n            this._curMat.copyTo(mat);\r\n            var tx = mat.tx, ty = mat.ty;\r\n            mat.tx = mat.ty = 0;\r\n            mat.transformPoint(Point.TEMP.setTo(x, y));\r\n            mat.translate(Point.TEMP.x + tx, Point.TEMP.y + ty);\r\n            Matrix.mul(canv.invMat, mat, mat);\r\n            this._curSubmit = SubmitBase.RENDERBASE;\r\n        }\r\n    }\r\n    drawTarget(rt, x, y, width, height, m, shaderValue, uv = null, blend = -1) {\r\n        this._drawCount++;\r\n        var rgba = 0xffffffff;\r\n        if (this._mesh.vertNum + 4 > Context._MAXVERTNUM) {\r\n            this._mesh = MeshQuadTexture.getAMesh(this.isMain);\r\n            this.meshlist.push(this._mesh);\r\n        }\r\n        this.transformQuad(x, y, width, height, 0, m || this._curMat, this._transedPoints);\r\n        if (!this.clipedOff(this._transedPoints)) {\r\n            this._mesh.addQuad(this._transedPoints, uv || Texture.DEF_UV, 0xffffffff, true);\r\n            var submit = this._curSubmit = SubmitTarget.create(this, this._mesh, shaderValue, rt);\r\n            submit.blendType = (blend == -1) ? this._nBlendType : blend;\r\n            this._copyClipInfo(submit, this._globalClipMatrix);\r\n            submit._numEle = 6;\r\n            this._mesh.indexNum += 6;\r\n            this._mesh.vertNum += 4;\r\n            this._submits[this._submits._length++] = submit;\r\n            this._curSubmit = SubmitBase.RENDERBASE;\r\n            return true;\r\n        }\r\n        this._curSubmit = SubmitBase.RENDERBASE;\r\n        return false;\r\n    }\r\n    drawTriangles(tex, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode, colorNum = 0xffffffff) {\r\n        if (!tex._getSource()) {\r\n            if (this.sprite) {\r\n                ILaya.systemTimer.callLater(this, this._repaintSprite);\r\n            }\r\n            return;\r\n        }\r\n        var oldcomp = null;\r\n        if (blendMode) {\r\n            oldcomp = this.globalCompositeOperation;\r\n            this.globalCompositeOperation = blendMode;\r\n        }\r\n        this._drawCount++;\r\n        var tmpMat = this._tmpMatrix;\r\n        var triMesh = this._triangleMesh;\r\n        var oldColorFilter = null;\r\n        var needRestorFilter = false;\r\n        if (color) {\r\n            oldColorFilter = this._colorFiler;\r\n            this._colorFiler = color;\r\n            this._curSubmit = SubmitBase.RENDERBASE;\r\n            needRestorFilter = oldColorFilter != color;\r\n        }\r\n        var webGLImg = tex.bitmap;\r\n        var preKey = this._curSubmit._key;\r\n        var sameKey = preKey.submitType === SubmitBase.KEY_TRIANGLES && preKey.other === webGLImg.id && preKey.blendShader == this._nBlendType;\r\n        if (triMesh.vertNum + vertices.length / 2 > Context._MAXVERTNUM) {\r\n            triMesh = this._triangleMesh = MeshTexture.getAMesh(this.isMain);\r\n            this.meshlist.push(triMesh);\r\n            sameKey = false;\r\n        }\r\n        if (!sameKey) {\r\n            var submit = this._curSubmit = SubmitTexture.create(this, triMesh, Value2D.create(ShaderDefines2D.TEXTURE2D, 0));\r\n            submit.shaderValue.textureHost = tex;\r\n            submit._renderType = SubmitBase.TYPE_TEXTURE;\r\n            submit._key.submitType = SubmitBase.KEY_TRIANGLES;\r\n            submit._key.other = webGLImg.id;\r\n            this._copyClipInfo(submit, this._globalClipMatrix);\r\n            this._submits[this._submits._length++] = submit;\r\n        }\r\n        var rgba = this._mixRGBandAlpha(colorNum, this._shader2D.ALPHA * alpha);\r\n        if (!this._drawTriUseAbsMatrix) {\r\n            if (!matrix) {\r\n                tmpMat.a = 1;\r\n                tmpMat.b = 0;\r\n                tmpMat.c = 0;\r\n                tmpMat.d = 1;\r\n                tmpMat.tx = x;\r\n                tmpMat.ty = y;\r\n            }\r\n            else {\r\n                tmpMat.a = matrix.a;\r\n                tmpMat.b = matrix.b;\r\n                tmpMat.c = matrix.c;\r\n                tmpMat.d = matrix.d;\r\n                tmpMat.tx = matrix.tx + x;\r\n                tmpMat.ty = matrix.ty + y;\r\n            }\r\n            Matrix.mul(tmpMat, this._curMat, tmpMat);\r\n            triMesh.addData(vertices, uvs, indices, tmpMat || this._curMat, rgba);\r\n        }\r\n        else {\r\n            triMesh.addData(vertices, uvs, indices, matrix, rgba);\r\n        }\r\n        this._curSubmit._numEle += indices.length;\r\n        if (needRestorFilter) {\r\n            this._colorFiler = oldColorFilter;\r\n            this._curSubmit = SubmitBase.RENDERBASE;\r\n        }\r\n        if (blendMode) {\r\n            this.globalCompositeOperation = oldcomp;\r\n        }\r\n    }\r\n    transform(a, b, c, d, tx, ty) {\r\n        SaveTransform.save(this);\r\n        Matrix.mul(Matrix.TEMP.setTo(a, b, c, d, tx, ty), this._curMat, this._curMat);\r\n        this._curMat._checkTransform();\r\n    }\r\n    _transformByMatrix(matrix, tx, ty) {\r\n        matrix.setTranslate(tx, ty);\r\n        Matrix.mul(matrix, this._curMat, this._curMat);\r\n        matrix.setTranslate(0, 0);\r\n        this._curMat._bTransform = true;\r\n    }\r\n    setTransformByMatrix(value) {\r\n        value.copyTo(this._curMat);\r\n    }\r\n    rotate(angle) {\r\n        SaveTransform.save(this);\r\n        this._curMat.rotateEx(angle);\r\n    }\r\n    scale(scaleX, scaleY) {\r\n        SaveTransform.save(this);\r\n        this._curMat.scaleEx(scaleX, scaleY);\r\n    }\r\n    clipRect(x, y, width, height) {\r\n        SaveClipRect.save(this);\r\n        if (this._clipRect == Context.MAXCLIPRECT) {\r\n            this._clipRect = new Rectangle(x, y, width, height);\r\n        }\r\n        else {\r\n            this._clipRect.width = width;\r\n            this._clipRect.height = height;\r\n            this._clipRect.x = x;\r\n            this._clipRect.y = y;\r\n        }\r\n        this._clipID_Gen++;\r\n        this._clipID_Gen %= 10000;\r\n        this._clipInfoID = this._clipID_Gen;\r\n        var cm = this._globalClipMatrix;\r\n        var minx = cm.tx;\r\n        var miny = cm.ty;\r\n        var maxx = minx + cm.a;\r\n        var maxy = miny + cm.d;\r\n        if (this._clipRect.width >= Context._MAXSIZE) {\r\n            cm.a = cm.d = Context._MAXSIZE;\r\n            cm.b = cm.c = cm.tx = cm.ty = 0;\r\n        }\r\n        else {\r\n            if (this._curMat._bTransform) {\r\n                cm.tx = this._clipRect.x * this._curMat.a + this._clipRect.y * this._curMat.c + this._curMat.tx;\r\n                cm.ty = this._clipRect.x * this._curMat.b + this._clipRect.y * this._curMat.d + this._curMat.ty;\r\n                cm.a = this._clipRect.width * this._curMat.a;\r\n                cm.b = this._clipRect.width * this._curMat.b;\r\n                cm.c = this._clipRect.height * this._curMat.c;\r\n                cm.d = this._clipRect.height * this._curMat.d;\r\n            }\r\n            else {\r\n                cm.tx = this._clipRect.x + this._curMat.tx;\r\n                cm.ty = this._clipRect.y + this._curMat.ty;\r\n                cm.a = this._clipRect.width;\r\n                cm.b = cm.c = 0;\r\n                cm.d = this._clipRect.height;\r\n            }\r\n            if (this._incache) {\r\n                this._clipInCache = true;\r\n            }\r\n        }\r\n        if (cm.a > 0 && cm.d > 0) {\r\n            var cmaxx = cm.tx + cm.a;\r\n            var cmaxy = cm.ty + cm.d;\r\n            if (cmaxx <= minx || cmaxy <= miny || cm.tx >= maxx || cm.ty >= maxy) {\r\n                cm.a = -0.1;\r\n                cm.d = -0.1;\r\n            }\r\n            else {\r\n                if (cm.tx < minx) {\r\n                    cm.a -= (minx - cm.tx);\r\n                    cm.tx = minx;\r\n                }\r\n                if (cmaxx > maxx) {\r\n                    cm.a -= (cmaxx - maxx);\r\n                }\r\n                if (cm.ty < miny) {\r\n                    cm.d -= (miny - cm.ty);\r\n                    cm.ty = miny;\r\n                }\r\n                if (cmaxy > maxy) {\r\n                    cm.d -= (cmaxy - maxy);\r\n                }\r\n                if (cm.a <= 0)\r\n                    cm.a = -0.1;\r\n                if (cm.d <= 0)\r\n                    cm.d = -0.1;\r\n            }\r\n        }\r\n    }\r\n    drawMesh(x, y, ib, vb, numElement, mat, shader, shaderValues, startIndex = 0) {\r\n        ;\r\n    }\r\n    addRenderObject(o) {\r\n        this._submits[this._submits._length++] = o;\r\n    }\r\n    submitElement(start, end) {\r\n        var mainCtx = this.isMain;\r\n        var renderList = this._submits;\r\n        var ret = renderList._length;\r\n        end < 0 && (end = renderList._length);\r\n        var submit = SubmitBase.RENDERBASE;\r\n        while (start < end) {\r\n            this._renderNextSubmitIndex = start + 1;\r\n            if (renderList[start] === SubmitBase.RENDERBASE) {\r\n                start++;\r\n                continue;\r\n            }\r\n            SubmitBase.preRender = submit;\r\n            submit = renderList[start];\r\n            start += submit.renderSubmit();\r\n        }\r\n        return ret;\r\n    }\r\n    flush() {\r\n        this._clipID_Gen = 0;\r\n        var ret = this.submitElement(0, this._submits._length);\r\n        this._path && this._path.reset();\r\n        SkinMeshBuffer.instance && SkinMeshBuffer.getInstance().reset();\r\n        this._curSubmit = SubmitBase.RENDERBASE;\r\n        for (var i = 0, sz = this.meshlist.length; i < sz; i++) {\r\n            var curm = this.meshlist[i];\r\n            curm.canReuse ? (curm.releaseMesh()) : (curm.destroy());\r\n        }\r\n        this.meshlist.length = 0;\r\n        this._mesh = MeshQuadTexture.getAMesh(this.isMain);\r\n        this._pathMesh = MeshVG.getAMesh(this.isMain);\r\n        this._triangleMesh = MeshTexture.getAMesh(this.isMain);\r\n        this.meshlist.push(this._mesh, this._pathMesh, this._triangleMesh);\r\n        this._flushCnt++;\r\n        if (this._flushCnt % 60 == 0 && this.isMain) {\r\n            if (TextRender.textRenderInst) {\r\n                TextRender.textRenderInst.GC();\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    beginPath(convex = false) {\r\n        var tPath = this._getPath();\r\n        tPath.beginPath(convex);\r\n    }\r\n    closePath() {\r\n        this._path.closePath();\r\n    }\r\n    addPath(points, close, convex, dx, dy) {\r\n        var ci = 0;\r\n        for (var i = 0, sz = points.length / 2; i < sz; i++) {\r\n            var x1 = points[ci] + dx, y1 = points[ci + 1] + dy;\r\n            points[ci] = x1;\r\n            points[ci + 1] = y1;\r\n            ci += 2;\r\n        }\r\n        this._getPath().push(points, convex);\r\n    }\r\n    fill() {\r\n        var m = this._curMat;\r\n        var tPath = this._getPath();\r\n        var submit = this._curSubmit;\r\n        var sameKey = (submit._key.submitType === SubmitBase.KEY_VG && submit._key.blendShader === this._nBlendType);\r\n        sameKey && (sameKey = sameKey && this.isSameClipInfo(submit));\r\n        if (!sameKey) {\r\n            this._curSubmit = this.addVGSubmit(this._pathMesh);\r\n        }\r\n        var rgba = this.mixRGBandAlpha(this.fillStyle.toInt());\r\n        var curEleNum = 0;\r\n        var idx;\r\n        for (var i = 0, sz = tPath.paths.length; i < sz; i++) {\r\n            var p = tPath.paths[i];\r\n            var vertNum = p.path.length / 2;\r\n            if (vertNum < 3 || (vertNum == 3 && !p.convex))\r\n                continue;\r\n            var cpath = p.path.concat();\r\n            var pi = 0;\r\n            var xp, yp;\r\n            var _x, _y;\r\n            if (m._bTransform) {\r\n                for (pi = 0; pi < vertNum; pi++) {\r\n                    xp = pi << 1;\r\n                    yp = xp + 1;\r\n                    _x = cpath[xp];\r\n                    _y = cpath[yp];\r\n                    cpath[xp] = m.a * _x + m.c * _y + m.tx;\r\n                    cpath[yp] = m.b * _x + m.d * _y + m.ty;\r\n                }\r\n            }\r\n            else {\r\n                for (pi = 0; pi < vertNum; pi++) {\r\n                    xp = pi << 1;\r\n                    yp = xp + 1;\r\n                    _x = cpath[xp];\r\n                    _y = cpath[yp];\r\n                    cpath[xp] = _x + m.tx;\r\n                    cpath[yp] = _y + m.ty;\r\n                }\r\n            }\r\n            if (this._pathMesh.vertNum + vertNum > Context._MAXVERTNUM) {\r\n                this._curSubmit._numEle += curEleNum;\r\n                curEleNum = 0;\r\n                this._pathMesh = MeshVG.getAMesh(this.isMain);\r\n                this._curSubmit = this.addVGSubmit(this._pathMesh);\r\n            }\r\n            var curvert = this._pathMesh.vertNum;\r\n            if (p.convex) {\r\n                var faceNum = vertNum - 2;\r\n                idx = new Array(faceNum * 3);\r\n                var idxpos = 0;\r\n                for (var fi = 0; fi < faceNum; fi++) {\r\n                    idx[idxpos++] = curvert;\r\n                    idx[idxpos++] = fi + 1 + curvert;\r\n                    idx[idxpos++] = fi + 2 + curvert;\r\n                }\r\n            }\r\n            else {\r\n                idx = Earcut.earcut(cpath, null, 2);\r\n                if (curvert > 0) {\r\n                    for (var ii = 0; ii < idx.length; ii++) {\r\n                        idx[ii] += curvert;\r\n                    }\r\n                }\r\n            }\r\n            this._pathMesh.addVertAndIBToMesh(this, cpath, rgba, idx);\r\n            curEleNum += idx.length;\r\n        }\r\n        this._curSubmit._numEle += curEleNum;\r\n    }\r\n    addVGSubmit(mesh) {\r\n        var submit = Submit.createShape(this, mesh, 0, Value2D.create(ShaderDefines2D.PRIMITIVE, 0));\r\n        submit._key.submitType = SubmitBase.KEY_VG;\r\n        this._submits[this._submits._length++] = submit;\r\n        this._copyClipInfo(submit, this._globalClipMatrix);\r\n        return submit;\r\n    }\r\n    stroke() {\r\n        if (this.lineWidth > 0) {\r\n            var rgba = this.mixRGBandAlpha(this.strokeStyle._color.numColor);\r\n            var tPath = this._getPath();\r\n            var submit = this._curSubmit;\r\n            var sameKey = (submit._key.submitType === SubmitBase.KEY_VG && submit._key.blendShader === this._nBlendType);\r\n            sameKey && (sameKey = sameKey && this.isSameClipInfo(submit));\r\n            if (!sameKey) {\r\n                this._curSubmit = this.addVGSubmit(this._pathMesh);\r\n            }\r\n            var curEleNum = 0;\r\n            for (var i = 0, sz = tPath.paths.length; i < sz; i++) {\r\n                var p = tPath.paths[i];\r\n                if (p.path.length <= 0)\r\n                    continue;\r\n                var idx = [];\r\n                var vertex = [];\r\n                var maxVertexNum = p.path.length * 2;\r\n                if (maxVertexNum < 2)\r\n                    continue;\r\n                if (this._pathMesh.vertNum + maxVertexNum > Context._MAXVERTNUM) {\r\n                    this._curSubmit._numEle += curEleNum;\r\n                    curEleNum = 0;\r\n                    this._pathMesh = MeshVG.getAMesh(this.isMain);\r\n                    this.meshlist.push(this._pathMesh);\r\n                    this._curSubmit = this.addVGSubmit(this._pathMesh);\r\n                }\r\n                BasePoly.createLine2(p.path, idx, this.lineWidth, this._pathMesh.vertNum, vertex, p.loop);\r\n                var ptnum = vertex.length / 2;\r\n                var m = this._curMat;\r\n                var pi = 0;\r\n                var xp, yp;\r\n                var _x, _y;\r\n                if (m._bTransform) {\r\n                    for (pi = 0; pi < ptnum; pi++) {\r\n                        xp = pi << 1;\r\n                        yp = xp + 1;\r\n                        _x = vertex[xp];\r\n                        _y = vertex[yp];\r\n                        vertex[xp] = m.a * _x + m.c * _y + m.tx;\r\n                        vertex[yp] = m.b * _x + m.d * _y + m.ty;\r\n                    }\r\n                }\r\n                else {\r\n                    for (pi = 0; pi < ptnum; pi++) {\r\n                        xp = pi << 1;\r\n                        yp = xp + 1;\r\n                        _x = vertex[xp];\r\n                        _y = vertex[yp];\r\n                        vertex[xp] = _x + m.tx;\r\n                        vertex[yp] = _y + m.ty;\r\n                    }\r\n                }\r\n                this._pathMesh.addVertAndIBToMesh(this, vertex, rgba, idx);\r\n                curEleNum += idx.length;\r\n            }\r\n            this._curSubmit._numEle += curEleNum;\r\n        }\r\n    }\r\n    moveTo(x, y) {\r\n        var tPath = this._getPath();\r\n        tPath.newPath();\r\n        tPath._lastOriX = x;\r\n        tPath._lastOriY = y;\r\n        tPath.addPoint(x, y);\r\n    }\r\n    lineTo(x, y) {\r\n        var tPath = this._getPath();\r\n        if (Math.abs(x - tPath._lastOriX) < 1e-3 && Math.abs(y - tPath._lastOriY) < 1e-3)\r\n            return;\r\n        tPath._lastOriX = x;\r\n        tPath._lastOriY = y;\r\n        tPath.addPoint(x, y);\r\n    }\r\n    arcTo(x1, y1, x2, y2, r) {\r\n        var i = 0;\r\n        var x = 0, y = 0;\r\n        var dx = this._path._lastOriX - x1;\r\n        var dy = this._path._lastOriY - y1;\r\n        var len1 = Math.sqrt(dx * dx + dy * dy);\r\n        if (len1 <= 0.000001) {\r\n            return;\r\n        }\r\n        var ndx = dx / len1;\r\n        var ndy = dy / len1;\r\n        var dx2 = x2 - x1;\r\n        var dy2 = y2 - y1;\r\n        var len22 = dx2 * dx2 + dy2 * dy2;\r\n        var len2 = Math.sqrt(len22);\r\n        if (len2 <= 0.000001) {\r\n            return;\r\n        }\r\n        var ndx2 = dx2 / len2;\r\n        var ndy2 = dy2 / len2;\r\n        var odx = ndx + ndx2;\r\n        var ody = ndy + ndy2;\r\n        var olen = Math.sqrt(odx * odx + ody * ody);\r\n        if (olen <= 0.000001) {\r\n            return;\r\n        }\r\n        var nOdx = odx / olen;\r\n        var nOdy = ody / olen;\r\n        var alpha = Math.acos(nOdx * ndx + nOdy * ndy);\r\n        var halfAng = Math.PI / 2 - alpha;\r\n        len1 = r / Math.tan(halfAng);\r\n        var ptx1 = len1 * ndx + x1;\r\n        var pty1 = len1 * ndy + y1;\r\n        var orilen = Math.sqrt(len1 * len1 + r * r);\r\n        var orix = x1 + nOdx * orilen;\r\n        var oriy = y1 + nOdy * orilen;\r\n        var ptx2 = len1 * ndx2 + x1;\r\n        var pty2 = len1 * ndy2 + y1;\r\n        var dir = ndx * ndy2 - ndy * ndx2;\r\n        var fChgAng = 0;\r\n        var sinx = 0.0;\r\n        var cosx = 0.0;\r\n        if (dir >= 0) {\r\n            fChgAng = halfAng * 2;\r\n            var fda = fChgAng / Context.SEGNUM;\r\n            sinx = Math.sin(fda);\r\n            cosx = Math.cos(fda);\r\n        }\r\n        else {\r\n            fChgAng = -halfAng * 2;\r\n            fda = fChgAng / Context.SEGNUM;\r\n            sinx = Math.sin(fda);\r\n            cosx = Math.cos(fda);\r\n        }\r\n        var lastx = this._path._lastOriX, lasty = this._path._lastOriY;\r\n        var _x1 = ptx1, _y1 = pty1;\r\n        if (Math.abs(_x1 - this._path._lastOriX) > 0.1 || Math.abs(_y1 - this._path._lastOriY) > 0.1) {\r\n            x = _x1;\r\n            y = _y1;\r\n            lastx = _x1;\r\n            lasty = _y1;\r\n            this._path._lastOriX = x;\r\n            this._path._lastOriY = y;\r\n            this._path.addPoint(x, y);\r\n        }\r\n        var cvx = ptx1 - orix;\r\n        var cvy = pty1 - oriy;\r\n        var tx = 0.0;\r\n        var ty = 0.0;\r\n        for (i = 0; i < Context.SEGNUM; i++) {\r\n            var cx = cvx * cosx + cvy * sinx;\r\n            var cy = -cvx * sinx + cvy * cosx;\r\n            x = cx + orix;\r\n            y = cy + oriy;\r\n            if (Math.abs(lastx - x) > 0.1 || Math.abs(lasty - y) > 0.1) {\r\n                this._path._lastOriX = x;\r\n                this._path._lastOriY = y;\r\n                this._path.addPoint(x, y);\r\n                lastx = x;\r\n                lasty = y;\r\n            }\r\n            cvx = cx;\r\n            cvy = cy;\r\n        }\r\n    }\r\n    arc(cx, cy, r, startAngle, endAngle, counterclockwise = false, b = true) {\r\n        var a = 0, da = 0, hda = 0, kappa = 0;\r\n        var dx = 0, dy = 0, x = 0, y = 0, tanx = 0, tany = 0;\r\n        var px = 0, py = 0, ptanx = 0, ptany = 0;\r\n        var i, ndivs, nvals;\r\n        da = endAngle - startAngle;\r\n        if (!counterclockwise) {\r\n            if (Math.abs(da) >= Math.PI * 2) {\r\n                da = Math.PI * 2;\r\n            }\r\n            else {\r\n                while (da < 0.0) {\r\n                    da += Math.PI * 2;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (Math.abs(da) >= Math.PI * 2) {\r\n                da = -Math.PI * 2;\r\n            }\r\n            else {\r\n                while (da > 0.0) {\r\n                    da -= Math.PI * 2;\r\n                }\r\n            }\r\n        }\r\n        var sx = this.getMatScaleX();\r\n        var sy = this.getMatScaleY();\r\n        var sr = r * (sx > sy ? sx : sy);\r\n        var cl = 2 * Math.PI * sr;\r\n        ndivs = (Math.max(cl / 10, 10)) | 0;\r\n        hda = (da / ndivs) / 2.0;\r\n        kappa = Math.abs(4 / 3 * (1 - Math.cos(hda)) / Math.sin(hda));\r\n        if (counterclockwise)\r\n            kappa = -kappa;\r\n        nvals = 0;\r\n        var tPath = this._getPath();\r\n        var _x1, _y1;\r\n        for (i = 0; i <= ndivs; i++) {\r\n            a = startAngle + da * (i / ndivs);\r\n            dx = Math.cos(a);\r\n            dy = Math.sin(a);\r\n            x = cx + dx * r;\r\n            y = cy + dy * r;\r\n            if (x != this._path._lastOriX || y != this._path._lastOriY) {\r\n                tPath.addPoint(x, y);\r\n            }\r\n        }\r\n        dx = Math.cos(endAngle);\r\n        dy = Math.sin(endAngle);\r\n        x = cx + dx * r;\r\n        y = cy + dy * r;\r\n        if (x != this._path._lastOriX || y != this._path._lastOriY) {\r\n            tPath.addPoint(x, y);\r\n        }\r\n    }\r\n    quadraticCurveTo(cpx, cpy, x, y) {\r\n        var tBezier = Bezier.I;\r\n        var tResultArray = [];\r\n        var tArray = tBezier.getBezierPoints([this._path._lastOriX, this._path._lastOriY, cpx, cpy, x, y], 30, 2);\r\n        for (var i = 0, n = tArray.length / 2; i < n; i++) {\r\n            this.lineTo(tArray[i * 2], tArray[i * 2 + 1]);\r\n        }\r\n        this.lineTo(x, y);\r\n    }\r\n    mixRGBandAlpha(color) {\r\n        return this._mixRGBandAlpha(color, this._shader2D.ALPHA);\r\n    }\r\n    _mixRGBandAlpha(color, alpha) {\r\n        if (alpha >= 1) {\r\n            return color;\r\n        }\r\n        var a = ((color & 0xff000000) >>> 24);\r\n        if (a != 0) {\r\n            a *= alpha;\r\n        }\r\n        else {\r\n            a = alpha * 255;\r\n        }\r\n        return (color & 0x00ffffff) | (a << 24);\r\n    }\r\n    strokeRect(x, y, width, height, parameterLineWidth) {\r\n        var tW = parameterLineWidth * 0.5;\r\n        if (this.lineWidth > 0) {\r\n            var rgba = this.mixRGBandAlpha(this.strokeStyle._color.numColor);\r\n            var hw = this.lineWidth / 2;\r\n            this._fillRect(x - hw, y - hw, width + this.lineWidth, this.lineWidth, rgba);\r\n            this._fillRect(x - hw, y - hw + height, width + this.lineWidth, this.lineWidth, rgba);\r\n            this._fillRect(x - hw, y + hw, this.lineWidth, height - this.lineWidth, rgba);\r\n            this._fillRect(x - hw + width, y + hw, this.lineWidth, height - this.lineWidth, rgba);\r\n        }\r\n    }\r\n    clip() {\r\n    }\r\n    drawParticle(x, y, pt) {\r\n        pt.x = x;\r\n        pt.y = y;\r\n        this._submits[this._submits._length++] = pt;\r\n    }\r\n    _getPath() {\r\n        return this._path || (this._path = new Path());\r\n    }\r\n    get canvas() {\r\n        return this._canvas;\r\n    }\r\n    _fillTexture_h(tex, imgid, uv, oriw, orih, x, y, w) {\r\n        if (oriw <= 0)\r\n            console.error('_fillTexture_h error: oriw must>0');\r\n        var stx = x;\r\n        var num = Math.floor(w / oriw);\r\n        var left = w % oriw;\r\n        for (var i = 0; i < num; i++) {\r\n            this._inner_drawTexture(tex, imgid, stx, y, oriw, orih, this._curMat, uv, 1, false);\r\n            stx += oriw;\r\n        }\r\n        if (left > 0) {\r\n            var du = uv[2] - uv[0];\r\n            var uvr = uv[0] + du * (left / oriw);\r\n            var tuv = Context.tmpuv1;\r\n            tuv[0] = uv[0];\r\n            tuv[1] = uv[1];\r\n            tuv[2] = uvr;\r\n            tuv[3] = uv[3];\r\n            tuv[4] = uvr;\r\n            tuv[5] = uv[5];\r\n            tuv[6] = uv[6];\r\n            tuv[7] = uv[7];\r\n            this._inner_drawTexture(tex, imgid, stx, y, left, orih, this._curMat, tuv, 1, false);\r\n        }\r\n    }\r\n    _fillTexture_v(tex, imgid, uv, oriw, orih, x, y, h) {\r\n        if (orih <= 0)\r\n            console.error('_fillTexture_v error: orih must>0');\r\n        var sty = y;\r\n        var num = Math.floor(h / orih);\r\n        var left = h % orih;\r\n        for (var i = 0; i < num; i++) {\r\n            this._inner_drawTexture(tex, imgid, x, sty, oriw, orih, this._curMat, uv, 1, false);\r\n            sty += orih;\r\n        }\r\n        if (left > 0) {\r\n            var dv = uv[7] - uv[1];\r\n            var uvb = uv[1] + dv * (left / orih);\r\n            var tuv = Context.tmpuv1;\r\n            tuv[0] = uv[0];\r\n            tuv[1] = uv[1];\r\n            tuv[2] = uv[2];\r\n            tuv[3] = uv[3];\r\n            tuv[4] = uv[4];\r\n            tuv[5] = uvb;\r\n            tuv[6] = uv[6];\r\n            tuv[7] = uvb;\r\n            this._inner_drawTexture(tex, imgid, x, sty, oriw, left, this._curMat, tuv, 1, false);\r\n        }\r\n    }\r\n    drawTextureWithSizeGrid(tex, tx, ty, width, height, sizeGrid, gx, gy) {\r\n        if (!tex._getSource())\r\n            return;\r\n        tx += gx;\r\n        ty += gy;\r\n        var uv = tex.uv, w = tex.bitmap.width, h = tex.bitmap.height;\r\n        var top = sizeGrid[0];\r\n        var left = sizeGrid[3];\r\n        var right = sizeGrid[1];\r\n        var bottom = sizeGrid[2];\r\n        var repeat = sizeGrid[4];\r\n        var needClip = false;\r\n        if (width == w) {\r\n            left = right = 0;\r\n        }\r\n        if (height == h) {\r\n            top = bottom = 0;\r\n        }\r\n        var d_top = top / h;\r\n        var d_left = left / w;\r\n        var d_right = right / w;\r\n        var d_bottom = bottom / h;\r\n        if (left + right > width) {\r\n            var clipWidth = width;\r\n            needClip = true;\r\n            width = left + right;\r\n            this.save();\r\n            this.clipRect(0 + tx, 0 + ty, clipWidth, height);\r\n        }\r\n        var imgid = tex.bitmap.id;\r\n        var mat = this._curMat;\r\n        var tuv = this._tempUV;\r\n        var uvl = uv[0];\r\n        var uvt = uv[1];\r\n        var uvr = uv[4];\r\n        var uvb = uv[5];\r\n        var uvl_ = uvl;\r\n        var uvt_ = uvt;\r\n        var uvr_ = uvr;\r\n        var uvb_ = uvb;\r\n        if (left && top) {\r\n            uvr_ = uvl + d_left;\r\n            uvb_ = uvt + d_top;\r\n            tuv[0] = uvl, tuv[1] = uvt, tuv[2] = uvr_, tuv[3] = uvt,\r\n                tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl, tuv[7] = uvb_;\r\n            this._inner_drawTexture(tex, imgid, tx, ty, left, top, mat, tuv, 1, false);\r\n        }\r\n        if (right && top) {\r\n            uvl_ = uvr - d_right;\r\n            uvt_ = uvt;\r\n            uvr_ = uvr;\r\n            uvb_ = uvt + d_top;\r\n            tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,\r\n                tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;\r\n            this._inner_drawTexture(tex, imgid, width - right + tx, 0 + ty, right, top, mat, tuv, 1, false);\r\n        }\r\n        if (left && bottom) {\r\n            uvl_ = uvl;\r\n            uvt_ = uvb - d_bottom;\r\n            uvr_ = uvl + d_left;\r\n            uvb_ = uvb;\r\n            tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,\r\n                tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;\r\n            this._inner_drawTexture(tex, imgid, 0 + tx, height - bottom + ty, left, bottom, mat, tuv, 1, false);\r\n        }\r\n        if (right && bottom) {\r\n            uvl_ = uvr - d_right;\r\n            uvt_ = uvb - d_bottom;\r\n            uvr_ = uvr;\r\n            uvb_ = uvb;\r\n            tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,\r\n                tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;\r\n            this._inner_drawTexture(tex, imgid, width - right + tx, height - bottom + ty, right, bottom, mat, tuv, 1, false);\r\n        }\r\n        if (top) {\r\n            uvl_ = uvl + d_left;\r\n            uvt_ = uvt;\r\n            uvr_ = uvr - d_right;\r\n            uvb_ = uvt + d_top;\r\n            tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,\r\n                tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;\r\n            if (repeat) {\r\n                this._fillTexture_h(tex, imgid, tuv, tex.width - left - right, top, left + tx, ty, width - left - right);\r\n            }\r\n            else {\r\n                this._inner_drawTexture(tex, imgid, left + tx, ty, width - left - right, top, mat, tuv, 1, false);\r\n            }\r\n        }\r\n        if (bottom) {\r\n            uvl_ = uvl + d_left;\r\n            uvt_ = uvb - d_bottom;\r\n            uvr_ = uvr - d_right;\r\n            uvb_ = uvb;\r\n            tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,\r\n                tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;\r\n            if (repeat) {\r\n                this._fillTexture_h(tex, imgid, tuv, tex.width - left - right, bottom, left + tx, height - bottom + ty, width - left - right);\r\n            }\r\n            else {\r\n                this._inner_drawTexture(tex, imgid, left + tx, height - bottom + ty, width - left - right, bottom, mat, tuv, 1, false);\r\n            }\r\n        }\r\n        if (left) {\r\n            uvl_ = uvl;\r\n            uvt_ = uvt + d_top;\r\n            uvr_ = uvl + d_left;\r\n            uvb_ = uvb - d_bottom;\r\n            tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,\r\n                tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;\r\n            if (repeat) {\r\n                this._fillTexture_v(tex, imgid, tuv, left, tex.height - top - bottom, tx, top + ty, height - top - bottom);\r\n            }\r\n            else {\r\n                this._inner_drawTexture(tex, imgid, tx, top + ty, left, height - top - bottom, mat, tuv, 1, false);\r\n            }\r\n        }\r\n        if (right) {\r\n            uvl_ = uvr - d_right;\r\n            uvt_ = uvt + d_top;\r\n            uvr_ = uvr;\r\n            uvb_ = uvb - d_bottom;\r\n            tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,\r\n                tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;\r\n            if (repeat) {\r\n                this._fillTexture_v(tex, imgid, tuv, right, tex.height - top - bottom, width - right + tx, top + ty, height - top - bottom);\r\n            }\r\n            else {\r\n                this._inner_drawTexture(tex, imgid, width - right + tx, top + ty, right, height - top - bottom, mat, tuv, 1, false);\r\n            }\r\n        }\r\n        uvl_ = uvl + d_left;\r\n        uvt_ = uvt + d_top;\r\n        uvr_ = uvr - d_right;\r\n        uvb_ = uvb - d_bottom;\r\n        tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,\r\n            tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;\r\n        if (repeat) {\r\n            var tuvr = Context.tmpUVRect;\r\n            tuvr[0] = uvl_;\r\n            tuvr[1] = uvt_;\r\n            tuvr[2] = uvr_ - uvl_;\r\n            tuvr[3] = uvb_ - uvt_;\r\n            this._fillTexture(tex, tex.width - left - right, tex.height - top - bottom, tuvr, left + tx, top + ty, width - left - right, height - top - bottom, 'repeat', 0, 0);\r\n        }\r\n        else {\r\n            this._inner_drawTexture(tex, imgid, left + tx, top + ty, width - left - right, height - top - bottom, mat, tuv, 1, false);\r\n        }\r\n        if (needClip)\r\n            this.restore();\r\n    }\r\n}\r\nContext.ENUM_TEXTALIGN_DEFAULT = 0;\r\nContext.ENUM_TEXTALIGN_CENTER = 1;\r\nContext.ENUM_TEXTALIGN_RIGHT = 2;\r\nContext._SUBMITVBSIZE = 32000;\r\nContext._MAXSIZE = 99999999;\r\nContext._MAXVERTNUM = 65535;\r\nContext.MAXCLIPRECT = null;\r\nContext._COUNT = 0;\r\nContext.SEGNUM = 32;\r\nContext._contextcount = 0;\r\nContext.PI2 = 2 * Math.PI;\r\nContext._textRender = null;\r\nContext.tmpuv1 = [0, 0, 0, 0, 0, 0, 0, 0];\r\nContext.tmpUV = [0, 0, 0, 0, 0, 0, 0, 0];\r\nContext.tmpUVRect = [0, 0, 0, 0];\r\nclass ContextParams {\r\n    constructor() {\r\n        this.lineWidth = 1;\r\n    }\r\n    clear() {\r\n        this.lineWidth = 1;\r\n        this.textAlign = this.textBaseline = null;\r\n    }\r\n    make() {\r\n        return this === ContextParams.DEFAULT ? new ContextParams() : this;\r\n    }\r\n}\r\n",
  "references": [
    "F:/ProjectsWorks/font_game_2.10/libs/ILaya.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/display/Sprite.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/filters/ColorFilter.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/layagl/LayaGL.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/maths/Bezier.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/maths/Matrix.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/maths/Point.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/maths/Rectangle.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/utils/FontInfo.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/utils/HTMLChar.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/utils/Stat.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/utils/WordText.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/canvas/BlendMode.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/canvas/DrawStyle.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/canvas/Path.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/canvas/save/ISaveData.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/canvas/save/SaveBase.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/canvas/save/SaveClipRect.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/canvas/save/SaveMark.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/canvas/save/SaveTransform.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/canvas/save/SaveTranslate.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/canvas/WebGLCacheAsNormalCanvas.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/shader/BaseShader.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/shader/d2/Shader2D.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/shader/d2/ShaderDefines2D.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/shader/d2/skinAnishader/SkinMeshBuffer.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/shader/d2/value/Value2D.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/shader/Shader.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/shapes/BasePoly.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/shapes/Earcut.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/submit/ISubmit.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/submit/Submit.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/submit/SubmitBase.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/submit/SubmitCanvas.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/submit/SubmitCMD.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/submit/SubmitKey.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/submit/SubmitTarget.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/submit/SubmitTexture.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/text/CharRenderInfo.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/text/CharSubmitCache.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/text/TextRender.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/utils/IndexBuffer2D.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/utils/Mesh2D.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/utils/MeshQuadTexture.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/utils/MeshTexture.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/utils/MeshVG.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/utils/RenderState2D.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/utils/VertexBuffer2D.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/webgl/WebGLContext.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/resource/Bitmap.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/resource/HTMLCanvas.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/resource/RenderTexture2D.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/resource/RenderTextureFormat.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/resource/Texture.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/resource/Texture2D.ts"
  ],
  "dts": {
    "name": "F:/ProjectsWorks/font_game_2.10/libs/laya/resource/Context.d.ts",
    "writeByteOrderMark": false,
    "text": "import { Sprite } from \"../display/Sprite\";\r\nimport { ColorFilter } from \"../filters/ColorFilter\";\r\nimport { Matrix } from \"../maths/Matrix\";\r\nimport { Point } from \"../maths/Point\";\r\nimport { Rectangle } from \"../maths/Rectangle\";\r\nimport { HTMLChar } from \"../utils/HTMLChar\";\r\nimport { WordText } from \"../utils/WordText\";\r\nimport { SaveMark } from \"../webgl/canvas/save/SaveMark\";\r\nimport { Shader2D } from \"../webgl/shader/d2/Shader2D\";\r\nimport { Value2D } from \"../webgl/shader/d2/value/Value2D\";\r\nimport { Shader } from \"../webgl/shader/Shader\";\r\nimport { ISubmit } from \"../webgl/submit/ISubmit\";\r\nimport { SubmitBase } from \"../webgl/submit/SubmitBase\";\r\nimport { SubmitKey } from \"../webgl/submit/SubmitKey\";\r\nimport { CharSubmitCache } from \"../webgl/text/CharSubmitCache\";\r\nimport { TextRender } from \"../webgl/text/TextRender\";\r\nimport { IndexBuffer2D } from \"../webgl/utils/IndexBuffer2D\";\r\nimport { MeshQuadTexture } from \"../webgl/utils/MeshQuadTexture\";\r\nimport { MeshTexture } from \"../webgl/utils/MeshTexture\";\r\nimport { MeshVG } from \"../webgl/utils/MeshVG\";\r\nimport { VertexBuffer2D } from \"../webgl/utils/VertexBuffer2D\";\r\nimport { HTMLCanvas } from \"./HTMLCanvas\";\r\nimport { RenderTexture2D } from \"./RenderTexture2D\";\r\nimport { Texture } from \"./Texture\";\r\nexport declare class Context {\r\n    _canvas: HTMLCanvas;\r\n    static ENUM_TEXTALIGN_DEFAULT: number;\r\n    static ENUM_TEXTALIGN_CENTER: number;\r\n    static ENUM_TEXTALIGN_RIGHT: number;\r\n    static _SUBMITVBSIZE: number;\r\n    static _MAXSIZE: number;\r\n    private static _MAXVERTNUM;\r\n    static MAXCLIPRECT: Rectangle;\r\n    static _COUNT: number;\r\n    _tmpMatrix: Matrix;\r\n    private static SEGNUM;\r\n    private static _contextcount;\r\n    private _drawTexToDrawTri_Vert;\r\n    private _drawTexToDrawTri_Index;\r\n    private _tempUV;\r\n    private _drawTriUseAbsMatrix;\r\n    static __init__(): void;\r\n    drawImage(...args: any[]): void;\r\n    getImageData(...args: any[]): any;\r\n    measureText(text: string): any;\r\n    setTransform(...args: any[]): void;\r\n    $transform(a: number, b: number, c: number, d: number, tx: number, ty: number): void;\r\n    lineJoin: string;\r\n    lineCap: string;\r\n    miterLimit: string;\r\n    clearRect(x: number, y: number, width: number, height: number): void;\r\n    _drawRect(x: number, y: number, width: number, height: number, style: any): void;\r\n    drawTexture2(x: number, y: number, pivotX: number, pivotY: number, m: Matrix, args2: any[]): void;\r\n    transformByMatrix(matrix: Matrix, tx: number, ty: number): void;\r\n    saveTransform(matrix: Matrix): void;\r\n    restoreTransform(matrix: Matrix): void;\r\n    drawRect(x: number, y: number, width: number, height: number, fillColor: any, lineColor: any, lineWidth: number): void;\r\n    alpha(value: number): void;\r\n    _transform(mat: Matrix, pivotX: number, pivotY: number): void;\r\n    _rotate(angle: number, pivotX: number, pivotY: number): void;\r\n    _scale(scaleX: number, scaleY: number, pivotX: number, pivotY: number): void;\r\n    _drawLine(x: number, y: number, fromX: number, fromY: number, toX: number, toY: number, lineColor: string, lineWidth: number, vid: number): void;\r\n    _drawLines(x: number, y: number, points: any[], lineColor: any, lineWidth: number, vid: number): void;\r\n    drawCurves(x: number, y: number, points: any[], lineColor: any, lineWidth: number): void;\r\n    private _fillAndStroke;\r\n    static PI2: number;\r\n    _drawCircle(x: number, y: number, radius: number, fillColor: any, lineColor: any, lineWidth: number, vid: number): void;\r\n    _drawPie(x: number, y: number, radius: number, startAngle: number, endAngle: number, fillColor: any, lineColor: any, lineWidth: number, vid: number): void;\r\n    _drawPoly(x: number, y: number, points: any[], fillColor: any, lineColor: any, lineWidth: number, isConvexPolygon: boolean, vid: number): void;\r\n    _drawPath(x: number, y: number, paths: any[], brush: any, pen: any): void;\r\n    static set2DRenderConfig(): void;\r\n    _id: number;\r\n    private _other;\r\n    private _renderNextSubmitIndex;\r\n    private _path;\r\n    _drawCount: number;\r\n    private _width;\r\n    private _height;\r\n    private _renderCount;\r\n    _submits: any;\r\n    _curSubmit: any;\r\n    _submitKey: SubmitKey;\r\n    _mesh: MeshQuadTexture;\r\n    _pathMesh: MeshVG | null;\r\n    _triangleMesh: MeshTexture | null;\r\n    meshlist: any[];\r\n    private _transedPoints;\r\n    private _temp4Points;\r\n    _clipRect: Rectangle;\r\n    _globalClipMatrix: Matrix;\r\n    _clipInCache: boolean;\r\n    _clipInfoID: number;\r\n    private _clipID_Gen;\r\n    _curMat: Matrix;\r\n    _lastMatScaleX: number;\r\n    _lastMatScaleY: number;\r\n    private _lastMat_a;\r\n    private _lastMat_b;\r\n    private _lastMat_c;\r\n    private _lastMat_d;\r\n    _nBlendType: number;\r\n    _save: any;\r\n    _targets: RenderTexture2D | null;\r\n    _charSubmitCache: CharSubmitCache | null;\r\n    _saveMark: SaveMark | null;\r\n    _shader2D: Shader2D;\r\n    sprite: Sprite | null;\r\n    static _textRender: TextRender | null;\r\n    _italicDeg: number;\r\n    _lastTex: Texture | null;\r\n    private _fillColor;\r\n    private _flushCnt;\r\n    private defTexture;\r\n    _colorFiler: ColorFilter | null;\r\n    drawTexAlign: boolean;\r\n    _incache: boolean;\r\n    isMain: boolean;\r\n    constructor();\r\n    clearBG(r: number, g: number, b: number, a: number): void;\r\n    _getSubmits(): any[];\r\n    private _releaseMem;\r\n    destroy(keepRT?: boolean): void;\r\n    clear(): void;\r\n    size(w: number, h: number): void;\r\n    asBitmap: boolean;\r\n    getMatScaleX(): number;\r\n    getMatScaleY(): number;\r\n    setFillColor(color: number): void;\r\n    getFillColor(): number;\r\n    fillStyle: any;\r\n    globalAlpha: number;\r\n    textAlign: string;\r\n    textBaseline: string;\r\n    globalCompositeOperation: string;\r\n    strokeStyle: any;\r\n    translate(x: number, y: number): void;\r\n    lineWidth: number;\r\n    save(): void;\r\n    restore(): void;\r\n    font: string;\r\n    fillText(txt: string | WordText, x: number, y: number, fontStr: string, color: string, align: string, lineWidth?: number, borderColor?: string): void;\r\n    drawText(text: string | WordText, x: number, y: number, font: string, color: string, textAlign: string): void;\r\n    fillWords(words: HTMLChar[], x: number, y: number, fontStr: string, color: string): void;\r\n    strokeWord(text: string | WordText, x: number, y: number, font: string, color: string, lineWidth: number, textAlign: string): void;\r\n    fillBorderText(txt: string | WordText, x: number, y: number, font: string, color: string, borderColor: string, lineWidth: number, textAlign: string): void;\r\n    fillBorderWords(words: HTMLChar[], x: number, y: number, font: string, color: string, borderColor: string, lineWidth: number): void;\r\n    _fast_filltext(data: string | WordText, x: number, y: number, fontObj: any, color: string, strokeColor: string | null, lineWidth: number, textAlign: number, underLine?: number): void;\r\n    private _fillRect;\r\n    fillRect(x: number, y: number, width: number, height: number, fillStyle: any): void;\r\n    fillTexture(texture: Texture, x: number, y: number, width: number, height: number, type: string, offset: Point, other: any): void;\r\n    _fillTexture(texture: Texture, texw: number, texh: number, texuvRect: any[], x: number, y: number, width: number, height: number, type: string, offsetx: number, offsety: number): void;\r\n    setColorFilter(filter: ColorFilter): void;\r\n    drawTexture(tex: Texture, x: number, y: number, width: number, height: number): void;\r\n    drawTextures(tex: Texture, pos: any[], tx: number, ty: number): void;\r\n    private _drawTextureAddSubmit;\r\n    _drawTextureM(tex: Texture, x: number, y: number, width: number, height: number, m: Matrix, alpha: number, uv: any[] | null): boolean;\r\n    _drawRenderTexture(tex: RenderTexture2D, x: number, y: number, width: number, height: number, m: Matrix, alpha: number, uv: any[]): boolean;\r\n    submitDebugger(): void;\r\n    _copyClipInfo(submit: SubmitBase, clipInfo: Matrix): void;\r\n    private isSameClipInfo;\r\n    _useNewTex2DSubmit(tex: Texture, minVertNum: number): void;\r\n    _drawTexRect(x: number, y: number, w: number, h: number, uv: any[]): void;\r\n    drawCallOptimize(enable: boolean): boolean;\r\n    _inner_drawTexture(tex: Texture, imgid: number, x: number, y: number, width: number, height: number, m: Matrix, uv: ArrayLike<number> | null, alpha: number, lastRender: boolean): boolean;\r\n    transform4Points(a: any[], m: Matrix, out: any[]): void;\r\n    clipedOff(pt: any[]): boolean;\r\n    transformQuad(x: number, y: number, w: number, h: number, italicDeg: number, m: Matrix, out: any[]): void;\r\n    pushRT(): void;\r\n    popRT(): void;\r\n    useRT(rt: RenderTexture2D): void;\r\n    RTRestore(rt: RenderTexture2D): void;\r\n    breakNextMerge(): void;\r\n    private _repaintSprite;\r\n    drawTextureWithTransform(tex: Texture, x: number, y: number, width: number, height: number, transform: Matrix | null, tx: number, ty: number, alpha: number, blendMode: string | null, colorfilter?: ColorFilter | null, uv?: number[]): void;\r\n    private _flushToTarget;\r\n    drawCanvas(canvas: HTMLCanvas, x: number, y: number, width: number, height: number): void;\r\n    drawTarget(rt: RenderTexture2D, x: number, y: number, width: number, height: number, m: Matrix, shaderValue: Value2D, uv?: ArrayLike<number> | null, blend?: number): boolean;\r\n    drawTriangles(tex: Texture, x: number, y: number, vertices: Float32Array, uvs: Float32Array, indices: Uint16Array, matrix: Matrix, alpha: number, color: ColorFilter, blendMode: string, colorNum?: number): void;\r\n    transform(a: number, b: number, c: number, d: number, tx: number, ty: number): void;\r\n    _transformByMatrix(matrix: Matrix, tx: number, ty: number): void;\r\n    setTransformByMatrix(value: Matrix): void;\r\n    rotate(angle: number): void;\r\n    scale(scaleX: number, scaleY: number): void;\r\n    clipRect(x: number, y: number, width: number, height: number): void;\r\n    drawMesh(x: number, y: number, ib: IndexBuffer2D, vb: VertexBuffer2D, numElement: number, mat: Matrix, shader: Shader, shaderValues: Value2D, startIndex?: number): void;\r\n    addRenderObject(o: ISubmit): void;\r\n    submitElement(start: number, end: number): number;\r\n    flush(): number;\r\n    beginPath(convex?: boolean): void;\r\n    closePath(): void;\r\n    addPath(points: any[], close: boolean, convex: boolean, dx: number, dy: number): void;\r\n    fill(): void;\r\n    private addVGSubmit;\r\n    stroke(): void;\r\n    moveTo(x: number, y: number): void;\r\n    lineTo(x: number, y: number): void;\r\n    arcTo(x1: number, y1: number, x2: number, y2: number, r: number): void;\r\n    arc(cx: number, cy: number, r: number, startAngle: number, endAngle: number, counterclockwise?: boolean, b?: boolean): void;\r\n    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;\r\n    mixRGBandAlpha(color: number): number;\r\n    _mixRGBandAlpha(color: number, alpha: number): number;\r\n    strokeRect(x: number, y: number, width: number, height: number, parameterLineWidth: number): void;\r\n    clip(): void;\r\n    drawParticle(x: number, y: number, pt: any): void;\r\n    private _getPath;\r\n    readonly canvas: HTMLCanvas;\r\n    private static tmpuv1;\r\n    private _fillTexture_h;\r\n    private _fillTexture_v;\r\n    private static tmpUV;\r\n    private static tmpUVRect;\r\n    drawTextureWithSizeGrid(tex: Texture, tx: number, ty: number, width: number, height: number, sizeGrid: any[], gx: number, gy: number): void;\r\n}\r\n"
  }
}

{
  "code": "import { Matrix } from \"../../maths/Matrix\";\r\nexport class PathConstraint {\r\n    constructor(data, bones) {\r\n        this._debugKey = false;\r\n        this._segments = [];\r\n        this._curves = [];\r\n        this.data = data;\r\n        this.position = data.position;\r\n        this.spacing = data.spacing;\r\n        this.rotateMix = data.rotateMix;\r\n        this.translateMix = data.translateMix;\r\n        this.bones = [];\r\n        var tBoneIds = this.data.bones;\r\n        for (var i = 0, n = tBoneIds.length; i < n; i++) {\r\n            this.bones.push(bones[tBoneIds[i]]);\r\n        }\r\n    }\r\n    apply(boneList, graphics) {\r\n        if (!this.target)\r\n            return;\r\n        var tTranslateMix = this.translateMix;\r\n        var tRotateMix = this.translateMix;\r\n        var tTranslate = tTranslateMix > 0;\r\n        var tRotate = tRotateMix > 0;\r\n        var tSpacingMode = this.data.spacingMode;\r\n        var tLengthSpacing = tSpacingMode == \"length\";\r\n        var tRotateMode = this.data.rotateMode;\r\n        var tTangents = tRotateMode == \"tangent\";\r\n        var tScale = tRotateMode == \"chainScale\";\r\n        var lengths = [];\r\n        var boneCount = this.bones.length;\r\n        var spacesCount = tTangents ? boneCount : boneCount + 1;\r\n        var spaces = [];\r\n        this._spaces = spaces;\r\n        spaces[0] = this.position;\r\n        var spacing = this.spacing;\r\n        if (tScale || tLengthSpacing) {\r\n            for (var i = 0, n = spacesCount - 1; i < n;) {\r\n                var bone = this.bones[i];\r\n                var length = bone.length;\r\n                var x = length * bone.resultMatrix.a;\r\n                var y = length * bone.resultMatrix.b;\r\n                length = Math.sqrt(x * x + y * y);\r\n                if (tScale)\r\n                    lengths[i] = length;\r\n                spaces[++i] = tLengthSpacing ? Math.max(0, length + spacing) : spacing;\r\n            }\r\n        }\r\n        else {\r\n            for (i = 1; i < spacesCount; i++) {\r\n                spaces[i] = spacing;\r\n            }\r\n        }\r\n        var positions = this.computeWorldPositions(this.target, boneList, graphics, spacesCount, tTangents, this.data.positionMode == \"percent\", tSpacingMode == \"percent\");\r\n        if (this._debugKey) {\r\n            for (i = 0; i < positions.length; i++) {\r\n                graphics.drawCircle(positions[i++], positions[i++], 5, \"#00ff00\");\r\n            }\r\n            var tLinePos = [];\r\n            for (i = 0; i < positions.length; i++) {\r\n                tLinePos.push(positions[i++], positions[i++]);\r\n            }\r\n            graphics.drawLines(0, 0, tLinePos, \"#ff0000\");\r\n        }\r\n        var skeletonX;\r\n        var skeletonY;\r\n        var boneX = positions[0];\r\n        var boneY = positions[1];\r\n        var offsetRotation = this.data.offsetRotation;\r\n        var tip = tRotateMode == \"chain\" && offsetRotation == 0;\r\n        var p;\r\n        for (i = 0, p = 3; i < boneCount; i++, p += 3) {\r\n            bone = this.bones[i];\r\n            bone.resultMatrix.tx += (boneX - bone.resultMatrix.tx) * tTranslateMix;\r\n            bone.resultMatrix.ty += (boneY - bone.resultMatrix.ty) * tTranslateMix;\r\n            x = positions[p];\r\n            y = positions[p + 1];\r\n            var dx = x - boneX, dy = y - boneY;\r\n            if (tScale) {\r\n                length = lengths[i];\r\n                if (length != 0) {\r\n                    var s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * tRotateMix + 1;\r\n                    bone.resultMatrix.a *= s;\r\n                    bone.resultMatrix.c *= s;\r\n                }\r\n            }\r\n            boneX = x;\r\n            boneY = y;\r\n            if (tRotate) {\r\n                var a = bone.resultMatrix.a;\r\n                var b = bone.resultMatrix.c;\r\n                var c = bone.resultMatrix.b;\r\n                var d = bone.resultMatrix.d;\r\n                var r;\r\n                var cos;\r\n                var sin;\r\n                if (tTangents) {\r\n                    r = positions[p - 1];\r\n                }\r\n                else if (spaces[i + 1] == 0) {\r\n                    r = positions[p + 2];\r\n                }\r\n                else {\r\n                    r = Math.atan2(dy, dx);\r\n                }\r\n                r -= Math.atan2(c, a) - offsetRotation / 180 * Math.PI;\r\n                if (tip) {\r\n                    cos = Math.cos(r);\r\n                    sin = Math.sin(r);\r\n                    length = bone.length;\r\n                    boneX += (length * (cos * a - sin * c) - dx) * tRotateMix;\r\n                    boneY += (length * (sin * a + cos * c) - dy) * tRotateMix;\r\n                }\r\n                if (r > Math.PI) {\r\n                    r -= (Math.PI * 2);\r\n                }\r\n                else if (r < -Math.PI) {\r\n                    r += (Math.PI * 2);\r\n                }\r\n                r *= tRotateMix;\r\n                cos = Math.cos(r);\r\n                sin = Math.sin(r);\r\n                bone.resultMatrix.a = cos * a - sin * c;\r\n                bone.resultMatrix.c = cos * b - sin * d;\r\n                bone.resultMatrix.b = sin * a + cos * c;\r\n                bone.resultMatrix.d = sin * b + cos * d;\r\n            }\r\n        }\r\n    }\r\n    computeWorldVertices2(boneSlot, boneList, start, count, worldVertices, offset) {\r\n        var tBones = boneSlot.currDisplayData.bones;\r\n        var tWeights = boneSlot.currDisplayData.weights;\r\n        var tTriangles = boneSlot.currDisplayData.triangles;\r\n        var tMatrix;\r\n        var i = 0;\r\n        var v = 0;\r\n        var skip = 0;\r\n        var n = 0;\r\n        var w = 0;\r\n        var b = 0;\r\n        var wx = 0;\r\n        var wy = 0;\r\n        var vx = 0;\r\n        var vy = 0;\r\n        var bone;\r\n        var len;\r\n        if (tBones == null) {\r\n            if (!tTriangles)\r\n                tTriangles = tWeights;\r\n            if (boneSlot.deformData)\r\n                tTriangles = boneSlot.deformData;\r\n            var parentName;\r\n            parentName = boneSlot.parent;\r\n            if (boneList) {\r\n                len = boneList.length;\r\n                for (i = 0; i < len; i++) {\r\n                    if (boneList[i].name == parentName) {\r\n                        bone = boneList[i];\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            var tBoneMt;\r\n            if (bone) {\r\n                tBoneMt = bone.resultMatrix;\r\n            }\r\n            if (!tBoneMt)\r\n                tBoneMt = PathConstraint._tempMt;\r\n            var x = tBoneMt.tx;\r\n            var y = tBoneMt.ty;\r\n            var a = tBoneMt.a, bb = tBoneMt.b, c = tBoneMt.c, d = tBoneMt.d;\r\n            if (bone)\r\n                d *= bone.d;\r\n            for (v = start, w = offset; w < count; v += 2, w += 2) {\r\n                vx = tTriangles[v], vy = tTriangles[v + 1];\r\n                worldVertices[w] = vx * a + vy * bb + x;\r\n                worldVertices[w + 1] = -(vx * c + vy * d + y);\r\n            }\r\n            return;\r\n        }\r\n        for (i = 0; i < start; i += 2) {\r\n            n = tBones[v];\r\n            v += n + 1;\r\n            skip += n;\r\n        }\r\n        var skeletonBones = boneList;\r\n        for (w = offset, b = skip * 3; w < count; w += 2) {\r\n            wx = 0, wy = 0;\r\n            n = tBones[v++];\r\n            n += v;\r\n            for (; v < n; v++, b += 3) {\r\n                tMatrix = skeletonBones[tBones[v]].resultMatrix;\r\n                vx = tWeights[b];\r\n                vy = tWeights[b + 1];\r\n                var weight = tWeights[b + 2];\r\n                wx += (vx * tMatrix.a + vy * tMatrix.c + tMatrix.tx) * weight;\r\n                wy += (vx * tMatrix.b + vy * tMatrix.d + tMatrix.ty) * weight;\r\n            }\r\n            worldVertices[w] = wx;\r\n            worldVertices[w + 1] = wy;\r\n        }\r\n    }\r\n    computeWorldPositions(boneSlot, boneList, graphics, spacesCount, tangents, percentPosition, percentSpacing) {\r\n        var tBones = boneSlot.currDisplayData.bones;\r\n        var tWeights = boneSlot.currDisplayData.weights;\r\n        var tTriangles = boneSlot.currDisplayData.triangles;\r\n        var tRx = 0;\r\n        var tRy = 0;\r\n        var nn = 0;\r\n        var tMatrix;\r\n        var tX;\r\n        var tY;\r\n        var tB = 0;\r\n        var tWeight = 0;\r\n        var tVertices = [];\r\n        var i = 0, j = 0, n = 0;\r\n        var verticesLength = boneSlot.currDisplayData.verLen;\r\n        var target = boneSlot;\r\n        var position = this.position;\r\n        var spaces = this._spaces;\r\n        var world = [];\r\n        var out = [];\r\n        var closed = false;\r\n        var curveCount = verticesLength / 6;\r\n        var prevCurve = -1;\r\n        var pathLength;\r\n        var o, curve;\r\n        var p;\r\n        var space;\r\n        var prev;\r\n        var length;\r\n        if (!true) {\r\n            var lengths = boneSlot.currDisplayData.lengths;\r\n            curveCount -= closed ? 1 : 2;\r\n            pathLength = lengths[curveCount];\r\n            if (percentPosition)\r\n                position *= pathLength;\r\n            if (percentSpacing) {\r\n                for (i = 0; i < spacesCount; i++)\r\n                    spaces[i] *= pathLength;\r\n            }\r\n            world.length = 8;\r\n            for (i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\r\n                space = spaces[i];\r\n                position += space;\r\n                p = position;\r\n                if (closed) {\r\n                    p %= pathLength;\r\n                    if (p < 0)\r\n                        p += pathLength;\r\n                    curve = 0;\r\n                }\r\n                else if (p < 0) {\r\n                    if (prevCurve != PathConstraint.BEFORE) {\r\n                        prevCurve = PathConstraint.BEFORE;\r\n                        this.computeWorldVertices2(target, boneList, 2, 4, world, 0);\r\n                    }\r\n                    this.addBeforePosition(p, world, 0, out, o);\r\n                    continue;\r\n                }\r\n                else if (p > pathLength) {\r\n                    if (prevCurve != PathConstraint.AFTER) {\r\n                        prevCurve = PathConstraint.AFTER;\r\n                        this.computeWorldVertices2(target, boneList, verticesLength - 6, 4, world, 0);\r\n                    }\r\n                    this.addAfterPosition(p - pathLength, world, 0, out, o);\r\n                    continue;\r\n                }\r\n                for (;; curve++) {\r\n                    length = lengths[curve];\r\n                    if (p > length)\r\n                        continue;\r\n                    if (curve == 0)\r\n                        p /= length;\r\n                    else {\r\n                        prev = lengths[curve - 1];\r\n                        p = (p - prev) / (length - prev);\r\n                    }\r\n                    break;\r\n                }\r\n                if (curve != prevCurve) {\r\n                    prevCurve = curve;\r\n                    if (closed && curve == curveCount) {\r\n                        this.computeWorldVertices2(target, boneList, verticesLength - 4, 4, world, 0);\r\n                        this.computeWorldVertices2(target, boneList, 0, 4, world, 4);\r\n                    }\r\n                    else\r\n                        this.computeWorldVertices2(target, boneList, curve * 6 + 2, 8, world, 0);\r\n                }\r\n                this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || (i > 0 && space == 0));\r\n            }\r\n            return out;\r\n        }\r\n        if (closed) {\r\n            verticesLength += 2;\r\n            world[verticesLength - 2] = world[0];\r\n            world[verticesLength - 1] = world[1];\r\n        }\r\n        else {\r\n            curveCount--;\r\n            verticesLength -= 4;\r\n            this.computeWorldVertices2(boneSlot, boneList, 2, verticesLength, tVertices, 0);\r\n            if (this._debugKey) {\r\n                for (i = 0; i < tVertices.length;) {\r\n                    graphics.drawCircle(tVertices[i++], tVertices[i++], 10, \"#ff0000\");\r\n                }\r\n            }\r\n            world = tVertices;\r\n        }\r\n        this._curves.length = curveCount;\r\n        var curves = this._curves;\r\n        pathLength = 0;\r\n        var x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;\r\n        var tmpx, tmpy, dddfx, dddfy, ddfx, ddfy, dfx, dfy;\r\n        var w;\r\n        for (i = 0, w = 2; i < curveCount; i++, w += 6) {\r\n            cx1 = world[w];\r\n            cy1 = world[w + 1];\r\n            cx2 = world[w + 2];\r\n            cy2 = world[w + 3];\r\n            x2 = world[w + 4];\r\n            y2 = world[w + 5];\r\n            tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\r\n            tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\r\n            dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\r\n            dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\r\n            ddfx = tmpx * 2 + dddfx;\r\n            ddfy = tmpy * 2 + dddfy;\r\n            dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\r\n            dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            ddfx += dddfx;\r\n            ddfy += dddfy;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            dfx += ddfx + dddfx;\r\n            dfy += ddfy + dddfy;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            curves[i] = pathLength;\r\n            x1 = x2;\r\n            y1 = y2;\r\n        }\r\n        if (percentPosition)\r\n            position *= pathLength;\r\n        if (percentSpacing) {\r\n            for (i = 0; i < spacesCount; i++)\r\n                spaces[i] *= pathLength;\r\n        }\r\n        var segments = this._segments;\r\n        var curveLength = 0;\r\n        var segment;\r\n        for (i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\r\n            space = spaces[i];\r\n            position += space;\r\n            p = position;\r\n            if (closed) {\r\n                p %= pathLength;\r\n                if (p < 0)\r\n                    p += pathLength;\r\n                curve = 0;\r\n            }\r\n            else if (p < 0) {\r\n                this.addBeforePosition(p, world, 0, out, o);\r\n                continue;\r\n            }\r\n            else if (p > pathLength) {\r\n                this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\r\n                continue;\r\n            }\r\n            for (;; curve++) {\r\n                length = curves[curve];\r\n                if (p > length)\r\n                    continue;\r\n                if (curve == 0)\r\n                    p /= length;\r\n                else {\r\n                    prev = curves[curve - 1];\r\n                    p = (p - prev) / (length - prev);\r\n                }\r\n                break;\r\n            }\r\n            if (curve != prevCurve) {\r\n                prevCurve = curve;\r\n                var ii = curve * 6;\r\n                x1 = world[ii];\r\n                y1 = world[ii + 1];\r\n                cx1 = world[ii + 2];\r\n                cy1 = world[ii + 3];\r\n                cx2 = world[ii + 4];\r\n                cy2 = world[ii + 5];\r\n                x2 = world[ii + 6];\r\n                y2 = world[ii + 7];\r\n                tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\r\n                tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\r\n                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\r\n                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\r\n                ddfx = tmpx * 2 + dddfx;\r\n                ddfy = tmpy * 2 + dddfy;\r\n                dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\r\n                dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\r\n                curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\r\n                segments[0] = curveLength;\r\n                for (ii = 1; ii < 8; ii++) {\r\n                    dfx += ddfx;\r\n                    dfy += ddfy;\r\n                    ddfx += dddfx;\r\n                    ddfy += dddfy;\r\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                    segments[ii] = curveLength;\r\n                }\r\n                dfx += ddfx;\r\n                dfy += ddfy;\r\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                segments[8] = curveLength;\r\n                dfx += ddfx + dddfx;\r\n                dfy += ddfy + dddfy;\r\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                segments[9] = curveLength;\r\n                segment = 0;\r\n            }\r\n            p *= curveLength;\r\n            for (;; segment++) {\r\n                length = segments[segment];\r\n                if (p > length)\r\n                    continue;\r\n                if (segment == 0)\r\n                    p /= length;\r\n                else {\r\n                    prev = segments[segment - 1];\r\n                    p = segment + (p - prev) / (length - prev);\r\n                }\r\n                break;\r\n            }\r\n            this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\r\n        }\r\n        return out;\r\n    }\r\n    addBeforePosition(p, temp, i, out, o) {\r\n        var x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);\r\n        out[o] = x1 + p * Math.cos(r);\r\n        out[o + 1] = y1 + p * Math.sin(r);\r\n        out[o + 2] = r;\r\n    }\r\n    addAfterPosition(p, temp, i, out, o) {\r\n        var x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);\r\n        out[o] = x1 + p * Math.cos(r);\r\n        out[o + 1] = y1 + p * Math.sin(r);\r\n        out[o + 2] = r;\r\n    }\r\n    addCurvePosition(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {\r\n        if (p == 0)\r\n            p = 0.0001;\r\n        var tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;\r\n        var ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;\r\n        var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\r\n        out[o] = x;\r\n        out[o + 1] = y;\r\n        if (tangents) {\r\n            out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\r\n        }\r\n        else {\r\n            out[o + 2] = 0;\r\n        }\r\n    }\r\n}\r\nPathConstraint.BEFORE = -2;\r\nPathConstraint.AFTER = -3;\r\nPathConstraint._tempMt = new Matrix();\r\n",
  "references": [
    "F:/ProjectsWorks/font_game_2.10/libs/laya/ani/bone/BoneSlot.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/ani/bone/PathConstraintData.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/ani/bone/Bone.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/display/Graphics.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/maths/Matrix.ts"
  ],
  "dts": {
    "name": "F:/ProjectsWorks/font_game_2.10/libs/laya/ani/bone/PathConstraint.d.ts",
    "writeByteOrderMark": false,
    "text": "import { BoneSlot } from \"./BoneSlot\";\r\nimport { PathConstraintData } from \"./PathConstraintData\";\r\nimport { Bone } from \"./Bone\";\r\nimport { Graphics } from \"../../display/Graphics\";\r\nexport declare class PathConstraint {\r\n    private static BEFORE;\r\n    private static AFTER;\r\n    target: BoneSlot;\r\n    data: PathConstraintData;\r\n    bones: Bone[];\r\n    position: number;\r\n    spacing: number;\r\n    rotateMix: number;\r\n    translateMix: number;\r\n    private _debugKey;\r\n    private _segments;\r\n    private _curves;\r\n    private _spaces;\r\n    constructor(data: PathConstraintData, bones: Bone[]);\r\n    apply(boneList: Bone[], graphics: Graphics): void;\r\n    private static _tempMt;\r\n    computeWorldVertices2(boneSlot: BoneSlot, boneList: Bone[], start: number, count: number, worldVertices: number[], offset: number): void;\r\n    private computeWorldPositions;\r\n    private addBeforePosition;\r\n    private addAfterPosition;\r\n    private addCurvePosition;\r\n}\r\n"
  }
}

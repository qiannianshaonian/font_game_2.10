{
  "code": "import { Event } from \"../events/Event\";\r\nimport { EventDispatcher } from \"../events/EventDispatcher\";\r\nimport { Rectangle } from \"../maths/Rectangle\";\r\nimport { Handler } from \"../utils/Handler\";\r\nimport { ILaya } from \"../../ILaya\";\r\nexport class Texture extends EventDispatcher {\r\n    constructor(bitmap = null, uv = null, sourceWidth = 0, sourceHeight = 0) {\r\n        super();\r\n        this.uvrect = [0, 0, 1, 1];\r\n        this._destroyed = false;\r\n        this._referenceCount = 0;\r\n        this.$_GID = 0;\r\n        this.offsetX = 0;\r\n        this.offsetY = 0;\r\n        this._w = 0;\r\n        this._h = 0;\r\n        this.sourceWidth = 0;\r\n        this.sourceHeight = 0;\r\n        this.url = null;\r\n        this.scaleRate = 1;\r\n        this.setTo(bitmap, uv, sourceWidth, sourceHeight);\r\n    }\r\n    static moveUV(offsetX, offsetY, uv) {\r\n        for (var i = 0; i < 8; i += 2) {\r\n            uv[i] += offsetX;\r\n            uv[i + 1] += offsetY;\r\n        }\r\n        return uv;\r\n    }\r\n    static create(source, x, y, width, height, offsetX = 0, offsetY = 0, sourceWidth = 0, sourceHeight = 0) {\r\n        return Texture._create(source, x, y, width, height, offsetX, offsetY, sourceWidth, sourceHeight);\r\n    }\r\n    static _create(source, x, y, width, height, offsetX = 0, offsetY = 0, sourceWidth = 0, sourceHeight = 0, outTexture = null) {\r\n        var btex = source instanceof Texture;\r\n        var uv = btex ? source.uv : Texture.DEF_UV;\r\n        var bitmap = btex ? source.bitmap : source;\r\n        if (bitmap.width && (x + width) > bitmap.width)\r\n            width = bitmap.width - x;\r\n        if (bitmap.height && (y + height) > bitmap.height)\r\n            height = bitmap.height - y;\r\n        var tex;\r\n        if (outTexture) {\r\n            tex = outTexture;\r\n            tex.setTo(bitmap, null, sourceWidth || width, sourceHeight || height);\r\n        }\r\n        else {\r\n            tex = new Texture(bitmap, null, sourceWidth || width, sourceHeight || height);\r\n        }\r\n        tex.width = width;\r\n        tex.height = height;\r\n        tex.offsetX = offsetX;\r\n        tex.offsetY = offsetY;\r\n        var dwidth = 1 / bitmap.width;\r\n        var dheight = 1 / bitmap.height;\r\n        x *= dwidth;\r\n        y *= dheight;\r\n        width *= dwidth;\r\n        height *= dheight;\r\n        var u1 = tex.uv[0], v1 = tex.uv[1], u2 = tex.uv[4], v2 = tex.uv[5];\r\n        var inAltasUVWidth = (u2 - u1), inAltasUVHeight = (v2 - v1);\r\n        var oriUV = Texture.moveUV(uv[0], uv[1], [x, y, x + width, y, x + width, y + height, x, y + height]);\r\n        tex.uv = new Float32Array([u1 + oriUV[0] * inAltasUVWidth, v1 + oriUV[1] * inAltasUVHeight,\r\n            u2 - (1 - oriUV[2]) * inAltasUVWidth, v1 + oriUV[3] * inAltasUVHeight,\r\n            u2 - (1 - oriUV[4]) * inAltasUVWidth, v2 - (1 - oriUV[5]) * inAltasUVHeight,\r\n            u1 + oriUV[6] * inAltasUVWidth, v2 - (1 - oriUV[7]) * inAltasUVHeight]);\r\n        var bitmapScale = bitmap.scaleRate;\r\n        if (bitmapScale && bitmapScale != 1) {\r\n            tex.sourceWidth /= bitmapScale;\r\n            tex.sourceHeight /= bitmapScale;\r\n            tex.width /= bitmapScale;\r\n            tex.height /= bitmapScale;\r\n            tex.scaleRate = bitmapScale;\r\n        }\r\n        else {\r\n            tex.scaleRate = 1;\r\n        }\r\n        return tex;\r\n    }\r\n    static createFromTexture(texture, x, y, width, height) {\r\n        var texScaleRate = texture.scaleRate;\r\n        if (texScaleRate != 1) {\r\n            x *= texScaleRate;\r\n            y *= texScaleRate;\r\n            width *= texScaleRate;\r\n            height *= texScaleRate;\r\n        }\r\n        var rect = Rectangle.TEMP.setTo(x - texture.offsetX, y - texture.offsetY, width, height);\r\n        var result = rect.intersection(Texture._rect1.setTo(0, 0, texture.width, texture.height), Texture._rect2);\r\n        if (result)\r\n            var tex = Texture.create(texture, result.x, result.y, result.width, result.height, result.x - rect.x, result.y - rect.y, width, height);\r\n        else\r\n            return null;\r\n        return tex;\r\n    }\r\n    get uv() {\r\n        return this._uv;\r\n    }\r\n    set uv(value) {\r\n        this.uvrect[0] = Math.min(value[0], value[2], value[4], value[6]);\r\n        this.uvrect[1] = Math.min(value[1], value[3], value[5], value[7]);\r\n        this.uvrect[2] = Math.max(value[0], value[2], value[4], value[6]) - this.uvrect[0];\r\n        this.uvrect[3] = Math.max(value[1], value[3], value[5], value[7]) - this.uvrect[1];\r\n        this._uv = value;\r\n    }\r\n    get width() {\r\n        if (this._w)\r\n            return this._w;\r\n        if (!this.bitmap)\r\n            return 0;\r\n        return (this.uv && this.uv !== Texture.DEF_UV) ? (this.uv[2] - this.uv[0]) * this.bitmap.width : this.bitmap.width;\r\n    }\r\n    set width(value) {\r\n        this._w = value;\r\n        this.sourceWidth || (this.sourceWidth = value);\r\n    }\r\n    get height() {\r\n        if (this._h)\r\n            return this._h;\r\n        if (!this.bitmap)\r\n            return 0;\r\n        return (this.uv && this.uv !== Texture.DEF_UV) ? (this.uv[5] - this.uv[1]) * this.bitmap.height : this.bitmap.height;\r\n    }\r\n    set height(value) {\r\n        this._h = value;\r\n        this.sourceHeight || (this.sourceHeight = value);\r\n    }\r\n    get bitmap() {\r\n        return this._bitmap;\r\n    }\r\n    set bitmap(value) {\r\n        this._bitmap && this._bitmap._removeReference(this._referenceCount);\r\n        this._bitmap = value;\r\n        value && (value._addReference(this._referenceCount));\r\n    }\r\n    get destroyed() {\r\n        return this._destroyed;\r\n    }\r\n    _addReference() {\r\n        this._bitmap && this._bitmap._addReference();\r\n        this._referenceCount++;\r\n    }\r\n    _removeReference() {\r\n        this._bitmap && this._bitmap._removeReference();\r\n        this._referenceCount--;\r\n    }\r\n    _getSource(cb = null) {\r\n        if (this._destroyed || !this._bitmap)\r\n            return null;\r\n        this.recoverBitmap(cb);\r\n        return this._bitmap.destroyed ? null : this.bitmap._getSource();\r\n    }\r\n    _onLoaded(complete, context) {\r\n        if (!context) {\r\n        }\r\n        else if (context == this) {\r\n        }\r\n        else if (context instanceof Texture) {\r\n            var tex = context;\r\n            Texture._create(context, 0, 0, tex.width, tex.height, 0, 0, tex.sourceWidth, tex.sourceHeight, this);\r\n        }\r\n        else {\r\n            this.bitmap = context;\r\n            this.sourceWidth = this._w = context.width;\r\n            this.sourceHeight = this._h = context.height;\r\n        }\r\n        complete && complete.run();\r\n        this.event(Event.READY, this);\r\n    }\r\n    getIsReady() {\r\n        return this._destroyed ? false : (this._bitmap ? true : false);\r\n    }\r\n    setTo(bitmap = null, uv = null, sourceWidth = 0, sourceHeight = 0) {\r\n        this.bitmap = bitmap;\r\n        this.sourceWidth = sourceWidth;\r\n        this.sourceHeight = sourceHeight;\r\n        if (bitmap) {\r\n            this._w = bitmap.width;\r\n            this._h = bitmap.height;\r\n            this.sourceWidth = this.sourceWidth || bitmap.width;\r\n            this.sourceHeight = this.sourceHeight || bitmap.height;\r\n        }\r\n        this.uv = uv || Texture.DEF_UV;\r\n    }\r\n    load(url, complete = null) {\r\n        if (!this._destroyed)\r\n            ILaya.loader.load(url, Handler.create(this, this._onLoaded, [complete]), null, \"htmlimage\", 1, true);\r\n    }\r\n    getTexturePixels(x, y, width, height) {\r\n        var st, dst, i;\r\n        var tex2d = this.bitmap;\r\n        var texw = this._w;\r\n        var texh = this._h;\r\n        var sourceWidth = this.sourceWidth;\r\n        var sourceHeight = this.sourceHeight;\r\n        var tex2dw = tex2d.width;\r\n        var tex2dh = tex2d.height;\r\n        var offsetX = this.offsetX;\r\n        var offsetY = this.offsetY;\r\n        let draww = width;\r\n        let drawh = height;\r\n        if (x + width > texw + offsetX)\r\n            draww -= (x + width) - texw - offsetX;\r\n        if (x + width > sourceWidth)\r\n            width -= (x + width) - sourceWidth;\r\n        if (y + height > texh + offsetY)\r\n            drawh -= (y + height) - texh - offsetY;\r\n        if (y + height > sourceHeight)\r\n            height -= (y + height) - sourceHeight;\r\n        if (width <= 0 || height <= 0)\r\n            return null;\r\n        let marginL = offsetX > x ? offsetX - x : 0;\r\n        let marginT = offsetY > y ? offsetY - y : 0;\r\n        let rePosX = x > offsetX ? x - offsetX : 0;\r\n        let rePosY = y > offsetY ? y - offsetY : 0;\r\n        draww -= marginL;\r\n        drawh -= marginT;\r\n        var wstride = width * 4;\r\n        var pix = null;\r\n        try {\r\n            pix = tex2d.getPixels();\r\n        }\r\n        catch (e) {\r\n        }\r\n        if (pix) {\r\n            if (x == 0 && y == 0 && width == tex2dw && height == tex2dh)\r\n                return pix;\r\n            let uv = this._uv.slice();\r\n            let atlasPosX = Math.round(uv[0] * tex2dw);\r\n            let atlasPosY = Math.round(uv[1] * tex2dh);\r\n            var ret = new Uint8Array(width * height * 4);\r\n            wstride = tex2dw * 4;\r\n            dst = (atlasPosY + rePosY) * wstride;\r\n            st = atlasPosX * 4 + rePosX * 4 + dst;\r\n            for (i = 0; i < drawh; i++) {\r\n                ret.set(pix.slice(st, st + draww * 4), width * 4 * (i + marginT) + marginL * 4);\r\n                st += wstride;\r\n            }\r\n            return ret;\r\n        }\r\n        var ctx = new ILaya.Context();\r\n        ctx.size(width, height);\r\n        ctx.asBitmap = true;\r\n        var uv = null;\r\n        if (x != 0 || y != 0 || width != tex2dw || height != tex2dh) {\r\n            uv = this._uv.slice();\r\n            var stu = uv[0];\r\n            var stv = uv[1];\r\n            var uvw = uv[2] - stu;\r\n            var uvh = uv[7] - stv;\r\n            var uk = uvw / texw;\r\n            var vk = uvh / texh;\r\n            uv = [stu + rePosX * uk, stv + rePosY * vk,\r\n                stu + (rePosX + draww) * uk, stv + rePosY * vk,\r\n                stu + (rePosX + draww) * uk, stv + (rePosY + drawh) * vk,\r\n                stu + rePosX * uk, stv + (rePosY + drawh) * vk];\r\n        }\r\n        ctx._drawTextureM(this, marginL, marginT, draww, drawh, null, 1.0, uv);\r\n        ctx._targets.start();\r\n        ctx.flush();\r\n        ctx._targets.end();\r\n        ctx._targets.restore();\r\n        var dt = ctx._targets.getData(0, 0, width, height);\r\n        ctx.destroy();\r\n        ret = new Uint8Array(width * height * 4);\r\n        st = 0;\r\n        dst = (height - 1) * wstride;\r\n        for (i = height - 1; i >= 0; i--) {\r\n            ret.set(dt.slice(dst, dst + wstride), st);\r\n            st += wstride;\r\n            dst -= wstride;\r\n        }\r\n        return ret;\r\n    }\r\n    getPixels(x, y, width, height) {\r\n        if (window.conch) {\r\n            return this._nativeObj.getImageData(x, y, width, height);\r\n        }\r\n        else {\r\n            return this.getTexturePixels(x, y, width, height);\r\n        }\r\n    }\r\n    recoverBitmap(onok = null) {\r\n        var url = this._bitmap.url;\r\n        if (!this._destroyed && (!this._bitmap || this._bitmap.destroyed) && url) {\r\n            let tex = ILaya.Loader.loadedMap[url];\r\n            if (tex) {\r\n                this.bitmap = tex;\r\n                onok && onok();\r\n            }\r\n            else {\r\n                ILaya.loader.load(url, Handler.create(this, function (bit) {\r\n                    this.bitmap = bit;\r\n                    onok && onok();\r\n                }), null, \"htmlimage\", 1, true);\r\n            }\r\n        }\r\n    }\r\n    disposeBitmap() {\r\n        if (!this._destroyed && this._bitmap) {\r\n            this._bitmap.destroy();\r\n        }\r\n    }\r\n    destroy(force = false) {\r\n        if (!this._destroyed) {\r\n            this._destroyed = true;\r\n            var bit = this._bitmap;\r\n            if (bit) {\r\n                bit._removeReference(this._referenceCount);\r\n                if (bit.referenceCount === 0 || force)\r\n                    bit.destroy();\r\n                bit = null;\r\n            }\r\n            if (this.url && this === ILaya.loader.getRes(this.url))\r\n                ILaya.Loader.clearRes(this.url);\r\n        }\r\n    }\r\n}\r\nTexture.DEF_UV = new Float32Array([0, 0, 1.0, 0, 1.0, 1.0, 0, 1.0]);\r\nTexture.NO_UV = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0]);\r\nTexture.INV_UV = new Float32Array([0, 1, 1.0, 1, 1.0, 0.0, 0, 0.0]);\r\nTexture._rect1 = new Rectangle();\r\nTexture._rect2 = new Rectangle();\r\n",
  "references": [
    "F:/ProjectsWorks/font_game_2.10/libs/laya/resource/Texture2D.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/events/Event.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/events/EventDispatcher.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/maths/Rectangle.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/utils/Handler.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/net/LoaderManager.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/ILaya.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/laya/d3/resource/RenderTexture.ts"
  ],
  "dts": {
    "name": "F:/ProjectsWorks/font_game_2.10/libs/laya/resource/Texture.d.ts",
    "writeByteOrderMark": false,
    "text": "import { Texture2D } from \"./Texture2D\";\r\nimport { EventDispatcher } from \"../events/EventDispatcher\";\r\nimport { Handler } from \"../utils/Handler\";\r\nimport { RenderTexture } from \"../d3/resource/RenderTexture\";\r\nexport declare class Texture extends EventDispatcher {\r\n    static DEF_UV: Float32Array;\r\n    static NO_UV: Float32Array;\r\n    static INV_UV: Float32Array;\r\n    private static _rect1;\r\n    private static _rect2;\r\n    uvrect: any[];\r\n    private _destroyed;\r\n    private _bitmap;\r\n    _uv: ArrayLike<number>;\r\n    private _referenceCount;\r\n    _nativeObj: any;\r\n    $_GID: number;\r\n    offsetX: number;\r\n    offsetY: number;\r\n    private _w;\r\n    private _h;\r\n    sourceWidth: number;\r\n    sourceHeight: number;\r\n    url: string;\r\n    scaleRate: number;\r\n    static moveUV(offsetX: number, offsetY: number, uv: any[]): any[];\r\n    static create(source: Texture2D | Texture, x: number, y: number, width: number, height: number, offsetX?: number, offsetY?: number, sourceWidth?: number, sourceHeight?: number): Texture;\r\n    static _create(source: Texture2D | Texture | RenderTexture, x: number, y: number, width: number, height: number, offsetX?: number, offsetY?: number, sourceWidth?: number, sourceHeight?: number, outTexture?: Texture): Texture;\r\n    static createFromTexture(texture: Texture, x: number, y: number, width: number, height: number): Texture;\r\n    uv: ArrayLike<number>;\r\n    width: number;\r\n    height: number;\r\n    bitmap: Texture2D | Texture | RenderTexture;\r\n    readonly destroyed: boolean;\r\n    constructor(bitmap?: Texture2D | Texture | RenderTexture, uv?: ArrayLike<number>, sourceWidth?: number, sourceHeight?: number);\r\n    _addReference(): void;\r\n    _removeReference(): void;\r\n    _getSource(cb?: Function): any;\r\n    private _onLoaded;\r\n    getIsReady(): boolean;\r\n    setTo(bitmap?: Texture2D | Texture | RenderTexture, uv?: ArrayLike<number>, sourceWidth?: number, sourceHeight?: number): void;\r\n    load(url: string, complete?: Handler): void;\r\n    getTexturePixels(x: number, y: number, width: number, height: number): Uint8Array;\r\n    getPixels(x: number, y: number, width: number, height: number): Uint8Array;\r\n    recoverBitmap(onok?: Function): void;\r\n    disposeBitmap(): void;\r\n    destroy(force?: boolean): void;\r\n}\r\n"
  }
}

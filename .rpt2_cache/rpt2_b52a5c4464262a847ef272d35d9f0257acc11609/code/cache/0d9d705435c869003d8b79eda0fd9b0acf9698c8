{
  "code": "import { Const } from \"../Const\";\r\nimport { SpriteConst } from \"../display/SpriteConst\";\r\nimport { Filter } from \"../filters/Filter\";\r\nimport { Matrix } from \"../maths/Matrix\";\r\nimport { Rectangle } from \"../maths/Rectangle\";\r\nimport { Texture } from \"../resource/Texture\";\r\nimport { WebGLRTMgr } from \"../resource/WebGLRTMgr\";\r\nimport { Stat } from \"../utils/Stat\";\r\nimport { BlendMode } from \"../webgl/canvas/BlendMode\";\r\nimport { WebGLCacheAsNormalCanvas } from \"../webgl/canvas/WebGLCacheAsNormalCanvas\";\r\nimport { ShaderDefines2D } from \"../webgl/shader/d2/ShaderDefines2D\";\r\nimport { Value2D } from \"../webgl/shader/d2/value/Value2D\";\r\nimport { SubmitCMD } from \"../webgl/submit/SubmitCMD\";\r\nimport { WebGLContext } from \"../webgl/WebGLContext\";\r\nimport { LayaGLQuickRunner } from \"./LayaGLQuickRunner\";\r\nimport { ILaya } from \"../../ILaya\";\r\nexport class RenderSprite {\r\n    constructor(type, next) {\r\n        if (LayaGLQuickRunner.map[type]) {\r\n            this._fun = LayaGLQuickRunner.map[type];\r\n            this._next = RenderSprite.NORENDER;\r\n            return;\r\n        }\r\n        this._next = next || RenderSprite.NORENDER;\r\n        switch (type) {\r\n            case 0:\r\n                this._fun = this._no;\r\n                return;\r\n            case SpriteConst.ALPHA:\r\n                this._fun = this._alpha;\r\n                return;\r\n            case SpriteConst.TRANSFORM:\r\n                this._fun = this._transform;\r\n                return;\r\n            case SpriteConst.BLEND:\r\n                this._fun = this._blend;\r\n                return;\r\n            case SpriteConst.CANVAS:\r\n                this._fun = this._canvas;\r\n                return;\r\n            case SpriteConst.MASK:\r\n                this._fun = this._mask;\r\n                return;\r\n            case SpriteConst.CLIP:\r\n                this._fun = this._clip;\r\n                return;\r\n            case SpriteConst.STYLE:\r\n                this._fun = this._style;\r\n                return;\r\n            case SpriteConst.GRAPHICS:\r\n                this._fun = this._graphics;\r\n                return;\r\n            case SpriteConst.CHILDS:\r\n                this._fun = this._children;\r\n                return;\r\n            case SpriteConst.CUSTOM:\r\n                this._fun = this._custom;\r\n                return;\r\n            case SpriteConst.TEXTURE:\r\n                this._fun = this._texture;\r\n                return;\r\n            case SpriteConst.FILTERS:\r\n                this._fun = Filter._filter;\r\n                return;\r\n            case RenderSprite.INIT:\r\n                this._fun = RenderSprite._initRenderFun;\r\n                return;\r\n        }\r\n        this.onCreate(type);\r\n    }\r\n    static __init__() {\r\n        LayaGLQuickRunner.__init__();\r\n        var i, len;\r\n        var initRender;\r\n        initRender = new RenderSprite(RenderSprite.INIT, null);\r\n        len = RenderSprite.renders.length = SpriteConst.CHILDS * 2;\r\n        for (i = 0; i < len; i++)\r\n            RenderSprite.renders[i] = initRender;\r\n        RenderSprite.renders[0] = new RenderSprite(0, null);\r\n        function _initSame(value, o) {\r\n            var n = 0;\r\n            for (var i = 0; i < value.length; i++) {\r\n                n |= value[i];\r\n                RenderSprite.renders[n] = o;\r\n            }\r\n        }\r\n    }\r\n    static _initRenderFun(sprite, context, x, y) {\r\n        var type = sprite._renderType;\r\n        var r = RenderSprite.renders[type] = RenderSprite._getTypeRender(type);\r\n        r._fun(sprite, context, x, y);\r\n    }\r\n    static _getTypeRender(type) {\r\n        if (LayaGLQuickRunner.map[type])\r\n            return new RenderSprite(type, null);\r\n        var rst = null;\r\n        var tType = SpriteConst.CHILDS;\r\n        while (tType > 0) {\r\n            if (tType & type)\r\n                rst = new RenderSprite(tType, rst);\r\n            tType = tType >> 1;\r\n        }\r\n        return rst;\r\n    }\r\n    onCreate(type) {\r\n    }\r\n    _style(sprite, context, x, y) {\r\n        var style = sprite._style;\r\n        if (style.render != null)\r\n            style.render(sprite, context, x, y);\r\n        var next = this._next;\r\n        next._fun.call(next, sprite, context, x, y);\r\n    }\r\n    _no(sprite, context, x, y) {\r\n    }\r\n    _custom(sprite, context, x, y) {\r\n        sprite.customRender(context, x, y);\r\n        this._next._fun.call(this._next, sprite, context, 0, 0);\r\n    }\r\n    _clip(sprite, context, x, y) {\r\n        var next = this._next;\r\n        if (next == RenderSprite.NORENDER)\r\n            return;\r\n        var r = sprite._style.scrollRect;\r\n        var width = r.width;\r\n        var height = r.height;\r\n        if (width === 0 || height === 0) {\r\n            return;\r\n        }\r\n        context.save();\r\n        context.clipRect(x, y, width, height);\r\n        next._fun.call(next, sprite, context, x - r.x, y - r.y);\r\n        context.restore();\r\n    }\r\n    _texture(sprite, context, x, y) {\r\n        var tex = sprite.texture;\r\n        if (tex._getSource()) {\r\n            var width = sprite._width || tex.sourceWidth;\r\n            var height = sprite._height || tex.sourceHeight;\r\n            var wRate = width / tex.sourceWidth;\r\n            var hRate = height / tex.sourceHeight;\r\n            width = tex.width * wRate;\r\n            height = tex.height * hRate;\r\n            if (width <= 0 || height <= 0)\r\n                return;\r\n            var px = x - sprite.pivotX + tex.offsetX * wRate;\r\n            var py = y - sprite.pivotY + tex.offsetY * hRate;\r\n            context.drawTexture(tex, px, py, width, height);\r\n        }\r\n        var next = this._next;\r\n        if (next != RenderSprite.NORENDER)\r\n            next._fun.call(next, sprite, context, x, y);\r\n    }\r\n    _graphics(sprite, context, x, y) {\r\n        var style = sprite._style;\r\n        var g = sprite._graphics;\r\n        g && g._render(sprite, context, x - style.pivotX, y - style.pivotY);\r\n        var next = this._next;\r\n        if (next != RenderSprite.NORENDER)\r\n            next._fun.call(next, sprite, context, x, y);\r\n    }\r\n    _image(sprite, context, x, y) {\r\n        var style = sprite._style;\r\n        context.drawTexture2(x, y, style.pivotX, style.pivotY, sprite.transform, sprite._graphics._one);\r\n    }\r\n    _image2(sprite, context, x, y) {\r\n        var style = sprite._style;\r\n        context.drawTexture2(x, y, style.pivotX, style.pivotY, sprite.transform, sprite._graphics._one);\r\n    }\r\n    _alpha(sprite, context, x, y) {\r\n        var style = sprite._style;\r\n        var alpha;\r\n        if ((alpha = style.alpha) > 0.01 || sprite._needRepaint()) {\r\n            var temp = context.globalAlpha;\r\n            context.globalAlpha *= alpha;\r\n            var next = this._next;\r\n            next._fun.call(next, sprite, context, x, y);\r\n            context.globalAlpha = temp;\r\n        }\r\n    }\r\n    _transform(sprite, context, x, y) {\r\n        var transform = sprite.transform, _next = this._next;\r\n        var style = sprite._style;\r\n        if (transform && _next != RenderSprite.NORENDER) {\r\n            context.save();\r\n            context.transform(transform.a, transform.b, transform.c, transform.d, transform.tx + x, transform.ty + y);\r\n            _next._fun.call(_next, sprite, context, 0, 0);\r\n            context.restore();\r\n        }\r\n        else {\r\n            if (_next != RenderSprite.NORENDER)\r\n                _next._fun.call(_next, sprite, context, x, y);\r\n        }\r\n    }\r\n    _children(sprite, context, x, y) {\r\n        var style = sprite._style;\r\n        var childs = sprite._children, n = childs.length, ele;\r\n        x = x - sprite.pivotX;\r\n        y = y - sprite.pivotY;\r\n        var textLastRender = sprite._getBit(Const.DRAWCALL_OPTIMIZE) && context.drawCallOptimize(true);\r\n        if (style.viewport) {\r\n            var rect = style.viewport;\r\n            var left = rect.x;\r\n            var top = rect.y;\r\n            var right = rect.right;\r\n            var bottom = rect.bottom;\r\n            var _x, _y;\r\n            for (i = 0; i < n; ++i) {\r\n                if ((ele = childs[i])._visible && ((_x = ele._x) < right && (_x + ele.width) > left && (_y = ele._y) < bottom && (_y + ele.height) > top)) {\r\n                    ele.render(context, x, y);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (var i = 0; i < n; ++i)\r\n                (ele = childs[i])._visible && ele.render(context, x, y);\r\n        }\r\n        textLastRender && context.drawCallOptimize(false);\r\n    }\r\n    _canvas(sprite, context, x, y) {\r\n        var _cacheStyle = sprite._cacheStyle;\r\n        var _next = this._next;\r\n        if (!_cacheStyle.enableCanvasRender) {\r\n            _next._fun.call(_next, sprite, context, x, y);\r\n            return;\r\n        }\r\n        _cacheStyle.cacheAs === 'bitmap' ? (Stat.canvasBitmap++) : (Stat.canvasNormal++);\r\n        var cacheNeedRebuild = false;\r\n        var textNeedRestore = false;\r\n        if (_cacheStyle.canvas) {\r\n            var canv = _cacheStyle.canvas;\r\n            var ctx = canv.context;\r\n            var charRIs = canv.touches;\r\n            if (charRIs) {\r\n                for (var ci = 0; ci < charRIs.length; ci++) {\r\n                    if (charRIs[ci].deleted) {\r\n                        textNeedRestore = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            cacheNeedRebuild = canv.isCacheValid && !canv.isCacheValid();\r\n        }\r\n        if (sprite._needRepaint() || (!_cacheStyle.canvas) || textNeedRestore || cacheNeedRebuild || ILaya.stage.isGlobalRepaint()) {\r\n            if (_cacheStyle.cacheAs === 'normal') {\r\n                if (context._targets) {\r\n                    _next._fun.call(_next, sprite, context, x, y);\r\n                    return;\r\n                }\r\n                else {\r\n                    this._canvas_webgl_normal_repaint(sprite, context);\r\n                }\r\n            }\r\n            else {\r\n                this._canvas_repaint(sprite, context, x, y);\r\n            }\r\n        }\r\n        var tRec = _cacheStyle.cacheRect;\r\n        context.drawCanvas(_cacheStyle.canvas, x + tRec.x, y + tRec.y, tRec.width, tRec.height);\r\n    }\r\n    _canvas_repaint(sprite, context, x, y) {\r\n        var _cacheStyle = sprite._cacheStyle;\r\n        var _next = this._next;\r\n        var tx;\r\n        var canvas = _cacheStyle.canvas;\r\n        var left;\r\n        var top;\r\n        var tRec;\r\n        var tCacheType = _cacheStyle.cacheAs;\r\n        var w, h;\r\n        var scaleX, scaleY;\r\n        var scaleInfo;\r\n        scaleInfo = _cacheStyle._calculateCacheRect(sprite, tCacheType, x, y);\r\n        scaleX = scaleInfo.x;\r\n        scaleY = scaleInfo.y;\r\n        tRec = _cacheStyle.cacheRect;\r\n        w = tRec.width * scaleX;\r\n        h = tRec.height * scaleY;\r\n        left = tRec.x;\r\n        top = tRec.y;\r\n        if (tCacheType === 'bitmap' && (w > 2048 || h > 2048)) {\r\n            console.warn(\"cache bitmap size larger than 2048,cache ignored\");\r\n            _cacheStyle.releaseContext();\r\n            _next._fun.call(_next, sprite, context, x, y);\r\n            return;\r\n        }\r\n        if (!canvas) {\r\n            _cacheStyle.createContext();\r\n            canvas = _cacheStyle.canvas;\r\n        }\r\n        tx = canvas.context;\r\n        tx.sprite = sprite;\r\n        (canvas.width != w || canvas.height != h) && canvas.size(w, h);\r\n        if (tCacheType === 'bitmap')\r\n            tx.asBitmap = true;\r\n        else if (tCacheType === 'normal')\r\n            tx.asBitmap = false;\r\n        tx.clear();\r\n        if (scaleX != 1 || scaleY != 1) {\r\n            var ctx = tx;\r\n            ctx.save();\r\n            ctx.scale(scaleX, scaleY);\r\n            _next._fun.call(_next, sprite, tx, -left, -top);\r\n            ctx.restore();\r\n            sprite._applyFilters();\r\n        }\r\n        else {\r\n            ctx = tx;\r\n            _next._fun.call(_next, sprite, tx, -left, -top);\r\n            sprite._applyFilters();\r\n        }\r\n        if (_cacheStyle.staticCache)\r\n            _cacheStyle.reCache = false;\r\n        Stat.canvasReCache++;\r\n    }\r\n    _canvas_webgl_normal_repaint(sprite, context) {\r\n        var _cacheStyle = sprite._cacheStyle;\r\n        var _next = this._next;\r\n        var canvas = _cacheStyle.canvas;\r\n        var tCacheType = _cacheStyle.cacheAs;\r\n        _cacheStyle._calculateCacheRect(sprite, tCacheType, 0, 0);\r\n        if (!canvas) {\r\n            canvas = new WebGLCacheAsNormalCanvas(context, sprite);\r\n            _cacheStyle.canvas = canvas;\r\n        }\r\n        var tx = canvas.context;\r\n        canvas.startRec();\r\n        _next._fun.call(_next, sprite, tx, sprite.pivotX, sprite.pivotY);\r\n        sprite._applyFilters();\r\n        Stat.canvasReCache++;\r\n        canvas.endRec();\r\n    }\r\n    _blend(sprite, context, x, y) {\r\n        var style = sprite._style;\r\n        var next = this._next;\r\n        if (style.blendMode) {\r\n            context.save();\r\n            context.globalCompositeOperation = style.blendMode;\r\n            next._fun.call(next, sprite, context, x, y);\r\n            context.restore();\r\n        }\r\n        else {\r\n            next._fun.call(next, sprite, context, x, y);\r\n        }\r\n    }\r\n    _mask(sprite, context, x, y) {\r\n        var next = this._next;\r\n        var mask = sprite.mask;\r\n        var submitCMD;\r\n        var ctx = context;\r\n        if (mask) {\r\n            ctx.save();\r\n            var preBlendMode = ctx.globalCompositeOperation;\r\n            var tRect = new Rectangle();\r\n            tRect.copyFrom(mask.getBounds());\r\n            tRect.width = Math.round(tRect.width);\r\n            tRect.height = Math.round(tRect.height);\r\n            tRect.x = Math.round(tRect.x);\r\n            tRect.y = Math.round(tRect.y);\r\n            if (tRect.width > 0 && tRect.height > 0) {\r\n                var w = tRect.width;\r\n                var h = tRect.height;\r\n                var tmpRT = WebGLRTMgr.getRT(w, h);\r\n                ctx.breakNextMerge();\r\n                ctx.pushRT();\r\n                ctx.addRenderObject(SubmitCMD.create([ctx, tmpRT, w, h], RenderSprite.tmpTarget, this));\r\n                mask.render(ctx, -tRect.x, -tRect.y);\r\n                ctx.breakNextMerge();\r\n                ctx.popRT();\r\n                ctx.save();\r\n                let shrink = 0.1;\r\n                ctx.clipRect(x + tRect.x - sprite.getStyle().pivotX + shrink, y + tRect.y - sprite.getStyle().pivotY + shrink, w - shrink * 2, h - shrink * 2);\r\n                next._fun.call(next, sprite, ctx, x, y);\r\n                ctx.restore();\r\n                preBlendMode = ctx.globalCompositeOperation;\r\n                ctx.addRenderObject(SubmitCMD.create([\"mask\"], RenderSprite.setBlendMode, this));\r\n                var shaderValue = Value2D.create(ShaderDefines2D.TEXTURE2D, 0);\r\n                var uv = Texture.INV_UV;\r\n                ctx.drawTarget(tmpRT, x + tRect.x - sprite.getStyle().pivotX, y + tRect.y - sprite.getStyle().pivotY, w, h, Matrix.TEMP.identity(), shaderValue, uv, 6);\r\n                ctx.addRenderObject(SubmitCMD.create([tmpRT], RenderSprite.recycleTarget, this));\r\n                ctx.addRenderObject(SubmitCMD.create([preBlendMode], RenderSprite.setBlendMode, this));\r\n            }\r\n            ctx.restore();\r\n        }\r\n        else {\r\n            next._fun.call(next, sprite, context, x, y);\r\n        }\r\n    }\r\n    static tmpTarget(ctx, rt, w, h) {\r\n        rt.start();\r\n        rt.clear(0, 0, 0, 0);\r\n    }\r\n    static recycleTarget(rt) {\r\n        WebGLRTMgr.releaseRT(rt);\r\n    }\r\n    static setBlendMode(blendMode) {\r\n        var gl = WebGLContext.mainContext;\r\n        BlendMode.targetFns[BlendMode.TOINT[blendMode]](gl);\r\n    }\r\n}\r\nRenderSprite.INIT = 0x11111;\r\nRenderSprite.renders = [];\r\nRenderSprite.NORENDER = new RenderSprite(0, null);\r\nRenderSprite.tempUV = new Array(8);\r\n",
  "references": [
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/Const.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/display/css/CacheStyle.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/display/css/SpriteStyle.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/display/css/TextStyle.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/display/Graphics.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/display/Sprite.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/display/SpriteConst.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/filters/Filter.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/maths/Matrix.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/maths/Point.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/maths/Rectangle.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/resource/Context.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/resource/HTMLCanvas.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/resource/RenderTexture2D.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/resource/Texture.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/resource/WebGLRTMgr.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/utils/Stat.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/webgl/canvas/BlendMode.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/webgl/canvas/WebGLCacheAsNormalCanvas.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/webgl/shader/d2/ShaderDefines2D.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/webgl/shader/d2/value/Value2D.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/webgl/submit/SubmitCMD.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/webgl/WebGLContext.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/renders/LayaGLQuickRunner.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/ILaya.ts"
  ],
  "dts": {
    "name": "/Users/zonst/Documents/font2.0/font_game_2.10/.rpt2_cache/placeholder/laya/renders/RenderSprite.d.ts",
    "writeByteOrderMark": false,
    "text": "import { Sprite } from \"../display/Sprite\";\r\nimport { Context } from \"../resource/Context\";\r\nimport { RenderTexture2D } from \"../resource/RenderTexture2D\";\r\nexport interface _RenderFunction {\r\n    (sp: Sprite, ctx: Context, x: number, y: number): void;\r\n}\r\nexport declare class RenderSprite {\r\n    static INIT: number;\r\n    static renders: RenderSprite[];\r\n    protected static NORENDER: RenderSprite;\r\n    _next: RenderSprite;\r\n    _fun: Function;\r\n    static __init__(): void;\r\n    private static _initRenderFun;\r\n    private static _getTypeRender;\r\n    constructor(type: number, next: RenderSprite | null);\r\n    protected onCreate(type: number): void;\r\n    _style(sprite: Sprite, context: Context, x: number, y: number): void;\r\n    _no(sprite: Sprite, context: Context, x: number, y: number): void;\r\n    _custom(sprite: Sprite, context: Context, x: number, y: number): void;\r\n    _clip(sprite: Sprite, context: Context, x: number, y: number): void;\r\n    _texture(sprite: Sprite, context: Context, x: number, y: number): void;\r\n    _graphics(sprite: Sprite, context: Context, x: number, y: number): void;\r\n    _image(sprite: Sprite, context: Context, x: number, y: number): void;\r\n    _image2(sprite: Sprite, context: Context, x: number, y: number): void;\r\n    _alpha(sprite: Sprite, context: Context, x: number, y: number): void;\r\n    _transform(sprite: Sprite, context: Context, x: number, y: number): void;\r\n    _children(sprite: Sprite, context: Context, x: number, y: number): void;\r\n    _canvas(sprite: Sprite, context: Context, x: number, y: number): void;\r\n    _canvas_repaint(sprite: Sprite, context: Context, x: number, y: number): void;\r\n    _canvas_webgl_normal_repaint(sprite: Sprite, context: Context): void;\r\n    _blend(sprite: Sprite, context: Context, x: number, y: number): void;\r\n    _mask(sprite: Sprite, context: Context, x: number, y: number): void;\r\n    static tempUV: any[];\r\n    static tmpTarget(ctx: Context, rt: RenderTexture2D, w: number, h: number): void;\r\n    static recycleTarget(rt: RenderTexture2D): void;\r\n    static setBlendMode(blendMode: string): void;\r\n}\r\n"
  }
}

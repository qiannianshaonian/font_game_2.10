{
  "code": "export class BasePoly {\r\n    static createLine2(p, indices, lineWidth, indexBase, outVertex, loop) {\r\n        if (p.length < 4)\r\n            return null;\r\n        var points = BasePoly.tempData.length > (p.length + 2) ? BasePoly.tempData : new Array(p.length + 2);\r\n        points[0] = p[0];\r\n        points[1] = p[1];\r\n        var newlen = 2;\r\n        var i = 0;\r\n        var length = p.length;\r\n        for (i = 2; i < length; i += 2) {\r\n            if (Math.abs(p[i] - p[i - 2]) + Math.abs(p[i + 1] - p[i - 1]) > 0.01) {\r\n                points[newlen++] = p[i];\r\n                points[newlen++] = p[i + 1];\r\n            }\r\n        }\r\n        if (loop && Math.abs(p[0] - points[newlen - 2]) + Math.abs(p[1] - points[newlen - 1]) > 0.01) {\r\n            points[newlen++] = p[0];\r\n            points[newlen++] = p[1];\r\n        }\r\n        var result = outVertex;\r\n        length = newlen / 2;\r\n        var w = lineWidth / 2;\r\n        var px, py, p1x, p1y, p2x, p2y, p3x, p3y;\r\n        var perpx, perpy, perp2x, perp2y, perp3x, perp3y;\r\n        var a1, b1, c1, a2, b2, c2;\r\n        var denom, pdist, dist;\r\n        p1x = points[0];\r\n        p1y = points[1];\r\n        p2x = points[2];\r\n        p2y = points[3];\r\n        perpx = -(p1y - p2y);\r\n        perpy = p1x - p2x;\r\n        dist = Math.sqrt(perpx * perpx + perpy * perpy);\r\n        perpx = perpx / dist * w;\r\n        perpy = perpy / dist * w;\r\n        result.push(p1x - perpx, p1y - perpy, p1x + perpx, p1y + perpy);\r\n        for (i = 1; i < length - 1; i++) {\r\n            p1x = points[(i - 1) * 2];\r\n            p1y = points[(i - 1) * 2 + 1];\r\n            p2x = points[(i) * 2];\r\n            p2y = points[(i) * 2 + 1];\r\n            p3x = points[(i + 1) * 2];\r\n            p3y = points[(i + 1) * 2 + 1];\r\n            perpx = -(p1y - p2y);\r\n            perpy = p1x - p2x;\r\n            dist = Math.sqrt(perpx * perpx + perpy * perpy);\r\n            perpx = perpx / dist * w;\r\n            perpy = perpy / dist * w;\r\n            perp2x = -(p2y - p3y);\r\n            perp2y = p2x - p3x;\r\n            dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);\r\n            perp2x = perp2x / dist * w;\r\n            perp2y = perp2y / dist * w;\r\n            a1 = (-perpy + p1y) - (-perpy + p2y);\r\n            b1 = (-perpx + p2x) - (-perpx + p1x);\r\n            c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);\r\n            a2 = (-perp2y + p3y) - (-perp2y + p2y);\r\n            b2 = (-perp2x + p2x) - (-perp2x + p3x);\r\n            c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);\r\n            denom = a1 * b2 - a2 * b1;\r\n            if (Math.abs(denom) < 0.1) {\r\n                denom += 10.1;\r\n                result.push(p2x - perpx, p2y - perpy, p2x + perpx, p2y + perpy);\r\n                continue;\r\n            }\r\n            px = (b1 * c2 - b2 * c1) / denom;\r\n            py = (a2 * c1 - a1 * c2) / denom;\r\n            pdist = (px - p2x) * (px - p2x) + (py - p2y) + (py - p2y);\r\n            result.push(px, py, p2x - (px - p2x), p2y - (py - p2y));\r\n        }\r\n        p1x = points[newlen - 4];\r\n        p1y = points[newlen - 3];\r\n        p2x = points[newlen - 2];\r\n        p2y = points[newlen - 1];\r\n        perpx = -(p1y - p2y);\r\n        perpy = p1x - p2x;\r\n        dist = Math.sqrt(perpx * perpx + perpy * perpy);\r\n        perpx = perpx / dist * w;\r\n        perpy = perpy / dist * w;\r\n        result.push(p2x - perpx, p2y - perpy, p2x + perpx, p2y + perpy);\r\n        for (i = 1; i < length; i++) {\r\n            indices.push(indexBase + (i - 1) * 2, indexBase + (i - 1) * 2 + 1, indexBase + i * 2 + 1, indexBase + i * 2 + 1, indexBase + i * 2, indexBase + (i - 1) * 2);\r\n        }\r\n        return result;\r\n    }\r\n    static createLineTriangle(path, color, width, loop, outvb, vbstride, outib) {\r\n        var points = path.slice();\r\n        var ptlen = points.length;\r\n        var p1x = points[0], p1y = points[1];\r\n        var p2x = points[2], p2y = points[2];\r\n        var len = 0;\r\n        var rp = 0;\r\n        var dx = 0, dy = 0;\r\n        var pointnum = ptlen / 2;\r\n        if (pointnum <= 1)\r\n            return;\r\n        if (pointnum == 2) {\r\n            return;\r\n        }\r\n        var tmpData = new Array(pointnum * 4);\r\n        var realPtNum = 0;\r\n        var ci = 0;\r\n        for (var i = 0; i < pointnum - 1; i++) {\r\n            p1x = points[ci++], p1y = points[ci++];\r\n            p2x = points[ci++], p2y = points[ci++];\r\n            dx = p2x - p1x, dy = p2y - p1y;\r\n            if (dx != 0 && dy != 0) {\r\n                len = Math.sqrt(dx * dx + dy * dy);\r\n                if (len > 1e-3) {\r\n                    rp = realPtNum * 4;\r\n                    tmpData[rp] = p1x;\r\n                    tmpData[rp + 1] = p1y;\r\n                    tmpData[rp + 2] = dx / len;\r\n                    tmpData[rp + 3] = dy / len;\r\n                    realPtNum++;\r\n                }\r\n            }\r\n        }\r\n        if (loop) {\r\n            p1x = points[ptlen - 2], p1y = points[ptlen - 1];\r\n            p2x = points[0], p2y = points[1];\r\n            dx = p2x - p1x, dy = p2y - p1y;\r\n            if (dx != 0 && dy != 0) {\r\n                len = Math.sqrt(dx * dx + dy * dy);\r\n                if (len > 1e-3) {\r\n                    rp = realPtNum * 4;\r\n                    tmpData[rp] = p1x;\r\n                    tmpData[rp + 1] = p1y;\r\n                    tmpData[rp + 2] = dx / len;\r\n                    tmpData[rp + 3] = dy / len;\r\n                    realPtNum++;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            rp = realPtNum * 4;\r\n            tmpData[rp] = p1x;\r\n            tmpData[rp + 1] = p1y;\r\n            tmpData[rp + 2] = dx / len;\r\n            tmpData[rp + 3] = dy / len;\r\n            realPtNum++;\r\n        }\r\n        ci = 0;\r\n        for (i = 0; i < pointnum; i++) {\r\n            p1x = points[ci], p1y = points[ci + 1];\r\n            p2x = points[ci + 2], p2y = points[ci + 3];\r\n        }\r\n        if (loop) {\r\n        }\r\n    }\r\n}\r\nBasePoly.tempData = new Array(256);\r\n",
  "references": [],
  "dts": {
    "name": "/Users/zonst/Documents/font2.0/font_game_2.10/.rpt2_cache/placeholder/laya/webgl/shapes/BasePoly.d.ts",
    "writeByteOrderMark": false,
    "text": "export declare class BasePoly {\r\n    private static tempData;\r\n    static createLine2(p: any[], indices: any[], lineWidth: number, indexBase: number, outVertex: any[], loop: boolean): any[];\r\n    static createLineTriangle(path: any[], color: number, width: number, loop: boolean, outvb: Float32Array, vbstride: number, outib: Uint16Array): void;\r\n}\r\n"
  }
}

{
  "code": "export class MathUtil {\r\n    static subtractVector3(l, r, o) {\r\n        o[0] = l[0] - r[0];\r\n        o[1] = l[1] - r[1];\r\n        o[2] = l[2] - r[2];\r\n    }\r\n    static lerp(left, right, amount) {\r\n        return left * (1 - amount) + right * amount;\r\n    }\r\n    static scaleVector3(f, b, e) {\r\n        e[0] = f[0] * b;\r\n        e[1] = f[1] * b;\r\n        e[2] = f[2] * b;\r\n    }\r\n    static lerpVector3(l, r, t, o) {\r\n        var ax = l[0], ay = l[1], az = l[2];\r\n        o[0] = ax + t * (r[0] - ax);\r\n        o[1] = ay + t * (r[1] - ay);\r\n        o[2] = az + t * (r[2] - az);\r\n    }\r\n    static lerpVector4(l, r, t, o) {\r\n        var ax = l[0], ay = l[1], az = l[2], aw = l[3];\r\n        o[0] = ax + t * (r[0] - ax);\r\n        o[1] = ay + t * (r[1] - ay);\r\n        o[2] = az + t * (r[2] - az);\r\n        o[3] = aw + t * (r[3] - aw);\r\n    }\r\n    static slerpQuaternionArray(a, Offset1, b, Offset2, t, out, Offset3) {\r\n        var ax = a[Offset1 + 0], ay = a[Offset1 + 1], az = a[Offset1 + 2], aw = a[Offset1 + 3], bx = b[Offset2 + 0], by = b[Offset2 + 1], bz = b[Offset2 + 2], bw = b[Offset2 + 3];\r\n        var omega, cosom, sinom, scale0, scale1;\r\n        cosom = ax * bx + ay * by + az * bz + aw * bw;\r\n        if (cosom < 0.0) {\r\n            cosom = -cosom;\r\n            bx = -bx;\r\n            by = -by;\r\n            bz = -bz;\r\n            bw = -bw;\r\n        }\r\n        if ((1.0 - cosom) > 0.000001) {\r\n            omega = Math.acos(cosom);\r\n            sinom = Math.sin(omega);\r\n            scale0 = Math.sin((1.0 - t) * omega) / sinom;\r\n            scale1 = Math.sin(t * omega) / sinom;\r\n        }\r\n        else {\r\n            scale0 = 1.0 - t;\r\n            scale1 = t;\r\n        }\r\n        out[Offset3 + 0] = scale0 * ax + scale1 * bx;\r\n        out[Offset3 + 1] = scale0 * ay + scale1 * by;\r\n        out[Offset3 + 2] = scale0 * az + scale1 * bz;\r\n        out[Offset3 + 3] = scale0 * aw + scale1 * bw;\r\n        return out;\r\n    }\r\n    static getRotation(x0, y0, x1, y1) {\r\n        return Math.atan2(y1 - y0, x1 - x0) / Math.PI * 180;\r\n    }\r\n    static sortBigFirst(a, b) {\r\n        if (a == b)\r\n            return 0;\r\n        return b > a ? 1 : -1;\r\n    }\r\n    static sortSmallFirst(a, b) {\r\n        if (a == b)\r\n            return 0;\r\n        return b > a ? -1 : 1;\r\n    }\r\n    static sortNumBigFirst(a, b) {\r\n        return parseFloat(b) - parseFloat(a);\r\n    }\r\n    static sortNumSmallFirst(a, b) {\r\n        return parseFloat(a) - parseFloat(b);\r\n    }\r\n    static sortByKey(key, bigFirst = false, forceNum = true) {\r\n        var _sortFun;\r\n        if (bigFirst) {\r\n            _sortFun = forceNum ? MathUtil.sortNumBigFirst : MathUtil.sortBigFirst;\r\n        }\r\n        else {\r\n            _sortFun = forceNum ? MathUtil.sortNumSmallFirst : MathUtil.sortSmallFirst;\r\n        }\r\n        return function (a, b) {\r\n            return _sortFun(a[key], b[key]);\r\n        };\r\n    }\r\n}\r\n",
  "references": [],
  "dts": {
    "name": "/Users/zonst/Documents/font2.0/font_game_2.10/.rpt2_cache/placeholder/laya/maths/MathUtil.d.ts",
    "writeByteOrderMark": false,
    "text": "export declare class MathUtil {\r\n    static subtractVector3(l: Float32Array, r: Float32Array, o: Float32Array): void;\r\n    static lerp(left: number, right: number, amount: number): number;\r\n    static scaleVector3(f: Float32Array, b: number, e: Float32Array): void;\r\n    static lerpVector3(l: Float32Array, r: Float32Array, t: number, o: Float32Array): void;\r\n    static lerpVector4(l: Float32Array, r: Float32Array, t: number, o: Float32Array): void;\r\n    static slerpQuaternionArray(a: Float32Array, Offset1: number, b: Float32Array, Offset2: number, t: number, out: Float32Array, Offset3: number): Float32Array;\r\n    static getRotation(x0: number, y0: number, x1: number, y1: number): number;\r\n    static sortBigFirst(a: number, b: number): number;\r\n    static sortSmallFirst(a: number, b: number): number;\r\n    static sortNumBigFirst(a: any, b: any): number;\r\n    static sortNumSmallFirst(a: any, b: any): number;\r\n    static sortByKey(key: string, bigFirst?: boolean, forceNum?: boolean): (a: any, b: any) => number;\r\n}\r\n"
  }
}

{
  "code": "import { Point } from \"../maths/Point\";\r\nimport { Rectangle } from \"../maths/Rectangle\";\r\nimport { ILaya } from \"../../ILaya\";\r\nexport class Utils {\r\n    static toRadian(angle) {\r\n        return angle * Utils._pi2;\r\n    }\r\n    static toAngle(radian) {\r\n        return radian * Utils._pi;\r\n    }\r\n    static toHexColor(color) {\r\n        if (color < 0 || isNaN(color))\r\n            return null;\r\n        var str = color.toString(16);\r\n        while (str.length < 6)\r\n            str = \"0\" + str;\r\n        return \"#\" + str;\r\n    }\r\n    static getGID() {\r\n        return Utils._gid++;\r\n    }\r\n    static concatArray(source, array) {\r\n        if (!array)\r\n            return source;\r\n        if (!source)\r\n            return array;\r\n        var i, len = array.length;\r\n        for (i = 0; i < len; i++) {\r\n            source.push(array[i]);\r\n        }\r\n        return source;\r\n    }\r\n    static clearArray(array) {\r\n        if (!array)\r\n            return array;\r\n        array.length = 0;\r\n        return array;\r\n    }\r\n    static copyArray(source, array) {\r\n        source || (source = []);\r\n        if (!array)\r\n            return source;\r\n        source.length = array.length;\r\n        var i, len = array.length;\r\n        for (i = 0; i < len; i++) {\r\n            source[i] = array[i];\r\n        }\r\n        return source;\r\n    }\r\n    static getGlobalRecByPoints(sprite, x0, y0, x1, y1) {\r\n        var newLTPoint;\r\n        newLTPoint = Point.create().setTo(x0, y0);\r\n        newLTPoint = sprite.localToGlobal(newLTPoint);\r\n        var newRBPoint;\r\n        newRBPoint = Point.create().setTo(x1, y1);\r\n        newRBPoint = sprite.localToGlobal(newRBPoint);\r\n        var rst = Rectangle._getWrapRec([newLTPoint.x, newLTPoint.y, newRBPoint.x, newRBPoint.y]);\r\n        newLTPoint.recover();\r\n        newRBPoint.recover();\r\n        return rst;\r\n    }\r\n    static getGlobalPosAndScale(sprite) {\r\n        return Utils.getGlobalRecByPoints(sprite, 0, 0, 1, 1);\r\n    }\r\n    static bind(fun, scope) {\r\n        var rst = fun;\r\n        rst = fun.bind(scope);\r\n        ;\r\n        return rst;\r\n    }\r\n    static updateOrder(array) {\r\n        if (!array || array.length < 2)\r\n            return false;\r\n        var i = 1, j, len = array.length, key, c;\r\n        while (i < len) {\r\n            j = i;\r\n            c = array[j];\r\n            key = array[j]._zOrder;\r\n            while (--j > -1) {\r\n                if (array[j]._zOrder > key)\r\n                    array[j + 1] = array[j];\r\n                else\r\n                    break;\r\n            }\r\n            array[j + 1] = c;\r\n            i++;\r\n        }\r\n        return true;\r\n    }\r\n    static transPointList(points, x, y) {\r\n        var i, len = points.length;\r\n        for (i = 0; i < len; i += 2) {\r\n            points[i] += x;\r\n            points[i + 1] += y;\r\n        }\r\n    }\r\n    static parseInt(str, radix = 0) {\r\n        var result = parseInt(str, radix);\r\n        if (isNaN(result))\r\n            return 0;\r\n        return result;\r\n    }\r\n    static getFileExtension(path) {\r\n        Utils._extReg.lastIndex = path.lastIndexOf(\".\");\r\n        var result = Utils._extReg.exec(path);\r\n        if (result && result.length > 1) {\r\n            return result[1].toLowerCase();\r\n        }\r\n        return null;\r\n    }\r\n    static getFilecompatibleExtension(path) {\r\n        var result = path.split(\".\");\r\n        var resultlen = result.length;\r\n        if (result.length > 2)\r\n            return result[resultlen - 2] + \".\" + result[resultlen - 1];\r\n        else\r\n            return null;\r\n    }\r\n    static getTransformRelativeToWindow(coordinateSpace, x, y) {\r\n        var stage = Utils.gStage;\r\n        var globalTransform = Utils.getGlobalPosAndScale(coordinateSpace);\r\n        var canvasMatrix = stage._canvasTransform.clone();\r\n        var canvasLeft = canvasMatrix.tx;\r\n        var canvasTop = canvasMatrix.ty;\r\n        canvasMatrix.rotate(-Math.PI / 180 * stage.canvasDegree);\r\n        canvasMatrix.scale(stage.clientScaleX, stage.clientScaleY);\r\n        var perpendicular = (stage.canvasDegree % 180 != 0);\r\n        var tx, ty;\r\n        if (perpendicular) {\r\n            tx = y + globalTransform.y;\r\n            ty = x + globalTransform.x;\r\n            tx *= canvasMatrix.d;\r\n            ty *= canvasMatrix.a;\r\n            if (stage.canvasDegree == 90) {\r\n                tx = canvasLeft - tx;\r\n                ty += canvasTop;\r\n            }\r\n            else {\r\n                tx += canvasLeft;\r\n                ty = canvasTop - ty;\r\n            }\r\n        }\r\n        else {\r\n            tx = x + globalTransform.x;\r\n            ty = y + globalTransform.y;\r\n            tx *= canvasMatrix.a;\r\n            ty *= canvasMatrix.d;\r\n            tx += canvasLeft;\r\n            ty += canvasTop;\r\n        }\r\n        ty += stage['_safariOffsetY'];\r\n        var domScaleX, domScaleY;\r\n        if (perpendicular) {\r\n            domScaleX = canvasMatrix.d * globalTransform.height;\r\n            domScaleY = canvasMatrix.a * globalTransform.width;\r\n        }\r\n        else {\r\n            domScaleX = canvasMatrix.a * globalTransform.width;\r\n            domScaleY = canvasMatrix.d * globalTransform.height;\r\n        }\r\n        return { x: tx, y: ty, scaleX: domScaleX, scaleY: domScaleY };\r\n    }\r\n    static fitDOMElementInArea(dom, coordinateSpace, x, y, width, height) {\r\n        if (!dom._fitLayaAirInitialized) {\r\n            dom._fitLayaAirInitialized = true;\r\n            dom.style.transformOrigin = dom.style.webKittransformOrigin = \"left top\";\r\n            dom.style.position = \"absolute\";\r\n        }\r\n        var transform = Utils.getTransformRelativeToWindow(coordinateSpace, x, y);\r\n        dom.style.transform = dom.style.webkitTransform = \"scale(\" + transform.scaleX + \",\" + transform.scaleY + \") rotate(\" + (Utils.gStage.canvasDegree) + \"deg)\";\r\n        dom.style.width = width + 'px';\r\n        dom.style.height = height + 'px';\r\n        dom.style.left = transform.x + 'px';\r\n        dom.style.top = transform.y + 'px';\r\n    }\r\n    static isOkTextureList(textureList) {\r\n        if (!textureList)\r\n            return false;\r\n        var i, len = textureList.length;\r\n        var tTexture;\r\n        for (i = 0; i < len; i++) {\r\n            tTexture = textureList[i];\r\n            if (!tTexture || !tTexture._getSource())\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    static isOKCmdList(cmds) {\r\n        if (!cmds)\r\n            return false;\r\n        var i, len = cmds.length;\r\n        var cmd;\r\n        var tex;\r\n        for (i = 0; i < len; i++) {\r\n            cmd = cmds[i];\r\n        }\r\n        return true;\r\n    }\r\n    static getQueryString(name) {\r\n        if (ILaya.Browser.onMiniGame)\r\n            return null;\r\n        if (!window.location || !window.location.search)\r\n            return null;\r\n        var reg = new RegExp(\"(^|&)\" + name + \"=([^&]*)(&|$)\");\r\n        var r = window.location.search.substr(1).match(reg);\r\n        if (r != null)\r\n            return unescape(r[2]);\r\n        return null;\r\n    }\r\n}\r\nUtils.gStage = null;\r\nUtils._gid = 1;\r\nUtils._pi = 180 / Math.PI;\r\nUtils._pi2 = Math.PI / 180;\r\nUtils._extReg = /\\.(\\w+)\\??/g;\r\nUtils.parseXMLFromString = function (value) {\r\n    var rst;\r\n    value = value.replace(/>\\s+</g, '><');\r\n    rst = (new DOMParser()).parseFromString(value, 'text/xml');\r\n    if (rst.firstChild.textContent.indexOf(\"This page contains the following errors\") > -1) {\r\n        throw new Error(rst.firstChild.firstChild.textContent);\r\n    }\r\n    return rst;\r\n};\r\n",
  "references": [
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/display/Sprite.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/display/Stage.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/maths/Matrix.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/maths/Point.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/maths/Rectangle.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/resource/Texture.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/ILaya.ts"
  ],
  "dts": {
    "name": "/Users/zonst/Documents/font2.0/font_game_2.10/.rpt2_cache/placeholder/laya/utils/Utils.d.ts",
    "writeByteOrderMark": false,
    "text": "import { Sprite } from \"../display/Sprite\";\r\nimport { Stage } from \"../display/Stage\";\r\nimport { Rectangle } from \"../maths/Rectangle\";\r\nexport declare class Utils {\r\n    static gStage: Stage;\r\n    private static _gid;\r\n    private static _pi;\r\n    private static _pi2;\r\n    protected static _extReg: RegExp;\r\n    static toRadian(angle: number): number;\r\n    static toAngle(radian: number): number;\r\n    static toHexColor(color: number): string;\r\n    static getGID(): number;\r\n    static parseXMLFromString: Function;\r\n    static concatArray(source: any[], array: any[]): any[];\r\n    static clearArray(array: any[]): any[];\r\n    static copyArray(source: any[], array: any[]): any[];\r\n    static getGlobalRecByPoints(sprite: Sprite, x0: number, y0: number, x1: number, y1: number): Rectangle;\r\n    static getGlobalPosAndScale(sprite: Sprite): Rectangle;\r\n    static bind(fun: Function, scope: any): Function;\r\n    static updateOrder(array: any[]): boolean;\r\n    static transPointList(points: any[], x: number, y: number): void;\r\n    static parseInt(str: string, radix?: number): number;\r\n    static getFileExtension(path: string): string;\r\n    static getFilecompatibleExtension(path: string): string;\r\n    static getTransformRelativeToWindow(coordinateSpace: Sprite, x: number, y: number): any;\r\n    static fitDOMElementInArea(dom: any, coordinateSpace: Sprite, x: number, y: number, width: number, height: number): void;\r\n    static isOkTextureList(textureList: any[]): boolean;\r\n    static isOKCmdList(cmds: any[]): boolean;\r\n    static getQueryString(name: string): string;\r\n}\r\n"
  }
}

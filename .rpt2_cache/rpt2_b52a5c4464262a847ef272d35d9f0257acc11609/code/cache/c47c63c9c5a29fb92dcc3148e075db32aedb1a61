{
  "code": "import { LayaGL } from \"../../layagl/LayaGL\";\r\nimport { RenderInfo } from \"../../renders/RenderInfo\";\r\nimport { BaseShader } from \"../shader/BaseShader\";\r\nimport { Buffer } from \"./Buffer\";\r\nexport class Buffer2D extends Buffer {\r\n    constructor() {\r\n        super();\r\n        this._maxsize = 0;\r\n        this._upload = true;\r\n        this._uploadSize = 0;\r\n        this._bufferSize = 0;\r\n        this._u8Array = null;\r\n    }\r\n    static __int__(gl) {\r\n    }\r\n    get bufferLength() {\r\n        return this._buffer.byteLength;\r\n    }\r\n    set byteLength(value) {\r\n        this.setByteLength(value);\r\n    }\r\n    setByteLength(value) {\r\n        if (this._byteLength !== value) {\r\n            value <= this._bufferSize || (this._resizeBuffer(value * 2 + 256, true));\r\n            this._byteLength = value;\r\n        }\r\n    }\r\n    needSize(sz) {\r\n        var old = this._byteLength;\r\n        if (sz) {\r\n            var needsz = this._byteLength + sz;\r\n            needsz <= this._bufferSize || (this._resizeBuffer(needsz << 1, true));\r\n            this._byteLength = needsz;\r\n        }\r\n        return old;\r\n    }\r\n    _bufferData() {\r\n        this._maxsize = Math.max(this._maxsize, this._byteLength);\r\n        if (RenderInfo.loopCount % 30 == 0) {\r\n            if (this._buffer.byteLength > (this._maxsize + 64)) {\r\n                this._buffer = this._buffer.slice(0, this._maxsize + 64);\r\n                this._bufferSize = this._buffer.byteLength;\r\n                this._checkArrayUse();\r\n            }\r\n            this._maxsize = this._byteLength;\r\n        }\r\n        if (this._uploadSize < this._buffer.byteLength) {\r\n            this._uploadSize = this._buffer.byteLength;\r\n            LayaGL.instance.bufferData(this._bufferType, this._uploadSize, this._bufferUsage);\r\n        }\r\n        LayaGL.instance.bufferSubData(this._bufferType, 0, new Uint8Array(this._buffer, 0, this._byteLength));\r\n    }\r\n    _bufferSubData(offset = 0, dataStart = 0, dataLength = 0) {\r\n        this._maxsize = Math.max(this._maxsize, this._byteLength);\r\n        if (RenderInfo.loopCount % 30 == 0) {\r\n            if (this._buffer.byteLength > (this._maxsize + 64)) {\r\n                this._buffer = this._buffer.slice(0, this._maxsize + 64);\r\n                this._bufferSize = this._buffer.byteLength;\r\n                this._checkArrayUse();\r\n            }\r\n            this._maxsize = this._byteLength;\r\n        }\r\n        if (this._uploadSize < this._buffer.byteLength) {\r\n            this._uploadSize = this._buffer.byteLength;\r\n            LayaGL.instance.bufferData(this._bufferType, this._uploadSize, this._bufferUsage);\r\n        }\r\n        if (dataStart || dataLength) {\r\n            var subBuffer = this._buffer.slice(dataStart, dataLength);\r\n            LayaGL.instance.bufferSubData(this._bufferType, offset, subBuffer);\r\n        }\r\n        else {\r\n            LayaGL.instance.bufferSubData(this._bufferType, offset, this._buffer);\r\n        }\r\n    }\r\n    _checkArrayUse() {\r\n    }\r\n    _bind_uploadForVAO() {\r\n        if (!this._upload)\r\n            return false;\r\n        this._upload = false;\r\n        this._bindForVAO();\r\n        this._bufferData();\r\n        return true;\r\n    }\r\n    _bind_upload() {\r\n        if (!this._upload)\r\n            return false;\r\n        this._upload = false;\r\n        this.bind();\r\n        this._bufferData();\r\n        return true;\r\n    }\r\n    _bind_subUpload(offset = 0, dataStart = 0, dataLength = 0) {\r\n        if (!this._upload)\r\n            return false;\r\n        this._upload = false;\r\n        this.bind();\r\n        this._bufferSubData(offset, dataStart, dataLength);\r\n        return true;\r\n    }\r\n    _resizeBuffer(nsz, copy) {\r\n        var buff = this._buffer;\r\n        if (nsz <= buff.byteLength)\r\n            return this;\r\n        var u8buf = this._u8Array;\r\n        if (copy && buff && buff.byteLength > 0) {\r\n            var newbuffer = new ArrayBuffer(nsz);\r\n            var oldU8Arr = (u8buf && u8buf.buffer == buff) ? u8buf : new Uint8Array(buff);\r\n            u8buf = this._u8Array = new Uint8Array(newbuffer);\r\n            u8buf.set(oldU8Arr, 0);\r\n            buff = this._buffer = newbuffer;\r\n        }\r\n        else {\r\n            buff = this._buffer = new ArrayBuffer(nsz);\r\n            this._u8Array = null;\r\n        }\r\n        this._checkArrayUse();\r\n        this._upload = true;\r\n        this._bufferSize = buff.byteLength;\r\n        return this;\r\n    }\r\n    append(data) {\r\n        this._upload = true;\r\n        var byteLen, n;\r\n        byteLen = data.byteLength;\r\n        if (data instanceof Uint8Array) {\r\n            this._resizeBuffer(this._byteLength + byteLen, true);\r\n            n = new Uint8Array(this._buffer, this._byteLength);\r\n        }\r\n        else if (data instanceof Uint16Array) {\r\n            this._resizeBuffer(this._byteLength + byteLen, true);\r\n            n = new Uint16Array(this._buffer, this._byteLength);\r\n        }\r\n        else if (data instanceof Float32Array) {\r\n            this._resizeBuffer(this._byteLength + byteLen, true);\r\n            n = new Float32Array(this._buffer, this._byteLength);\r\n        }\r\n        n.set(data, 0);\r\n        this._byteLength += byteLen;\r\n        this._checkArrayUse();\r\n    }\r\n    appendU16Array(data, len) {\r\n        this._resizeBuffer(this._byteLength + len * 2, true);\r\n        var u = new Uint16Array(this._buffer, this._byteLength, len);\r\n        if (len == 6) {\r\n            u[0] = data[0];\r\n            u[1] = data[1];\r\n            u[2] = data[2];\r\n            u[3] = data[3];\r\n            u[4] = data[4];\r\n            u[5] = data[5];\r\n        }\r\n        else if (len >= 100) {\r\n            u.set(new Uint16Array(data.buffer, 0, len));\r\n        }\r\n        else {\r\n            for (var i = 0; i < len; i++) {\r\n                u[i] = data[i];\r\n            }\r\n        }\r\n        this._byteLength += len * 2;\r\n        this._checkArrayUse();\r\n    }\r\n    appendEx(data, type) {\r\n        this._upload = true;\r\n        var byteLen, n;\r\n        byteLen = data.byteLength;\r\n        this._resizeBuffer(this._byteLength + byteLen, true);\r\n        n = new type(this._buffer, this._byteLength);\r\n        n.set(data, 0);\r\n        this._byteLength += byteLen;\r\n        this._checkArrayUse();\r\n    }\r\n    appendEx2(data, type, dataLen, perDataLen = 1) {\r\n        this._upload = true;\r\n        var byteLen, n;\r\n        byteLen = dataLen * perDataLen;\r\n        this._resizeBuffer(this._byteLength + byteLen, true);\r\n        n = new type(this._buffer, this._byteLength);\r\n        var i;\r\n        for (i = 0; i < dataLen; i++) {\r\n            n[i] = data[i];\r\n        }\r\n        this._byteLength += byteLen;\r\n        this._checkArrayUse();\r\n    }\r\n    getBuffer() {\r\n        return this._buffer;\r\n    }\r\n    setNeedUpload() {\r\n        this._upload = true;\r\n    }\r\n    getNeedUpload() {\r\n        return this._upload;\r\n    }\r\n    upload() {\r\n        var gl = LayaGL.instance;\r\n        var scuess = this._bind_upload();\r\n        gl.bindBuffer(this._bufferType, null);\r\n        if (this._bufferType == gl.ARRAY_BUFFER)\r\n            Buffer._bindedVertexBuffer = null;\r\n        if (this._bufferType == gl.ELEMENT_ARRAY_BUFFER)\r\n            Buffer._bindedIndexBuffer = null;\r\n        BaseShader.activeShader = null;\r\n        return scuess;\r\n    }\r\n    subUpload(offset = 0, dataStart = 0, dataLength = 0) {\r\n        var gl = LayaGL.instance;\r\n        var scuess = this._bind_subUpload();\r\n        gl.bindBuffer(this._bufferType, null);\r\n        if (this._bufferType == gl.ARRAY_BUFFER)\r\n            Buffer._bindedVertexBuffer = null;\r\n        if (this._bufferType == gl.ELEMENT_ARRAY_BUFFER)\r\n            Buffer._bindedIndexBuffer = null;\r\n        BaseShader.activeShader = null;\r\n        return scuess;\r\n    }\r\n    _disposeResource() {\r\n        this._upload = true;\r\n        this._uploadSize = 0;\r\n    }\r\n    clear() {\r\n        this._byteLength = 0;\r\n        this._upload = true;\r\n    }\r\n}\r\nBuffer2D.FLOAT32 = 4;\r\nBuffer2D.SHORT = 2;\r\n",
  "references": [
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/layagl/LayaGL.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/renders/RenderInfo.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/webgl/shader/BaseShader.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/webgl/WebGLContext.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/webgl/utils/Buffer.ts"
  ],
  "dts": {
    "name": "/Users/zonst/Documents/font2.0/font_game_2.10/.rpt2_cache/placeholder/laya/webgl/utils/Buffer2D.d.ts",
    "writeByteOrderMark": false,
    "text": "import { WebGLContext } from \"../WebGLContext\";\r\nimport { Buffer } from \"./Buffer\";\r\nexport declare class Buffer2D extends Buffer {\r\n    static FLOAT32: number;\r\n    static SHORT: number;\r\n    static __int__(gl: WebGLContext): void;\r\n    protected _maxsize: number;\r\n    _upload: boolean;\r\n    protected _uploadSize: number;\r\n    protected _bufferSize: number;\r\n    protected _u8Array: Uint8Array;\r\n    readonly bufferLength: number;\r\n    byteLength: number;\r\n    setByteLength(value: number): void;\r\n    needSize(sz: number): number;\r\n    constructor();\r\n    protected _bufferData(): void;\r\n    protected _bufferSubData(offset?: number, dataStart?: number, dataLength?: number): void;\r\n    protected _checkArrayUse(): void;\r\n    _bind_uploadForVAO(): boolean;\r\n    _bind_upload(): boolean;\r\n    _bind_subUpload(offset?: number, dataStart?: number, dataLength?: number): boolean;\r\n    _resizeBuffer(nsz: number, copy: boolean): Buffer2D;\r\n    append(data: any): void;\r\n    appendU16Array(data: Uint16Array, len: number): void;\r\n    appendEx(data: any, type: new (buf: any, len: any) => any): void;\r\n    appendEx2(data: any, type: new (buff: any, len: any) => any, dataLen: number, perDataLen?: number): void;\r\n    getBuffer(): ArrayBuffer;\r\n    setNeedUpload(): void;\r\n    getNeedUpload(): boolean;\r\n    upload(): boolean;\r\n    subUpload(offset?: number, dataStart?: number, dataLength?: number): boolean;\r\n    protected _disposeResource(): void;\r\n    clear(): void;\r\n}\r\n"
  }
}

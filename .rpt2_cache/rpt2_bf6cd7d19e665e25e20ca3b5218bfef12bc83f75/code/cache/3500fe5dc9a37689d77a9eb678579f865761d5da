{
  "code": "import { LayaGL } from \"../../layagl/LayaGL\";\r\nimport { Shader } from \"../shader/Shader\";\r\nimport { InlcudeFile } from \"./InlcudeFile\";\r\nimport { ShaderNode } from \"./ShaderNode\";\r\nexport class ShaderCompile {\r\n    constructor(vs, ps, nameMap) {\r\n        this.defs = {};\r\n        let _this = this;\r\n        function _compile(script) {\r\n            script = script.replace(ShaderCompile._clearCR, \"\");\r\n            var includefiles = [];\r\n            var top = new ShaderNode(includefiles);\r\n            _this._compileToTree(top, script.split('\\n'), 0, includefiles, _this.defs);\r\n            return top;\r\n        }\r\n        var startTime = Date.now();\r\n        this._VS = _compile(vs);\r\n        this._PS = _compile(ps);\r\n        this._nameMap = nameMap;\r\n        if ((Date.now() - startTime) > 2)\r\n            console.log(\"ShaderCompile use time:\" + (Date.now() - startTime) + \"  size:\" + vs.length + \"/\" + ps.length);\r\n    }\r\n    static __init__() {\r\n        var gl = LayaGL.instance;\r\n        ShaderCompile.shaderParamsMap = { \"float\": gl.FLOAT, \"int\": gl.INT, \"bool\": gl.BOOL, \"vec2\": gl.FLOAT_VEC2, \"vec3\": gl.FLOAT_VEC3, \"vec4\": gl.FLOAT_VEC4, \"ivec2\": gl.INT_VEC2, \"ivec3\": gl.INT_VEC3, \"ivec4\": gl.INT_VEC4, \"bvec2\": gl.BOOL_VEC2, \"bvec3\": gl.BOOL_VEC3, \"bvec4\": gl.BOOL_VEC4, \"mat2\": gl.FLOAT_MAT2, \"mat3\": gl.FLOAT_MAT3, \"mat4\": gl.FLOAT_MAT4, \"sampler2D\": gl.SAMPLER_2D, \"samplerCube\": gl.SAMPLER_CUBE };\r\n    }\r\n    static _parseOne(attributes, uniforms, words, i, word, b) {\r\n        var one = { type: ShaderCompile.shaderParamsMap[words[i + 1]], name: words[i + 2], size: isNaN(parseInt(words[i + 3])) ? 1 : parseInt(words[i + 3]) };\r\n        if (b) {\r\n            if (word == \"attribute\") {\r\n                attributes.push(one);\r\n            }\r\n            else {\r\n                uniforms.push(one);\r\n            }\r\n        }\r\n        if (words[i + 3] == ':') {\r\n            one.type = words[i + 4];\r\n            i += 2;\r\n        }\r\n        i += 2;\r\n        return i;\r\n    }\r\n    static addInclude(fileName, txt) {\r\n        if (!txt || txt.length === 0)\r\n            throw new Error(\"add shader include file err:\" + fileName);\r\n        if (ShaderCompile.includes[fileName])\r\n            throw new Error(\"add shader include file err, has add:\" + fileName);\r\n        ShaderCompile.includes[fileName] = new InlcudeFile(txt);\r\n    }\r\n    static preGetParams(vs, ps) {\r\n        var text = [vs, ps];\r\n        var result = {};\r\n        var attributes = [];\r\n        var uniforms = [];\r\n        var definesInfo = {};\r\n        var definesName = [];\r\n        result.attributes = attributes;\r\n        result.uniforms = uniforms;\r\n        result.defines = definesInfo;\r\n        var i, n, one;\r\n        for (var s = 0; s < 2; s++) {\r\n            text[s] = text[s].replace(ShaderCompile._removeAnnotation, \"\");\r\n            var words = text[s].match(ShaderCompile._reg);\r\n            var tempelse;\r\n            for (i = 0, n = words.length; i < n; i++) {\r\n                var word = words[i];\r\n                if (word != \"attribute\" && word != \"uniform\") {\r\n                    if (word == \"#define\") {\r\n                        word = words[++i];\r\n                        definesName[word] = 1;\r\n                        continue;\r\n                    }\r\n                    else if (word == \"#ifdef\") {\r\n                        tempelse = words[++i];\r\n                        var def = definesInfo[tempelse] = definesInfo[tempelse] || [];\r\n                        for (i++; i < n; i++) {\r\n                            word = words[i];\r\n                            if (word != \"attribute\" && word != \"uniform\") {\r\n                                if (word == \"#else\") {\r\n                                    for (i++; i < n; i++) {\r\n                                        word = words[i];\r\n                                        if (word != \"attribute\" && word != \"uniform\") {\r\n                                            if (word == \"#endif\") {\r\n                                                break;\r\n                                            }\r\n                                            continue;\r\n                                        }\r\n                                        i = ShaderCompile._parseOne(attributes, uniforms, words, i, word, !definesName[tempelse]);\r\n                                    }\r\n                                }\r\n                                continue;\r\n                            }\r\n                            i = ShaderCompile._parseOne(attributes, uniforms, words, i, word, definesName[tempelse]);\r\n                        }\r\n                    }\r\n                    continue;\r\n                }\r\n                i = ShaderCompile._parseOne(attributes, uniforms, words, i, word, true);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    static splitToWords(str, block) {\r\n        var out = [];\r\n        var c;\r\n        var ofs = -1;\r\n        var word;\r\n        for (var i = 0, n = str.length; i < n; i++) {\r\n            c = str.charAt(i);\r\n            if (\" \\t=+-*/&%!<>()'\\\",;\".indexOf(c) >= 0) {\r\n                if (ofs >= 0 && (i - ofs) > 1) {\r\n                    word = str.substr(ofs, i - ofs);\r\n                    out.push(word);\r\n                }\r\n                if (c == '\"' || c == \"'\") {\r\n                    var ofs2 = str.indexOf(c, i + 1);\r\n                    if (ofs2 < 0) {\r\n                        throw \"Sharder err:\" + str;\r\n                    }\r\n                    out.push(str.substr(i + 1, ofs2 - i - 1));\r\n                    i = ofs2;\r\n                    ofs = -1;\r\n                    continue;\r\n                }\r\n                if (c == '(' && block && out.length > 0) {\r\n                    word = out[out.length - 1] + \";\";\r\n                    if (\"vec4;main;\".indexOf(word) < 0)\r\n                        block.useFuns += word;\r\n                }\r\n                ofs = -1;\r\n                continue;\r\n            }\r\n            if (ofs < 0)\r\n                ofs = i;\r\n        }\r\n        if (ofs < n && (n - ofs) > 1) {\r\n            word = str.substr(ofs, n - ofs);\r\n            out.push(word);\r\n        }\r\n        return out;\r\n    }\r\n    _compileToTree(parent, lines, start, includefiles, defs) {\r\n        var node, preNode;\r\n        var text, name, fname;\r\n        var ofs, words, noUseNode;\r\n        var i, n, j;\r\n        for (i = start; i < lines.length; i++) {\r\n            text = lines[i];\r\n            if (text.length < 1)\r\n                continue;\r\n            ofs = text.indexOf(\"//\");\r\n            if (ofs === 0)\r\n                continue;\r\n            if (ofs >= 0)\r\n                text = text.substr(0, ofs);\r\n            node = noUseNode || new ShaderNode(includefiles);\r\n            noUseNode = null;\r\n            node.text = text;\r\n            node.noCompile = true;\r\n            if ((ofs = text.indexOf(\"#\")) >= 0) {\r\n                name = \"#\";\r\n                for (j = ofs + 1, n = text.length; j < n; j++) {\r\n                    var c = text.charAt(j);\r\n                    if (c === ' ' || c === '\\t' || c === '?')\r\n                        break;\r\n                    name += c;\r\n                }\r\n                node.name = name;\r\n                switch (name) {\r\n                    case \"#ifdef\":\r\n                    case \"#ifndef\":\r\n                        node.src = text;\r\n                        node.noCompile = text.match(/[!&|()=<>]/) != null;\r\n                        if (!node.noCompile) {\r\n                            words = text.replace(/^\\s*/, '').split(/\\s+/);\r\n                            node.setCondition(words[1], name === \"#ifdef\" ? ShaderCompile.IFDEF_YES : ShaderCompile.IFDEF_ELSE);\r\n                            node.text = \"//\" + node.text;\r\n                        }\r\n                        else {\r\n                            console.log(\"function():Boolean{return \" + text.substr(ofs + node.name.length) + \"}\");\r\n                        }\r\n                        node.setParent(parent);\r\n                        parent = node;\r\n                        if (defs) {\r\n                            words = text.substr(j).split(ShaderCompile._splitToWordExps3);\r\n                            for (j = 0; j < words.length; j++) {\r\n                                text = words[j];\r\n                                text.length && (defs[text] = true);\r\n                            }\r\n                        }\r\n                        continue;\r\n                    case \"#if\":\r\n                        node.src = text;\r\n                        node.noCompile = true;\r\n                        node.setParent(parent);\r\n                        parent = node;\r\n                        if (defs) {\r\n                            words = text.substr(j).split(ShaderCompile._splitToWordExps3);\r\n                            for (j = 0; j < words.length; j++) {\r\n                                text = words[j];\r\n                                text.length && text != \"defined\" && (defs[text] = true);\r\n                            }\r\n                        }\r\n                        continue;\r\n                    case \"#else\":\r\n                        node.src = text;\r\n                        parent = parent.parent;\r\n                        preNode = parent.childs[parent.childs.length - 1];\r\n                        node.noCompile = preNode.noCompile;\r\n                        if (!node.noCompile) {\r\n                            node.condition = preNode.condition;\r\n                            node.conditionType = preNode.conditionType == ShaderCompile.IFDEF_YES ? ShaderCompile.IFDEF_ELSE : ShaderCompile.IFDEF_YES;\r\n                            node.text = \"//\" + node.text + \" \" + preNode.text + \" \" + node.conditionType;\r\n                        }\r\n                        node.setParent(parent);\r\n                        parent = node;\r\n                        continue;\r\n                    case \"#endif\":\r\n                        parent = parent.parent;\r\n                        preNode = parent.childs[parent.childs.length - 1];\r\n                        node.noCompile = preNode.noCompile;\r\n                        if (!node.noCompile) {\r\n                            node.text = \"//\" + node.text;\r\n                        }\r\n                        node.setParent(parent);\r\n                        continue;\r\n                    case \"#include\":\r\n                        words = ShaderCompile.splitToWords(text, null);\r\n                        var inlcudeFile = ShaderCompile.includes[words[1]];\r\n                        if (!inlcudeFile) {\r\n                            throw \"ShaderCompile error no this include file:\" + words[1];\r\n                        }\r\n                        if ((ofs = words[0].indexOf(\"?\")) < 0) {\r\n                            node.setParent(parent);\r\n                            text = inlcudeFile.getWith(words[2] == 'with' ? words[3] : null);\r\n                            this._compileToTree(node, text.split('\\n'), 0, includefiles, defs);\r\n                            node.text = \"\";\r\n                            continue;\r\n                        }\r\n                        node.setCondition(words[0].substr(ofs + 1), ShaderCompile.IFDEF_YES);\r\n                        node.text = inlcudeFile.getWith(words[2] == 'with' ? words[3] : null);\r\n                        break;\r\n                    case \"#import\":\r\n                        words = ShaderCompile.splitToWords(text, null);\r\n                        fname = words[1];\r\n                        includefiles.push({ node: node, file: ShaderCompile.includes[fname], ofs: node.text.length });\r\n                        continue;\r\n                }\r\n            }\r\n            else {\r\n                preNode = parent.childs[parent.childs.length - 1];\r\n                if (preNode && !preNode.name) {\r\n                    includefiles.length > 0 && ShaderCompile.splitToWords(text, preNode);\r\n                    noUseNode = node;\r\n                    preNode.text += \"\\n\" + text;\r\n                    continue;\r\n                }\r\n                includefiles.length > 0 && ShaderCompile.splitToWords(text, node);\r\n            }\r\n            node.setParent(parent);\r\n        }\r\n    }\r\n    createShader(define, shaderName, createShader, bindAttrib) {\r\n        var defMap = {};\r\n        var defineStr = \"\";\r\n        if (define) {\r\n            for (var i in define) {\r\n                defineStr += \"#define \" + i + \"\\n\";\r\n                defMap[i] = true;\r\n            }\r\n        }\r\n        var vs = this._VS.toscript(defMap, []);\r\n        var ps = this._PS.toscript(defMap, []);\r\n        return (createShader || Shader.create)(defineStr + vs.join('\\n'), defineStr + ps.join('\\n'), shaderName, this._nameMap, bindAttrib);\r\n    }\r\n}\r\nShaderCompile.IFDEF_NO = 0;\r\nShaderCompile.IFDEF_YES = 1;\r\nShaderCompile.IFDEF_ELSE = 2;\r\nShaderCompile.IFDEF_PARENT = 3;\r\nShaderCompile._removeAnnotation = new RegExp(\"(/\\\\*([^*]|[\\\\r\\\\\\n]|(\\\\*+([^*/]|[\\\\r\\\\n])))*\\\\*+/)|(//.*)\", \"g\");\r\nShaderCompile._reg = new RegExp(\"(\\\".*\\\")|('.*')|([#\\\\w\\\\*-\\\\.+/()=<>{}\\\\\\\\]+)|([,;:\\\\\\\\])\", \"g\");\r\nShaderCompile._splitToWordExps = new RegExp(\"[(\\\".*\\\")]+|[('.*')]+|([ \\\\t=\\\\+\\\\-*/&%!<>!%\\(\\),;])\", \"g\");\r\nShaderCompile.includes = {};\r\nShaderCompile._clearCR = new RegExp(\"\\r\", \"g\");\r\nShaderCompile._splitToWordExps3 = new RegExp(\"[ \\\\t=\\\\+\\\\-*/&%!<>!%\\(\\),;\\\\|]\", \"g\");\r\n",
  "references": [
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/layagl/LayaGL.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/webgl/shader/Shader.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/webgl/utils/InlcudeFile.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/webgl/utils/ShaderNode.ts"
  ],
  "dts": {
    "name": "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/webgl/utils/ShaderCompile.d.ts",
    "writeByteOrderMark": false,
    "text": "import { Shader } from \"../shader/Shader\";\r\nimport { ShaderNode } from \"./ShaderNode\";\r\nexport declare class ShaderCompile {\r\n    static IFDEF_NO: number;\r\n    static IFDEF_YES: number;\r\n    static IFDEF_ELSE: number;\r\n    static IFDEF_PARENT: number;\r\n    static _removeAnnotation: RegExp;\r\n    static _reg: RegExp;\r\n    static _splitToWordExps: RegExp;\r\n    static includes: any;\r\n    static shaderParamsMap: any;\r\n    private _nameMap;\r\n    _VS: ShaderNode;\r\n    _PS: ShaderNode;\r\n    static __init__(): void;\r\n    private static _parseOne;\r\n    static addInclude(fileName: string, txt: string): void;\r\n    static preGetParams(vs: string, ps: string): any;\r\n    static splitToWords(str: string, block: ShaderNode): any[];\r\n    static _clearCR: RegExp;\r\n    defs: Object;\r\n    constructor(vs: string, ps: string, nameMap: any);\r\n    static _splitToWordExps3: RegExp;\r\n    protected _compileToTree(parent: ShaderNode, lines: any[], start: number, includefiles: any[], defs: any): void;\r\n    createShader(define: any, shaderName: any, createShader: Function, bindAttrib: any[]): Shader;\r\n}\r\n"
  }
}

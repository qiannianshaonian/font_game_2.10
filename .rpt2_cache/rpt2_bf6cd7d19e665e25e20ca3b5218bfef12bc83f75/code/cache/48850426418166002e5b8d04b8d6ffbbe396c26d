{
  "code": "import { Matrix } from \"../../maths/Matrix\";\r\nimport { Sprite } from \"../../display/Sprite\";\r\nimport { ILaya } from \"../../../ILaya\";\r\nexport class IkConstraint {\r\n    constructor(data, bones) {\r\n        this.isSpine = true;\r\n        this.isDebug = false;\r\n        this._targetBone = bones[data.targetBoneIndex];\r\n        this.isSpine = data.isSpine;\r\n        if (this._bones == null)\r\n            this._bones = [];\r\n        this._bones.length = 0;\r\n        for (var i = 0, n = data.boneIndexs.length; i < n; i++) {\r\n            this._bones.push(bones[data.boneIndexs[i]]);\r\n        }\r\n        this.name = data.name;\r\n        this.mix = data.mix;\r\n        this.bendDirection = data.bendDirection;\r\n    }\r\n    apply() {\r\n        switch (this._bones.length) {\r\n            case 1:\r\n                this._applyIk1(this._bones[0], this._targetBone.resultMatrix.tx, this._targetBone.resultMatrix.ty, this.mix);\r\n                break;\r\n            case 2:\r\n                if (this.isSpine) {\r\n                    this._applyIk2(this._bones[0], this._bones[1], this._targetBone.resultMatrix.tx, this._targetBone.resultMatrix.ty, this.bendDirection, this.mix);\r\n                }\r\n                else {\r\n                    this._applyIk3(this._bones[0], this._bones[1], this._targetBone.resultMatrix.tx, this._targetBone.resultMatrix.ty, this.bendDirection, this.mix);\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    _applyIk1(bone, targetX, targetY, alpha) {\r\n        var pp = bone.parentBone;\r\n        var id = 1 / (pp.resultMatrix.a * pp.resultMatrix.d - pp.resultMatrix.b * pp.resultMatrix.c);\r\n        var x = targetX - pp.resultMatrix.tx;\r\n        var y = targetY - pp.resultMatrix.ty;\r\n        var tx = (x * pp.resultMatrix.d - y * pp.resultMatrix.c) * id - bone.transform.x;\r\n        var ty = (y * pp.resultMatrix.a - x * pp.resultMatrix.b) * id - bone.transform.y;\r\n        var rotationIK = Math.atan2(ty, tx) * IkConstraint.radDeg - 0 - bone.transform.skX;\r\n        if (bone.transform.scX < 0)\r\n            rotationIK += 180;\r\n        if (rotationIK > 180)\r\n            rotationIK -= 360;\r\n        else if (rotationIK < -180)\r\n            rotationIK += 360;\r\n        bone.transform.skX = bone.transform.skY = bone.transform.skX + rotationIK * alpha;\r\n        bone.update();\r\n    }\r\n    updatePos(x, y) {\r\n        if (this._sp) {\r\n            this._sp.pos(x, y);\r\n        }\r\n    }\r\n    _applyIk2(parent, child, targetX, targetY, bendDir, alpha) {\r\n        if (alpha == 0) {\r\n            return;\r\n        }\r\n        var px = parent.resultTransform.x, py = parent.resultTransform.y;\r\n        var psx = parent.transform.scX, psy = parent.transform.scY;\r\n        var csx = child.transform.scX;\r\n        var os1, os2, s2;\r\n        if (psx < 0) {\r\n            psx = -psx;\r\n            os1 = 180;\r\n            s2 = -1;\r\n        }\r\n        else {\r\n            os1 = 0;\r\n            s2 = 1;\r\n        }\r\n        if (psy < 0) {\r\n            psy = -psy;\r\n            s2 = -s2;\r\n        }\r\n        if (csx < 0) {\r\n            csx = -csx;\r\n            os2 = 180;\r\n        }\r\n        else {\r\n            os2 = 0;\r\n        }\r\n        var cx = child.resultTransform.x, cy, cwx, cwy;\r\n        var a = parent.resultMatrix.a, b = parent.resultMatrix.c;\r\n        var c = parent.resultMatrix.b, d = parent.resultMatrix.d;\r\n        var u = Math.abs(psx - psy) <= 0.0001;\r\n        if (!u) {\r\n            cy = 0;\r\n            cwx = a * cx + parent.resultMatrix.tx;\r\n            cwy = c * cx + parent.resultMatrix.ty;\r\n        }\r\n        else {\r\n            cy = child.resultTransform.y;\r\n            cwx = a * cx + b * cy + parent.resultMatrix.tx;\r\n            cwy = c * cx + d * cy + parent.resultMatrix.ty;\r\n        }\r\n        if (this.isDebug) {\r\n            if (!this._sp) {\r\n                this._sp = new Sprite();\r\n                ILaya.stage.addChild(this._sp);\r\n            }\r\n            this._sp.graphics.clear();\r\n            this._sp.graphics.drawCircle(targetX, targetY, 15, \"#ffff00\");\r\n            this._sp.graphics.drawCircle(cwx, cwy, 15, \"#ff00ff\");\r\n        }\r\n        parent.setRotation(Math.atan2(cwy - parent.resultMatrix.ty, cwx - parent.resultMatrix.tx));\r\n        var pp = parent.parentBone;\r\n        a = pp.resultMatrix.a;\r\n        b = pp.resultMatrix.c;\r\n        c = pp.resultMatrix.b;\r\n        d = pp.resultMatrix.d;\r\n        var id = 1 / (a * d - b * c);\r\n        var x = targetX - pp.resultMatrix.tx, y = targetY - pp.resultMatrix.ty;\r\n        var tx = (x * d - y * b) * id - px;\r\n        var ty = (y * a - x * c) * id - py;\r\n        x = cwx - pp.resultMatrix.tx;\r\n        y = cwy - pp.resultMatrix.ty;\r\n        var dx = (x * d - y * b) * id - px;\r\n        var dy = (y * a - x * c) * id - py;\r\n        var l1 = Math.sqrt(dx * dx + dy * dy);\r\n        var l2 = child.length * csx;\r\n        var a1, a2;\r\n        if (u) {\r\n            l2 *= psx;\r\n            var cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);\r\n            if (cos < -1)\r\n                cos = -1;\r\n            else if (cos > 1)\r\n                cos = 1;\r\n            a2 = Math.acos(cos) * bendDir;\r\n            a = l1 + l2 * cos;\r\n            b = l2 * Math.sin(a2);\r\n            a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\r\n        }\r\n        else {\r\n            a = psx * l2;\r\n            b = psy * l2;\r\n            var aa = a * a, bb = b * b, dd = tx * tx + ty * ty, ta = Math.atan2(ty, tx);\r\n            c = bb * l1 * l1 + aa * dd - aa * bb;\r\n            var c1 = -2 * bb * l1, c2 = bb - aa;\r\n            d = c1 * c1 - 4 * c2 * c;\r\n            if (d > 0) {\r\n                var q = Math.sqrt(d);\r\n                if (c1 < 0)\r\n                    q = -q;\r\n                q = -(c1 + q) / 2;\r\n                var r0 = q / c2, r1 = c / q;\r\n                var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\r\n                if (r * r <= dd) {\r\n                    y = Math.sqrt(dd - r * r) * bendDir;\r\n                    a1 = ta - Math.atan2(y, r);\r\n                    a2 = Math.atan2(y / psy, (r - l1) / psx);\r\n                }\r\n            }\r\n            var minAngle = 0, minDist = Number.MAX_VALUE, minX = 0, minY = 0;\r\n            var maxAngle = 0, maxDist = 0, maxX = 0, maxY = 0;\r\n            x = l1 + a;\r\n            d = x * x;\r\n            if (d > maxDist) {\r\n                maxAngle = 0;\r\n                maxDist = d;\r\n                maxX = x;\r\n            }\r\n            x = l1 - a;\r\n            d = x * x;\r\n            if (d < minDist) {\r\n                minAngle = Math.PI;\r\n                minDist = d;\r\n                minX = x;\r\n            }\r\n            var angle = Math.acos(-a * l1 / (aa - bb));\r\n            x = a * Math.cos(angle) + l1;\r\n            y = b * Math.sin(angle);\r\n            d = x * x + y * y;\r\n            if (d < minDist) {\r\n                minAngle = angle;\r\n                minDist = d;\r\n                minX = x;\r\n                minY = y;\r\n            }\r\n            if (d > maxDist) {\r\n                maxAngle = angle;\r\n                maxDist = d;\r\n                maxX = x;\r\n                maxY = y;\r\n            }\r\n            if (dd <= (minDist + maxDist) / 2) {\r\n                a1 = ta - Math.atan2(minY * bendDir, minX);\r\n                a2 = minAngle * bendDir;\r\n            }\r\n            else {\r\n                a1 = ta - Math.atan2(maxY * bendDir, maxX);\r\n                a2 = maxAngle * bendDir;\r\n            }\r\n        }\r\n        var os = Math.atan2(cy, cx) * s2;\r\n        var rotation = parent.resultTransform.skX;\r\n        a1 = (a1 - os) * IkConstraint.radDeg + os1 - rotation;\r\n        if (a1 > 180)\r\n            a1 -= 360;\r\n        else if (a1 < -180)\r\n            a1 += 360;\r\n        parent.resultTransform.x = px;\r\n        parent.resultTransform.y = py;\r\n        parent.resultTransform.skX = parent.resultTransform.skY = rotation + a1 * alpha;\r\n        rotation = child.resultTransform.skX;\r\n        rotation = rotation % 360;\r\n        a2 = ((a2 + os) * IkConstraint.radDeg - 0) * s2 + os2 - rotation;\r\n        if (a2 > 180)\r\n            a2 -= 360;\r\n        else if (a2 < -180)\r\n            a2 += 360;\r\n        child.resultTransform.x = cx;\r\n        child.resultTransform.y = cy;\r\n        child.resultTransform.skX = child.resultTransform.skY = child.resultTransform.skY + a2 * alpha;\r\n        parent.update();\r\n    }\r\n    _applyIk3(parent, child, targetX, targetY, bendDir, alpha) {\r\n        if (alpha == 0) {\r\n            return;\r\n        }\r\n        var cwx, cwy;\r\n        const x = child.resultMatrix.a * child.length;\r\n        const y = child.resultMatrix.b * child.length;\r\n        const lLL = x * x + y * y;\r\n        const lL = Math.sqrt(lLL);\r\n        var parentX = parent.resultMatrix.tx;\r\n        var parentY = parent.resultMatrix.ty;\r\n        var childX = child.resultMatrix.tx;\r\n        var childY = child.resultMatrix.ty;\r\n        var dX = childX - parentX;\r\n        var dY = childY - parentY;\r\n        const lPP = dX * dX + dY * dY;\r\n        const lP = Math.sqrt(lPP);\r\n        dX = targetX - parent.resultMatrix.tx;\r\n        dY = targetY - parent.resultMatrix.ty;\r\n        const lTT = dX * dX + dY * dY;\r\n        const lT = Math.sqrt(lTT);\r\n        var ikRadianA = 0;\r\n        if (lL + lP <= lT || lT + lL <= lP || lT + lP <= lL) {\r\n            var rate;\r\n            if (lL + lP <= lT) {\r\n                rate = 1;\r\n            }\r\n            else {\r\n                rate = -1;\r\n            }\r\n            childX = parentX + rate * (targetX - parentX) * lP / lT;\r\n            childY = parentY + rate * (targetY - parentY) * lP / lT;\r\n        }\r\n        else {\r\n            const h = (lPP - lLL + lTT) / (2 * lTT);\r\n            const r = Math.sqrt(lPP - h * h * lTT) / lT;\r\n            const hX = parentX + (dX * h);\r\n            const hY = parentY + (dY * h);\r\n            const rX = -dY * r;\r\n            const rY = dX * r;\r\n            if (bendDir > 0) {\r\n                childX = hX - rX;\r\n                childY = hY - rY;\r\n            }\r\n            else {\r\n                childX = hX + rX;\r\n                childY = hY + rY;\r\n            }\r\n        }\r\n        cwx = childX;\r\n        cwy = childY;\r\n        if (this.isDebug) {\r\n            if (!this._sp) {\r\n                this._sp = new Sprite();\r\n                ILaya.stage.addChild(this._sp);\r\n            }\r\n            this._sp.graphics.clear();\r\n            this._sp.graphics.drawCircle(parentX, parentY, 15, \"#ff00ff\");\r\n            this._sp.graphics.drawCircle(targetX, targetY, 15, \"#ffff00\");\r\n            this._sp.graphics.drawCircle(cwx, cwy, 15, \"#ff00ff\");\r\n        }\r\n        var pRotation;\r\n        pRotation = Math.atan2(cwy - parent.resultMatrix.ty, cwx - parent.resultMatrix.tx);\r\n        parent.setRotation(pRotation);\r\n        var pTarMatrix;\r\n        pTarMatrix = IkConstraint._tempMatrix;\r\n        pTarMatrix.identity();\r\n        pTarMatrix.rotate(pRotation);\r\n        pTarMatrix.scale(parent.resultMatrix.getScaleX(), parent.resultMatrix.getScaleY());\r\n        pTarMatrix.translate(parent.resultMatrix.tx, parent.resultMatrix.ty);\r\n        pTarMatrix.copyTo(parent.resultMatrix);\r\n        parent.updateChild();\r\n        var childRotation;\r\n        childRotation = Math.atan2(targetY - cwy, targetX - cwx);\r\n        child.setRotation(childRotation);\r\n        var childTarMatrix;\r\n        childTarMatrix = IkConstraint._tempMatrix;\r\n        childTarMatrix.identity();\r\n        childTarMatrix.rotate(childRotation);\r\n        childTarMatrix.scale(child.resultMatrix.getScaleX(), child.resultMatrix.getScaleY());\r\n        childTarMatrix.translate(cwx, cwy);\r\n        pTarMatrix.copyTo(child.resultMatrix);\r\n        child.updateChild();\r\n    }\r\n}\r\nIkConstraint.radDeg = 180 / Math.PI;\r\nIkConstraint.degRad = Math.PI / 180;\r\nIkConstraint._tempMatrix = new Matrix();\r\n",
  "references": [
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/ani/bone/IkConstraintData.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/ani/bone/Bone.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/maths/Matrix.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/display/Sprite.ts",
    "/Users/zonst/Documents/font2.0/font_game_2.10/libs/ILaya.ts"
  ],
  "dts": {
    "name": "/Users/zonst/Documents/font2.0/font_game_2.10/libs/laya/ani/bone/IkConstraint.d.ts",
    "writeByteOrderMark": false,
    "text": "import { IkConstraintData } from \"./IkConstraintData\";\r\nimport { Bone } from \"./Bone\";\r\nexport declare class IkConstraint {\r\n    private _targetBone;\r\n    private _bones;\r\n    name: string;\r\n    mix: number;\r\n    bendDirection: number;\r\n    isSpine: boolean;\r\n    static radDeg: number;\r\n    static degRad: number;\r\n    private static _tempMatrix;\r\n    constructor(data: IkConstraintData, bones: Bone[]);\r\n    apply(): void;\r\n    private _applyIk1;\r\n    private _sp;\r\n    private isDebug;\r\n    updatePos(x: number, y: number): void;\r\n    private _applyIk2;\r\n    private _applyIk3;\r\n}\r\n"
  }
}

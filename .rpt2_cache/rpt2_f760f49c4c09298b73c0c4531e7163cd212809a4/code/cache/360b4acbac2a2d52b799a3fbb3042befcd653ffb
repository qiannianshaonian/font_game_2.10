{
  "code": "import { CallLater } from \"./CallLater\";\r\nimport { ILaya } from \"../../ILaya\";\r\nexport class Timer {\r\n    constructor(autoActive = true) {\r\n        this.scale = 1;\r\n        this.currTimer = Date.now();\r\n        this.currFrame = 0;\r\n        this._delta = 0;\r\n        this._lastTimer = Date.now();\r\n        this._map = [];\r\n        this._handlers = [];\r\n        this._temp = [];\r\n        this._count = 0;\r\n        autoActive && Timer.gSysTimer && Timer.gSysTimer.frameLoop(1, this, this._update);\r\n    }\r\n    get delta() {\r\n        return this._delta;\r\n    }\r\n    _update() {\r\n        if (this.scale <= 0) {\r\n            this._lastTimer = Date.now();\r\n            this._delta = 0;\r\n            return;\r\n        }\r\n        var frame = this.currFrame = this.currFrame + this.scale;\r\n        var now = Date.now();\r\n        var awake = (now - this._lastTimer) > 30000;\r\n        this._delta = (now - this._lastTimer) * this.scale;\r\n        var timer = this.currTimer = this.currTimer + this._delta;\r\n        this._lastTimer = now;\r\n        var handlers = this._handlers;\r\n        this._count = 0;\r\n        for (var i = 0, n = handlers.length; i < n; i++) {\r\n            var handler = handlers[i];\r\n            if (handler.method !== null) {\r\n                var t = handler.userFrame ? frame : timer;\r\n                if (t >= handler.exeTime) {\r\n                    if (handler.repeat) {\r\n                        if (!handler.jumpFrame || awake) {\r\n                            handler.exeTime += handler.delay;\r\n                            handler.run(false);\r\n                            if (t > handler.exeTime) {\r\n                                handler.exeTime += Math.ceil((t - handler.exeTime) / handler.delay) * handler.delay;\r\n                            }\r\n                        }\r\n                        else {\r\n                            while (t >= handler.exeTime) {\r\n                                handler.exeTime += handler.delay;\r\n                                handler.run(false);\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        handler.run(true);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                this._count++;\r\n            }\r\n        }\r\n        if (this._count > 30 || frame % 200 === 0)\r\n            this._clearHandlers();\r\n    }\r\n    _clearHandlers() {\r\n        var handlers = this._handlers;\r\n        for (var i = 0, n = handlers.length; i < n; i++) {\r\n            var handler = handlers[i];\r\n            if (handler.method !== null)\r\n                this._temp.push(handler);\r\n            else\r\n                this._recoverHandler(handler);\r\n        }\r\n        this._handlers = this._temp;\r\n        handlers.length = 0;\r\n        this._temp = handlers;\r\n    }\r\n    _recoverHandler(handler) {\r\n        if (this._map[handler.key] == handler)\r\n            this._map[handler.key] = null;\r\n        handler.clear();\r\n        Timer._pool.push(handler);\r\n    }\r\n    _create(useFrame, repeat, delay, caller, method, args, coverBefore) {\r\n        if (!delay) {\r\n            method.apply(caller, args);\r\n            return null;\r\n        }\r\n        if (coverBefore) {\r\n            var handler = this._getHandler(caller, method);\r\n            if (handler) {\r\n                handler.repeat = repeat;\r\n                handler.userFrame = useFrame;\r\n                handler.delay = delay;\r\n                handler.caller = caller;\r\n                handler.method = method;\r\n                handler.args = args;\r\n                handler.exeTime = delay + (useFrame ? this.currFrame : this.currTimer + Date.now() - this._lastTimer);\r\n                return handler;\r\n            }\r\n        }\r\n        handler = Timer._pool.length > 0 ? Timer._pool.pop() : new TimerHandler();\r\n        handler.repeat = repeat;\r\n        handler.userFrame = useFrame;\r\n        handler.delay = delay;\r\n        handler.caller = caller;\r\n        handler.method = method;\r\n        handler.args = args;\r\n        handler.exeTime = delay + (useFrame ? this.currFrame : this.currTimer + Date.now() - this._lastTimer);\r\n        this._indexHandler(handler);\r\n        this._handlers.push(handler);\r\n        return handler;\r\n    }\r\n    _indexHandler(handler) {\r\n        var caller = handler.caller;\r\n        var method = handler.method;\r\n        var cid = caller ? caller.$_GID || (caller.$_GID = ILaya.Utils.getGID()) : 0;\r\n        var mid = method.$_TID || (method.$_TID = (Timer._mid++) * 100000);\r\n        handler.key = cid + mid;\r\n        this._map[handler.key] = handler;\r\n    }\r\n    once(delay, caller, method, args = null, coverBefore = true) {\r\n        this._create(false, false, delay, caller, method, args, coverBefore);\r\n    }\r\n    loop(delay, caller, method, args = null, coverBefore = true, jumpFrame = false) {\r\n        var handler = this._create(false, true, delay, caller, method, args, coverBefore);\r\n        if (handler)\r\n            handler.jumpFrame = jumpFrame;\r\n    }\r\n    frameOnce(delay, caller, method, args = null, coverBefore = true) {\r\n        this._create(true, false, delay, caller, method, args, coverBefore);\r\n    }\r\n    frameLoop(delay, caller, method, args = null, coverBefore = true) {\r\n        this._create(true, true, delay, caller, method, args, coverBefore);\r\n    }\r\n    toString() {\r\n        return \" handlers:\" + this._handlers.length + \" pool:\" + Timer._pool.length;\r\n    }\r\n    clear(caller, method) {\r\n        var handler = this._getHandler(caller, method);\r\n        if (handler) {\r\n            this._map[handler.key] = null;\r\n            handler.key = 0;\r\n            handler.clear();\r\n        }\r\n    }\r\n    clearAll(caller) {\r\n        if (!caller)\r\n            return;\r\n        for (var i = 0, n = this._handlers.length; i < n; i++) {\r\n            var handler = this._handlers[i];\r\n            if (handler.caller === caller) {\r\n                this._map[handler.key] = null;\r\n                handler.key = 0;\r\n                handler.clear();\r\n            }\r\n        }\r\n    }\r\n    _getHandler(caller, method) {\r\n        var cid = caller ? caller.$_GID || (caller.$_GID = ILaya.Utils.getGID()) : 0;\r\n        var mid = method.$_TID || (method.$_TID = (Timer._mid++) * 100000);\r\n        return this._map[cid + mid];\r\n    }\r\n    callLater(caller, method, args = null) {\r\n        CallLater.I.callLater(caller, method, args);\r\n    }\r\n    runCallLater(caller, method) {\r\n        CallLater.I.runCallLater(caller, method);\r\n    }\r\n    runTimer(caller, method) {\r\n        var handler = this._getHandler(caller, method);\r\n        if (handler && handler.method != null) {\r\n            this._map[handler.key] = null;\r\n            handler.run(true);\r\n        }\r\n    }\r\n    pause() {\r\n        this.scale = 0;\r\n    }\r\n    resume() {\r\n        this.scale = 1;\r\n    }\r\n}\r\nTimer.gSysTimer = null;\r\nTimer._pool = [];\r\nTimer._mid = 1;\r\nclass TimerHandler {\r\n    clear() {\r\n        this.caller = null;\r\n        this.method = null;\r\n        this.args = null;\r\n    }\r\n    run(withClear) {\r\n        var caller = this.caller;\r\n        if (caller && caller.destroyed)\r\n            return this.clear();\r\n        var method = this.method;\r\n        var args = this.args;\r\n        withClear && this.clear();\r\n        if (method == null)\r\n            return;\r\n        args ? method.apply(caller, args) : method.call(caller);\r\n    }\r\n}\r\n",
  "references": [
    "F:/ProjectsWorks/font_game_2.10/libs/laya/utils/CallLater.ts",
    "F:/ProjectsWorks/font_game_2.10/libs/ILaya.ts"
  ],
  "dts": {
    "name": "F:/ProjectsWorks/font_game_2.10/.rpt2_cache/placeholder/laya/utils/Timer.d.ts",
    "writeByteOrderMark": false,
    "text": "export declare class Timer {\r\n    static gSysTimer: Timer;\r\n    private static _pool;\r\n    static _mid: number;\r\n    scale: number;\r\n    currTimer: number;\r\n    currFrame: number;\r\n    _delta: number;\r\n    _lastTimer: number;\r\n    private _map;\r\n    private _handlers;\r\n    private _temp;\r\n    private _count;\r\n    constructor(autoActive?: boolean);\r\n    readonly delta: number;\r\n    _update(): void;\r\n    private _clearHandlers;\r\n    private _recoverHandler;\r\n    _create(useFrame: boolean, repeat: boolean, delay: number, caller: any, method: Function, args: any[], coverBefore: boolean): TimerHandler;\r\n    private _indexHandler;\r\n    once(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean): void;\r\n    loop(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean, jumpFrame?: boolean): void;\r\n    frameOnce(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean): void;\r\n    frameLoop(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean): void;\r\n    toString(): string;\r\n    clear(caller: any, method: Function): void;\r\n    clearAll(caller: any): void;\r\n    private _getHandler;\r\n    callLater(caller: any, method: Function, args?: any[]): void;\r\n    runCallLater(caller: any, method: Function): void;\r\n    runTimer(caller: any, method: Function): void;\r\n    pause(): void;\r\n    resume(): void;\r\n}\r\ndeclare class TimerHandler {\r\n    key: number;\r\n    repeat: boolean;\r\n    delay: number;\r\n    userFrame: boolean;\r\n    exeTime: number;\r\n    caller: any;\r\n    method: Function;\r\n    args: any[];\r\n    jumpFrame: boolean;\r\n    clear(): void;\r\n    run(withClear: boolean): void;\r\n}\r\nexport {};\r\n"
  }
}

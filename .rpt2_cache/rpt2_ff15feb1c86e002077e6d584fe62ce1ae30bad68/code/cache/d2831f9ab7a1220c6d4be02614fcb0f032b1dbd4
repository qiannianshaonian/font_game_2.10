{
  "code": "import { Handler } from \"../utils/Handler\";\r\nexport class EventDispatcher {\r\n    hasListener(type) {\r\n        var listener = this._events && this._events[type];\r\n        return !!listener;\r\n    }\r\n    event(type, data = null) {\r\n        if (!this._events || !this._events[type])\r\n            return false;\r\n        var listeners = this._events[type];\r\n        if (listeners.run) {\r\n            if (listeners.once)\r\n                delete this._events[type];\r\n            data != null ? listeners.runWith(data) : listeners.run();\r\n        }\r\n        else {\r\n            for (var i = 0, n = listeners.length; i < n; i++) {\r\n                var listener = listeners[i];\r\n                if (listener) {\r\n                    (data != null) ? listener.runWith(data) : listener.run();\r\n                }\r\n                if (!listener || listener.once) {\r\n                    listeners.splice(i, 1);\r\n                    i--;\r\n                    n--;\r\n                }\r\n            }\r\n            if (listeners.length === 0 && this._events)\r\n                delete this._events[type];\r\n        }\r\n        return true;\r\n    }\r\n    on(type, caller, listener, args = null) {\r\n        return this._createListener(type, caller, listener, args, false);\r\n    }\r\n    once(type, caller, listener, args = null) {\r\n        return this._createListener(type, caller, listener, args, true);\r\n    }\r\n    _createListener(type, caller, listener, args, once, offBefore = true) {\r\n        offBefore && this.off(type, caller, listener, once);\r\n        var handler = EventHandler.create(caller || this, listener, args, once);\r\n        this._events || (this._events = {});\r\n        var events = this._events;\r\n        if (!events[type])\r\n            events[type] = handler;\r\n        else {\r\n            if (!events[type].run)\r\n                events[type].push(handler);\r\n            else\r\n                events[type] = [events[type], handler];\r\n        }\r\n        return this;\r\n    }\r\n    off(type, caller, listener, onceOnly = false) {\r\n        if (!this._events || !this._events[type])\r\n            return this;\r\n        var listeners = this._events[type];\r\n        if (listeners != null) {\r\n            if (listeners.run) {\r\n                if ((!caller || listeners.caller === caller) && (listener == null || listeners.method === listener) && (!onceOnly || listeners.once)) {\r\n                    delete this._events[type];\r\n                    listeners.recover();\r\n                }\r\n            }\r\n            else {\r\n                var count = 0;\r\n                for (var i = 0, n = listeners.length; i < n; i++) {\r\n                    var item = listeners[i];\r\n                    if (!item) {\r\n                        count++;\r\n                        continue;\r\n                    }\r\n                    if (item && (!caller || item.caller === caller) && (listener == null || item.method === listener) && (!onceOnly || item.once)) {\r\n                        count++;\r\n                        listeners[i] = null;\r\n                        item.recover();\r\n                    }\r\n                }\r\n                if (count === n)\r\n                    delete this._events[type];\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    offAll(type = null) {\r\n        var events = this._events;\r\n        if (!events)\r\n            return this;\r\n        if (type) {\r\n            this._recoverHandlers(events[type]);\r\n            delete events[type];\r\n        }\r\n        else {\r\n            for (var name in events) {\r\n                this._recoverHandlers(events[name]);\r\n            }\r\n            this._events = null;\r\n        }\r\n        return this;\r\n    }\r\n    offAllCaller(caller) {\r\n        if (caller && this._events) {\r\n            for (var name in this._events) {\r\n                this.off(name, caller, null);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    _recoverHandlers(arr) {\r\n        if (!arr)\r\n            return;\r\n        if (arr.run) {\r\n            arr.recover();\r\n        }\r\n        else {\r\n            for (var i = arr.length - 1; i > -1; i--) {\r\n                if (arr[i]) {\r\n                    arr[i].recover();\r\n                    arr[i] = null;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    isMouseEvent(type) {\r\n        return EventDispatcher.MOUSE_EVENTS[type] || false;\r\n    }\r\n}\r\nEventDispatcher.MOUSE_EVENTS = { \"rightmousedown\": true, \"rightmouseup\": true, \"rightclick\": true, \"mousedown\": true, \"mouseup\": true, \"mousemove\": true, \"mouseover\": true, \"mouseout\": true, \"click\": true, \"doubleclick\": true };\r\nclass EventHandler extends Handler {\r\n    constructor(caller, method, args, once) {\r\n        super(caller, method, args, once);\r\n    }\r\n    recover() {\r\n        if (this._id > 0) {\r\n            this._id = 0;\r\n            EventHandler._pool.push(this.clear());\r\n        }\r\n    }\r\n    static create(caller, method, args = null, once = true) {\r\n        if (EventHandler._pool.length)\r\n            return EventHandler._pool.pop().setTo(caller, method, args, once);\r\n        return new EventHandler(caller, method, args, once);\r\n    }\r\n}\r\nEventHandler._pool = [];\r\n",
  "references": [
    "F:/ProjectsWorks/font_game_2ceshi/libs/laya/utils/Handler.ts"
  ],
  "dts": {
    "name": "F:/ProjectsWorks/font_game_2ceshi/.rpt2_cache/placeholder/laya/events/EventDispatcher.d.ts",
    "writeByteOrderMark": false,
    "text": "export declare class EventDispatcher {\r\n    static MOUSE_EVENTS: any;\r\n    private _events;\r\n    hasListener(type: string): boolean;\r\n    event(type: string, data?: any): boolean;\r\n    on(type: string, caller: any, listener: Function, args?: any[]): EventDispatcher;\r\n    once(type: string, caller: any, listener: Function, args?: any[]): EventDispatcher;\r\n    _createListener(type: string, caller: any, listener: Function, args: any[], once: boolean, offBefore?: boolean): EventDispatcher;\r\n    off(type: string, caller: any, listener: Function, onceOnly?: boolean): EventDispatcher;\r\n    offAll(type?: string): EventDispatcher;\r\n    offAllCaller(caller: any): EventDispatcher;\r\n    private _recoverHandlers;\r\n    isMouseEvent(type: string): boolean;\r\n}\r\n"
  }
}

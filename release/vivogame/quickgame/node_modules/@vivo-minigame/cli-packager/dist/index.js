'use strict';var _interopRequireWildcard=require("@babel/runtime-corejs2/helpers/interopRequireWildcard"),_interopRequireDefault=require("@babel/runtime-corejs2/helpers/interopRequireDefault"),_Object$defineProperty=require("@babel/runtime-corejs2/core-js/object/define-property");_Object$defineProperty(exports,"__esModule",{value:!0}),exports.release=exports.watch=exports.build=void 0;var _keys=_interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys")),_path=_interopRequireDefault(require("path")),_webpack=_interopRequireDefault(require("webpack")),_cliSharedUtils=require("@vivo-minigame/cli-shared-utils"),_cliServer=require("@vivo-minigame/cli-server"),_process=require("./config/process"),paths=_interopRequireWildcard(require("./lib/paths")),_manifest=require("./lib/manifest"),_constanst=require("./lib/constanst"),_subpackage=require("./lib/subpackage"),_writeMD=_interopRequireDefault(require("./lib/writeMD5"));const watch=async a=>build({...a,watch:!0});exports.watch=watch;const release=async a=>build({...a,isRelease:!0});exports.release=release;const build=async({isRelease:b=!1,watch:c=!1,inject:d=!0,isStreamPack:e=!0,buildType:a,complete:f=()=>{}})=>{(0,_manifest.check)(),_cliSharedUtils.fs.removeSync(paths.BUILD),_cliSharedUtils.fs.removeSync(paths.DIST),_cliSharedUtils.fs.removeSync(paths.TEMP);// 读取manifest配置
const g=(0,_manifest.get)();// 添加manifest配置 buildType
(0,_manifest.add)("buildType",a);// 是否配置插件包的判断
// 对manifest的插件配置个数进行校验
try{if(g.plugins){const a=(0,_keys.default)(g.plugins).length;if(1<a)return void(0,_cliSharedUtils.error)("\u8BF7\u68C0\u67E5manifest.json\u7684\u914D\u7F6E\uFF0C\u63D2\u4EF6\u53EA\u652F\u6301\u914D\u7F6E\u4E00\u4E2A\uFF0C\u5373plugins\u53EA\u80FD\u6709\u4E00\u4E2A\u5C5E\u6027")}}catch(a){(0,_cliSharedUtils.error)(a)}// 取pluginPath，并判断配置的合法性
// 对插件包里面的文件plugin.json判断
let h;try{const a=g.plugins?g.plugins["cocos-library"]||g.plugins["laya-library"]||g.plugins["egret-library"]:"";// 校验version不超过32字符
if(h=a.path,a&&32<a.version.length)return void(0,_cliSharedUtils.error)("\u8BF7\u68C0\u67E5manifest.json\u7684\u914D\u7F6E\uFF0Cplugins\u7684\u63D2\u4EF6\u7684version\u5B57\u6BB5\u7684\u503C\u5B57\u7B26\u4E0D\u80FD\u8D85\u8FC732\u4E2A\uFF0C\u8BF7\u4FEE\u6539\u540E\u518D\u5C1D\u8BD5");// 校验pluginPath的合法性
if(g.plugins&&0>["cocos-library","laya-library","egret-library"].indexOf(h))return void(0,_cliSharedUtils.error)("\u8BF7\u68C0\u67E5manifest.json\u7684\u914D\u7F6E\uFF0Cplugins\u7684\u63D2\u4EF6\u7684path\u5C5E\u6027\u503C\u9700\u8981\u8DDF\u63D2\u4EF6\u540D\u79F0\u4E00\u6837\uFF0C\u4E3Acocos-library | laya-library | egret-library \u8FD9\u4E09\u4E2A\u4E2D\u7684\u5176\u4E2D\u4E00\u4E2A");// 对插件包里面的文件做判断
if(g.plugins&&!_cliSharedUtils.fs.pathExistsSync(_path.default.join(_cliSharedUtils.projectPath,h,"/plugin.json")))return void(0,_cliSharedUtils.error)("\u8BF7\u68C0\u67E5\u63D2\u4EF6\u5305\u662F\u5426\u5B58\u5728\uFF0C\u8BF7\u68C0\u67E5\u91CC\u9762\u7684\u6587\u4EF6plugin.json\u662F\u5426\u7F3A\u5931")}catch(a){return void("Cannot read property 'path' of undefined"===a.message&&(0,_cliSharedUtils.error)("\u8BF7\u68C0\u67E5manifest.json\u7684\u914D\u7F6E\uFF0Cplugins\u7684\u5C5E\u6027\u503C\u53EA\u80FD\u4E3Acocos-library | laya-library | egret-library \u8FD9\u4E09\u4E2A\u4E2D\u7684\u5176\u4E2D\u4E00\u4E2A"))}// 写入MD5值
h&&(0,_writeMD.default)(h);// 过滤出合法的分包配置
const i=(0,_subpackage.filter)(g.subpackages),{entry:j,externals:k,isMain:l}=(0,_subpackage.toConfigs)(i);// 将分包配置转化为对应的webpack的打包入口
// 将分包配置转化为对应的externals用于打出兼容的原整包
// 对分包名称判断 不能为main
if(l)return void(0,_cliSharedUtils.error)("\u8BF7\u68C0\u67E5\u5206\u5305\u7684\u914D\u7F6E\uFF0C\u5206\u5305\u540D\u79F0\u4E0D\u80FD\u4E3Amain\uFF0C\u8BF7\u4FEE\u6539\u5206\u5305\u540D\u79F0");// 取出包名
const m=g.package||"Bundle",n=(0,_webpack.default)((0,_process.singleConfig)(j,b,m,k,d,i,h,e,g,a)),o=(c,d)=>{if(!(0,_process.checkError)(c,d))// 原整包打包完成后，判断是否存在分包配置，如果有就编译分包，如果没有，拷贝原整包作为最终的输出包
if((0,_cliSharedUtils.info)(`${_constanst.LOG_TITLE}原整包打包完成！ 耗时: ${(d.endTime-d.startTime)/1e3}s`),i.length)(0,_cliSharedUtils.info)(`${_constanst.LOG_TITLE}开始编译分包...`),(0,_webpack.default)((0,_process.multiConfig)(j,b,m,k,i,h,e,g,a),(a,b)=>{(0,_process.checkError)(a,b)||((0,_cliSharedUtils.info)(`${_constanst.LOG_TITLE}总包打包完成！ 耗时: ${(b.endTime-b.startTime)/1e3}s`),p())});else// 不分包不带插件包的 才走这个逻辑
// 不分包的带插件包的打包已经在webpack插件里面做了
if(!h){const a=_path.default.join(paths.TEMP,`${m}${_constanst.RPK}`),c=_path.default.join(paths.DIST,`${m}${b?_constanst.RPK_SIGNED:_constanst.RPK}`);_cliSharedUtils.fs.copy(a,c).then(p).catch(a=>{(0,_cliSharedUtils.error)(a)})}else p()},p=()=>{// 打包完成后，删除临时目录
// 通知调试器更新包
f(),_cliSharedUtils.fs.removeSync(paths.TEMP),(0,_cliSharedUtils.done)(`${_constanst.LOG_TITLE}压缩包已生成:${paths.DIST}`),c&&((0,_cliSharedUtils.log)(),(0,_cliSharedUtils.info)(`${_constanst.LOG_TITLE}开始监听文件变动，变动后自动重新构建...`)),(0,_cliServer.notifyUpdate)()};// 先打原整包
(0,_cliSharedUtils.info)(`${_constanst.LOG_TITLE}开始编译原整包...`),c?n.watch({aggregateTimeout:1e3,ignored:/node_modules/},o):n.run(o)};exports.build=build;
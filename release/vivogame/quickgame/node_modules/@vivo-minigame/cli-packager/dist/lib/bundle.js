/*
 * Copyright (C) 2017, hapjs.org. All rights reserved.
 */'use strict';var _interopRequireDefault=require("@babel/runtime-corejs2/helpers/interopRequireDefault"),_Object$defineProperty=require("@babel/runtime-corejs2/core-js/object/define-property");_Object$defineProperty(exports,"__esModule",{value:!0}),exports.signZip=signZip;var _keys=_interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys")),_path=_interopRequireDefault(require("path")),_crypto=_interopRequireDefault(require("crypto")),_signature=_interopRequireDefault(require("./signature")),_jsrsasign=_interopRequireDefault(require("jsrsasign")),_cliSharedUtils=require("@vivo-minigame/cli-shared-utils");/**
 * 加签名zip文件
 * @param fileBuf  文件buf数据
 * @param zipFileHashs  文件hash值 数组
 * @param prikey
 * @param certpem
 * @param output 导出路径 可以不填写
 */function signZip(a,b,d,e,f){const g=Buffer.from(_signature.default.Base64.unarmor(e)),h=new _jsrsasign.default.X509;h.readCertPEM(e.toString());const c=_jsrsasign.default.KEYUTIL.getPEM(h.getPublicKey());// 读取zip文件buf
// const fileBuf = fs.readFileSync(zip)
if(!a||4>=a.length)return(0,_cliSharedUtils.error)(`### App Loader ### Zip文件打开失败`),!1;// 检查文件类型是否正确
const i=a.readInt32LE(0);if("4034b50"!==i.toString(16).toLowerCase())return(0,_cliSharedUtils.error)(`### App Loader ### Zip文件格式错误`),!1;// 解析数据块
const j=parserZip(a);// 加入文件列表hash  makeSignChunk 函数会用到
if(j.options={},j.options.files=b,j.tag){(0,_keys.default)(j.sections).forEach(b=>{const c=j.sections[b];c.sign=getChunkSign(a,c)}),signChunk(j,d,c,g);const b=saveChunk(a,j);if(f)_cliSharedUtils.fs.writeFileSync(f,b);else return b}}/**
 * 解析Zip, 分解数据块
 * @param buf
 * @param tag
 */function parserZip(a){const b={tag:!1,length:a.length,sections:{header:null,central:null,footer:null}};return b.sections.footer=readEOCD(a),b.sections.footer.tag&&(b.sections.central=readCD(a,b.sections.footer.previous,b.sections.footer.startIndex-b.sections.footer.previous),b.sections.central.tag&&(b.sections.header=readFH(a,b.sections.central.previous,b.sections.central.startIndex-b.sections.central.previous),b.sections.header.tag&&(b.tag=!0))),b}/**
 * 从后往前读取
 * @param buf
 * @param tag  结束标签
 * @param offset  起始位置(不包括该位置), -1表示末尾
 */function readEOCD(a){const b={tag:!1};if(a&&22<=a.length){let c,d=a.length-22;// 从开始位置往前单个字节读取, 检查
for(;0<=d;){if(c=a.readInt32LE(d),"6054b50"===c.toString(16).toLowerCase()){b.tag=!0,b.startIndex=d,b.len=a.length-d,b.previous=a.readInt32LE(d+16);break}d-=1}}return b}/**
 * 从后往前读取
 * @param buf
 * @param tag  结束标签
 * @param offset  起始位置(不包括该位置), -1表示末尾
 */function readCD(a,b,c){const d={tag:!1};if(a&&a.length>=b){const e=a.readInt32LE(b);"2014b50"===e.toString(16).toLowerCase()&&(d.tag=!0,d.startIndex=b,d.len=c,d.previous=a.readInt32LE(b+42))}return d}/**
 * 从后往前读取
 * @param buf
 * @param tag  结束标签
 * @param offset  起始位置(不包括该位置), -1表示末尾
 */function readFH(a,b,c){const d={tag:!1};if(a&&a.length>=b){const e=a.readInt32LE(b);"4034b50"===e.toString(16).toLowerCase()&&(d.tag=!0,d.startIndex=b,d.len=c,d.previous=-1)}return d}/**
 * 数据块hash
 * @param buf
 * @param chunk
 */function getChunkSign(a,b){// 存储每个块的摘要
const c=b.startIndex,d=b.startIndex+b.len,e=a.slice(c,d),f=Buffer.alloc(5+b.len);f[0]=165,f.writeInt32LE(e.length,1),e.copy(f,5);const g=_crypto.default.createHash("SHA256");return g.update(f),g.digest()}/**
 * 对整个chunk签名
 * @param chunks
 */function signChunk(a,b,c,d){function e(a){a.copy(h,i),i+=a.length}const f=a.sections,g=f.header.sign.length+f.central.sign.length+f.footer.sign.length+5,h=Buffer.alloc(g);// 二进制拼接每个块摘要
let i=0;h.writeInt8(90,0),h.writeInt32LE(3,1),i+=5,e(f.header.sign),e(f.central.sign),e(f.footer.sign);// 计算整体摘要
const j=_crypto.default.createHash("SHA256");j.update(h);const k=j.digest(),l=makeSignChunk(a.options,k,b,c,d);// 生成sign block, 计算block总长度, 向buf中考入数据
a.signchunk=saveSignChunk(l)}/**
 *
 * @param file
 */function makeSignChunk(a,b,c,d,e){// 摘要块
const f=Buffer.alloc(b.length+12);f.writeInt32LE(b.length+8,0),f.writeInt32LE(259,4),f.writeInt32LE(b.length,8),b.copy(f,12);const g={len:f.length,buffer:f// 证书块
},h=Buffer.alloc(e.length+4);h.writeInt32LE(e.length,0),e.copy(h,4);const i={len:h.length,buffer:h// 签名数据
},j={len:12,digests:{size:0,data:[]},certs:{size:0,data:[]},additional:0};j.digests.data.push(g),j.digests.size+=g.len,j.len+=g.len,j.certs.data.push(i),j.certs.size+=i.len,j.len+=i.len;// 将public.pem转化为der
const k=Buffer.from(_signature.default.Base64.unarmor(d)),l={len:16+k.length,size:12+k.length,signdata:{size:0,buffer:null},signatures:{size:0,data:[]},pubkey:{size:k.length,buffer:k}};l.signdata.buffer=makeSignDataBuffer(j),l.signdata.size=j.len,l.size+=j.len,l.len+=j.len;// 生成签名
const m=_crypto.default.createSign("RSA-SHA256");m.update(l.signdata.buffer);const n=m.sign(c),o={len:n.length+12,size:n.length+8,id:259,buffer:n};l.signatures.data.push(o),l.signatures.size+=o.len,l.size+=o.len,l.len+=o.len;const p={len:4,size:0,data:[]};p.data.push(l),p.size+=l.len,p.len+=l.len;// 生成key-value
const q={len:p.len+12,size:p.len+4,id:16777473,value:p},r={len:32,size:24,data:[]};// 添加文件列表hash kvblock
if(r.data.push(q),r.size+=q.len,r.len+=q.len,a.files){const b=signFiles(a.files,c);if(b){const a={len:4,size:0,data:[]};a.data.push(b),a.size+=b.length,a.len+=b.length;const c={len:a.len+12,size:a.len+4,id:16777729,value:a};r.data.push(c),r.size+=c.len,r.len+=c.len}}return r}/**
 *
 * @param block
 */function makeSignDataBuffer(a){const b=Buffer.alloc(a.len);let c=0;return b.writeInt32LE(a.digests.size,c),c+=4,a.digests.data.forEach(a=>{a.buffer.copy(b,c),c+=a.len}),b.writeInt32LE(a.certs.size,c),c+=4,a.certs.data.forEach(a=>{a.buffer.copy(b,c),c+=a.len}),b.writeInt32LE(a.additional,c),b}/**
 *
 * @param file
 */const SigMagic="RPK Sig Block 42";function saveSignChunk(a){const b=Buffer.alloc(a.len);let c=0;// 大小
b.writeInt32LE(a.size,c),c+=4,b.writeInt32LE(0,c),c+=4,a.data.forEach(a=>{b.writeInt32LE(a.size,c),c+=4,b.writeInt32LE(0,c),c+=4,b.writeInt32LE(a.id,c),c+=4,b.writeInt32LE(a.value.size,c),c+=4,16777473===a.id?a.value.data.forEach(a=>{b.writeInt32LE(a.size,c),c+=4,b.writeInt32LE(a.signdata.size,c),c+=4,a.signdata.buffer.copy(b,c),c+=a.signdata.buffer.length,b.writeInt32LE(a.signatures.size,c),c+=4,a.signatures.data.forEach(a=>{b.writeInt32LE(a.size,c),c+=4,b.writeInt32LE(a.id,c),c+=4,b.writeInt32LE(a.buffer.length,c),c+=4,a.buffer.copy(b,c),c+=a.buffer.length}),b.writeInt32LE(a.pubkey.size,c),c+=4,a.pubkey.buffer.copy(b,c),c+=a.pubkey.buffer.length}):16777729===a.id&&a.value.data.forEach(a=>{a.copy(b,c),c+=a.length})}),b.writeInt32LE(a.size,c),c+=4,b.writeInt32LE(0,c),c+=4;// 魔法值
const d=Buffer.from(SigMagic);return d.copy(b,c),b}/**
 *
 * @param file
 */function makeSignFile(a){// 提取文件名
const b=_path.default.extname(a),c=_path.default.dirname(a),d=_path.default.basename(a,b);return _path.default.join(c,d+".signed"+b)}/**
 * 对整个chunk签名
 * @param buf
 * @param chunks
 * @return 返回签名后的文件buffer
 */function saveChunk(a,b){// 创建新buffer
const c=Buffer.alloc(a.length+b.signchunk.length);let d=0;const e=b.sections;// 拷贝header
return a.copy(c,d,e.header.startIndex,e.header.startIndex+e.header.len),d+=e.header.len,b.signchunk.copy(c,d),d+=b.signchunk.length,a.copy(c,d,e.central.startIndex,e.central.startIndex+e.central.len),d+=e.central.len,a.writeInt32LE(e.central.startIndex+b.signchunk.length,e.footer.startIndex+16),a.copy(c,d,e.footer.startIndex,e.footer.startIndex+e.footer.len),d+=e.footer.len,c}/**
 * 加签名文件
 * @param filepath
 * @param prikey
 * @param pubkey
 * @param output
 */function signFiles(a,b,c){const d={len:8,size:4,digests:[],sign:null// 生成hash块
};// 写入文件 若没有output 返回文件buf
return a.forEach(a=>{// name hash
const b=_signature.default.CRC32.digest(a.name),c=6+a.hash.length,e=Buffer.alloc(c);// 计算大小
let f=0;e.writeInt32LE(b,f),f+=4,e.writeInt16LE(a.hash.length,f),f+=2,a.hash.copy(e,f),f+=a.hash.length,d.digests.push(e),d.size+=c,d.len+=c}),signDigestChunk(d,b),saveDigestChunk(d,c)}/**
 *
 * @param chunk
 * @param prikey
 */function signDigestChunk(a,b){const c=Buffer.alloc(a.size);let d=0;c.writeInt32LE(259,d),d+=4,a.digests.forEach(a=>{a.copy(c,d),d+=a.length}),a.digests=c.slice();// 生成签名
const e=_crypto.default.createSign("RSA-SHA256");e.update(c);const f=e.sign(b);a.sign={len:12+f.length,size:8+f.length,id:259,data:f},a.len+=a.sign.len}/**
 *
 * @param chunk
 * @param output
 */function saveDigestChunk(a,b){// 创建新buffer
const c=Buffer.alloc(a.len);let d=0;return c.writeInt32LE(a.size,d),d+=4,a.digests.copy(c,d),d+=a.digests.length,c.writeInt32LE(a.sign.size,d),d+=4,c.writeInt32LE(a.sign.id,d),d+=4,c.writeInt32LE(a.sign.data.length,d),d+=4,a.sign.data.copy(c,d),d+=a.sign.data.length,b&&_cliSharedUtils.fs.writeFileSync(b,c),c}
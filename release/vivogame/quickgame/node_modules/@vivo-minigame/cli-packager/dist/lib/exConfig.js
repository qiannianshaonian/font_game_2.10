"use strict";var _interopRequireWildcard=require("@babel/runtime-corejs2/helpers/interopRequireWildcard"),_interopRequireDefault=require("@babel/runtime-corejs2/helpers/interopRequireDefault"),_Object$defineProperty=require("@babel/runtime-corejs2/core-js/object/define-property");_Object$defineProperty(exports,"__esModule",{value:!0}),exports.default=exConfig;var _fs=_interopRequireDefault(require("fs")),_path=_interopRequireDefault(require("path")),_copyWebpackPlugin=_interopRequireDefault(require("copy-webpack-plugin")),_cliSharedUtils=require("@vivo-minigame/cli-shared-utils"),paths=_interopRequireWildcard(require("./paths"));/**
 * 获取小游戏工程目录的minigame.config.js的配置
 * @param {Object} webpackConfig webpack的配置文件
 * @param {Object} options 提供一些参数
 * @param {String} options.context   小游戏工程目录
 * @param {String} options.src 小游戏工程src目录
 * @param {String} options.build 小游戏工程的编译目录
 */function exConfig(a,b){// 如果小游戏工程目录存在minigame.config.js，就以此为准，没有再判断webpack.config.js
if(_fs.default.existsSync(paths.PROJECT_CONFIG))try{const{externals:c=[],copyFile:d=[]}=require(paths.PROJECT_CONFIG)(b),f=a.externals||{},g=c.map(a=>(f[a.module_name]=`commonjs ${a.module_path}`,{from:_path.default.join(b.context,a.module_from),to:_path.default.join(b.build,a.module_path)}));g.length&&(a.externals=f,a.plugins.push(new _copyWebpackPlugin.default(g)));// 复制文件到build的逻辑，没有被代码引入，但是打包需要打的文件路径
const h=d.map(a=>({from:_path.default.join(b.context,a.module_from),to:_path.default.join(b.build,a.module_path)}));h.length&&a.plugins.push(new _copyWebpackPlugin.default(h))}catch(a){(0,_cliSharedUtils.warn)(a)}else if(_fs.default.existsSync(paths.PROJECT_WEBPACK_CONFIG))try{require(paths.PROJECT_WEBPACK_CONFIG).postHook(a,b)}catch(a){(0,_cliSharedUtils.warn)(a)}}
"use strict";var _interopRequireDefault=require("@babel/runtime-corejs2/helpers/interopRequireDefault"),_Object$defineProperty=require("@babel/runtime-corejs2/core-js/object/define-property");_Object$defineProperty(exports,"__esModule",{value:!0}),exports.default=rpk;var _stringify=_interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify")),_path=_interopRequireDefault(require("path")),_jszip=_interopRequireDefault(require("jszip")),_crypto=_interopRequireDefault(require("crypto")),_cliSharedUtils=require("@vivo-minigame/cli-shared-utils"),_bundle=require("./bundle"),_constanst=require("./constanst");// 文件摘要包（zip 文件）
const DIGEST_ZIP_PATH="META-INF/CERT",COMPRESS_OPTS={type:"nodebuffer",compression:"DEFLATE",compressionOptions:{level:9}// 获取buf的hash
};// 压缩参数，设置输出 buffer，以便对 buffer 进行操作
function getBufferDigest(a){const b=_crypto.default.createHash("SHA256");return b.update(a),b.digest()}/**
 * 返回摘要文件签名buff d
 * @param {} fileHashObj - 文件资源列表和对应hash
 * @param {Buffer} privatekey - 私钥文件 buffer
 * @param {Buffer} certificate - 证书文件 buffer
 * @returns {Object} signedDigestBuf - 摘要文件签名buff
 */async function signZipResourcesMeta(a,b,c){// ZIP元文件
const d=new _jszip.default;d.file("hash.json",(0,_stringify.default)({algorithm:"SHA-256",digests:a}));const e=await d.generateAsync(COMPRESS_OPTS),f={name:"hash.json",hash:getBufferDigest(e)};return(0,_bundle.signZip)(e,[f],b,c)}/**
 * 对文件进行重新 排序
 * 第一位 入口文件 第二位 js文件 第三位 manifest（读取到这个文件引擎会执行js）
 * 第四位 icon和防沉迷页面图片 第五位 游戏的资源文件
 * @param {Array(String)} res 文件路径数组
 * @param {Object} manifest 小游戏配置文件
 */function sortAgain(a,b){const c=["main.js","game.js"],d=[],e=[],f=[b&&b.icon.substr(1),b&&b.homePage&&b.homePage.substr(1)],g=[],h=["manifest.json"],i=[],j=[];if(!a)return[];// 将输入数组深拷贝，避免源数据被修改，执行后续操作时出问题
const k=JSON.parse((0,_stringify.default)(a));for(let l=k.length-1;0<=l;l--){const a=k[l],b=_path.default.extname(a);-1<c.indexOf(a)?(d.push(a),k.splice(l,1)):".js"===b?(e.push(a),k.splice(l,1)):-1<h.indexOf(a)?(i.push(a),k.splice(l,1)):-1<f.indexOf(a)?(g.push(a),k.splice(l,1)):j.push(a)}return d.concat(e,i,g,j)}/**
 * 打rpk包
 * @param {String} name rpk包的文件名
 * @param {Array(String)} buildReses rpk对应的资源路径
 * @param {String} pathFrom 打包rpk到何处
 * @param {String} pathTo 打包rpk到何处
 * @param {Object} signFile 签名文件信息
 * @param {Boolean} isStreamPack 是否开启流式打包
 * @param {Object} manifest 小游戏配置文件
 */async function rpk(a,b,c,d,e,f,g){_cliSharedUtils.fs.ensureDirSync(d),(0,_cliSharedUtils.info)(`${_constanst.LOG_TITLE}开始压缩:${a} from:${c}`);const h=_path.default.join(d,`bundle.${Math.random()}.zip`),i=new _jszip.default,j={},k=[],l=_cliSharedUtils.fs.readFileSync(e.privatekey),m=_cliSharedUtils.fs.readFileSync(e.certificate),n=sortAgain(b,g);if(n.forEach(a=>{const b=_path.default.join(c,a),d=getBufferDigest(_cliSharedUtils.fs.readFileSync(b));j[a]=d.toString("hex"),k.push({name:a,hash:d})}),f){// 添加流式下载逻辑，摘要信息打包
const a=await signZipResourcesMeta(j,l,m,d);//   这个地方是吧 hash.json 打进CERT文件
i.file(DIGEST_ZIP_PATH,a),k.push({name:DIGEST_ZIP_PATH,hash:getBufferDigest(a)})}n.forEach(a=>{const b=_path.default.join(c,a);i.file(a,_cliSharedUtils.fs.createReadStream(b))});const o=await i.generateAsync(COMPRESS_OPTS);_cliSharedUtils.fs.outputFileSync(h,o),(0,_bundle.signZip)(o,k,l,m,_path.default.join(d,`${a}`)),_cliSharedUtils.fs.removeSync(h),(0,_cliSharedUtils.info)(`${_constanst.LOG_TITLE}压缩完成:${a}`)}
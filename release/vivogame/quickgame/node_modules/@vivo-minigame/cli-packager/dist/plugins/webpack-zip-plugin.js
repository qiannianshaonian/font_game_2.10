"use strict";var _interopRequireWildcard=require("@babel/runtime-corejs2/helpers/interopRequireWildcard"),_interopRequireDefault=require("@babel/runtime-corejs2/helpers/interopRequireDefault"),_Object$defineProperty=require("@babel/runtime-corejs2/core-js/object/define-property");_Object$defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _promise=_interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise")),_path=_interopRequireDefault(require("path")),_cliSharedUtils=require("@vivo-minigame/cli-shared-utils"),paths=_interopRequireWildcard(require("../lib/paths")),_constanst=require("../lib/constanst"),_readdir=_interopRequireDefault(require("../lib/readdir")),_rpk=_interopRequireDefault(require("../lib/rpk")),_rpkPlugin=_interopRequireDefault(require("../lib/rpkPlugin"));// 签名文件
const signFiles={debug:{privatekey:paths.DEBUG_PRIVATE_KEY,certificate:paths.DEBUG_CERTIFICATE},release:{privatekey:paths.RELEASE_PRIVATE_KEY,certificate:paths.RELEASE_CERTIFICATE}// 在build里面获取 除去插件包的全部文件
};function getLeftFiles(a,b){const c=[];for(let d=a.length-1;0<=d;d--){const e=a[d],f=_path.default.extname(b);""===f&&0>e.indexOf(b)&&c.push(a[d])}return c}// 打插件包
function pluginRpk(a,b,c,d){// 获取插件包文件列表和除去插件包的文件列表 和全部文件列表（打出兼容包）
const e=getLeftFiles(a,b),f=(0,_rpkPlugin.default)(`${b}.rpk`,b,paths.TEMP),g=(0,_rpk.default)(`${_constanst.MAIN}${_constanst.RPK}`,e,paths.BUILD,paths.TEMP,c,d);// 有插件包
return[f,g]}class ZipWebpackPlugin{constructor(a){this.options=a}apply(a){const{isRelease:b,packageName:c,singlePackage:d,subpackages:e,pluginPath:f,isStreamPack:g,manifest:h,buildType:i}=this.options;/**
     * 获取打原整包的配置
     * @param {Boolean} isRelease 是否是release模式
     * @param {String} packageName 包名
     * @param {Boolean} singlePackage 是否是打原整包
     * @param {Array} subpackages 分包配置
     * @param {String} pluginPath 插件包路径
     * @param {Boolean} isStreamPack 是否开启流式打包
     * @param {Object} manifest 小游戏配置文件
     * @param {String} buildType 小游戏构建类型
     */a.hooks.afterEmit.tapPromise("ZipWebpackPlugin",()=>{// 编译完成开始打包，打包前先校验签名文件是否存在
const a=signFiles[b?"release":"debug"];// debug包的后缀 .rpk  release包的后缀 .signed.rpk
// buildType 默认值为release
let j=_constanst.RPK_SIGNED,k=_constanst.RPK;i&&"release"!==i&&(j=`.${i}${_constanst.RPK_SIGNED}`,k=`.${i}${_constanst.RPK}`);const l=b?j:k;// console.log(123123)
// console.log(ext)
if(!_cliSharedUtils.fs.existsSync(a.privatekey))throw new Error(`${_constanst.LOG_TITLE}缺少私钥文件, 打包失败: ${a.privatekey}`);if(!_cliSharedUtils.fs.existsSync(a.certificate))throw new Error(`${_constanst.LOG_TITLE}缺少证书文件, 打包失败: ${a.certificate}`);return new _promise.default(b=>{(0,_cliSharedUtils.info)(`${_constanst.LOG_TITLE}${d?"\u539F\u6574\u5305\u7F16\u8BD1\u5B8C\u6210\uFF0C\u5F00\u59CB\u751F\u6210\u539F\u6574\u5305":"\u5206\u5305\u7F16\u8BD1\u5B8C\u6210\uFF0C\u5F00\u59CB\u751F\u6210\u5206\u5305"}`);// 遍历出build目录所有文件
const i=(0,_readdir.default)(paths.BUILD);// 如果是打原整包
if(!d){// 如果存在分包，那么就打出各个分包，并和原整包一起再打一个rpk，到dist目录
const d=[];// 根据分包配置，找到各个包对应的资源。执行如下操作后，files中剩下的即为主包的资源
e.forEach(({name:a,root:b})=>{const c=[];for(let d=i.length-1;0<=d;d--){const a=i[d],e=_path.default.extname(b);""===e&&0===a.indexOf(b)?c.push(i.splice(d,1)[0]):""!==e&&(a===b||`${b}.map`===a)&&c.push(i.splice(d,1)[0])}d.push({name:a,matchFiles:c})});// 打各个分包
const j=d.map(({name:b,matchFiles:c})=>(0,_rpk.default)(`${b}${_constanst.RPK}`,c,paths.BUILD,paths.TEMP,a,g));let k;// 分包都打好后，连原整包一起打一个整包
k=f?pluginRpk(i,f,a,g):[(0,_rpk.default)(`${_constanst.MAIN}${_constanst.RPK}`,i,paths.BUILD,paths.TEMP,a,g,h)],_promise.default.all([...j,...k]).then(function(){// isStreamPack 写死为false，rpk包再打整体包暂时不需要流式打包
(0,_rpk.default)(`${c}${l}`,(0,_readdir.default)(paths.TEMP),paths.TEMP,paths.DIST,a,!1).then(()=>{b()})})}else// 插件true 分包false
if(f&&0===e.length){// 原整包的打包
const d=[(0,_rpk.default)(`${c}${_constanst.RPK}`,i,paths.BUILD,paths.TEMP,a,g,h)],e=pluginRpk(i,f,a,g);// 插件包不传manifest 这个主要是将icon和homePage提前加载的
_promise.default.all([...e,...d]).then(function(){(0,_cliSharedUtils.info)(`${_constanst.LOG_TITLE}插件包打包完成，开始生成总包...`),(0,_rpk.default)(`${c}${l}`,(0,_readdir.default)(paths.TEMP),paths.TEMP,paths.DIST,a,!1).then(()=>{b()})})}else// 插件false 分包false
// 打原整包到temp目录 有插件包的也走这个逻辑，因为需要打个兼容的包
(0,_rpk.default)(`${c}${_constanst.RPK}`,i,paths.BUILD,paths.TEMP,a,g,h).then(b)})})}}var _default=ZipWebpackPlugin;exports.default=_default;
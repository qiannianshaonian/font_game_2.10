"use strict";var _interopRequireDefault=require("@babel/runtime-corejs2/helpers/interopRequireDefault"),_Object$defineProperty=require("@babel/runtime-corejs2/core-js/object/define-property");_Object$defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _from=_interopRequireDefault(require("@babel/runtime-corejs2/core-js/array/from")),_stringify=_interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify")),_map=_interopRequireDefault(require("@babel/runtime-corejs2/core-js/map")),_adbDevicesEmitter=_interopRequireDefault(require("adb-devices-emitter")),_adbCommander=_interopRequireDefault(require("adb-commander")),_recordClient=require("../record-client.js"),_debuglog=_interopRequireDefault(require("./debuglog"));/**
 * Copyright (C) 2017, hapjs.org. All rights reserved.
 */const REMOTE_REVERSE_PORT=12306,REMOTE_UP_FORWARD_PORT=39517;/**
 * ADB Modules
 */class ADBModule{/**
   * ADBModule constructor
   * @param option
   * @param option.localReversePort  {number} adb reverse命令使用的端口
   */constructor(a){// 当前连接的设备列表 sn: { upForwardPortPair:[localPort, remotePort], wsPortPair[localPort, remotePort] }
// 用来记录所有当前连接和已拔出的设备列表
// 记录localUpForwardPort(自增)的端口号, 初始值等于REMOTE_UP_FORWARD_PORT
this.option=a,this.currentDeviceMap=new _map.default,this.cachedDeviceMap=new _map.default,this.DEBUG=(process.env.NODE_DEBUG||"").split(",").includes("adb"),this._localUpForwardPort=REMOTE_UP_FORWARD_PORT,this.commander=_adbCommander.default,this.devicesEmitter=_adbDevicesEmitter.default,this._lastPromise=null,this.emulators=new _map.default,this.init()}/**
   * 注册事件， 开始查询设备
   */init(){(0,_debuglog.default)(`init(): start`),this.devicesEmitter.addEventListener("deviceAdded",a=>{this._listen(a,this.onDeviceAdded.bind(this))}),this.devicesEmitter.addEventListener("deviceRemoved",a=>{this._listen(a,this.onDeviceRemoved.bind(this))}),this.devicesEmitter.start()}/**
   * 确保队列式的调用顺序
   * @private
   */_listen(a,b){this._lastPromise=this._lastPromise?this._lastPromise.then(()=>b(a),()=>b(a)):b(a)}/**
   * 取得一个_localUpForwardPort端口数字
   * @private
   */_getNextLocalForwardPort(){return this._localUpForwardPort++}/**
   * 处理每个新增设备
   * @desc
   * 为每一个设备执行以下操作：
   * 1. adb reverse tcp:${localReversePort} tcp:REMOTE_REVERSE_PORT,
   * 2. adb forward tcp:${localUpForwardPort} tcp:REMOTE_UP_FORWARD_PORT;
   * 3. 如果cachedDeviceList中存在当前新增设备, 且状态为已断开, 检查该设备是否
   * 已有wsForwardPort端口记录信息, 有则执行adb forward tcp:${wsPair[0]} tcp:${wsPair[1]};
   * 4. 为currentList中新增当前设备;
   * @param event
   * @param event.sn 设备序列号
   */async onDeviceAdded(a){const{sn:b}=a;console.info(`### App Server ### 手机设备(${b})被连入`);const{result:c}=await this.commander.getProp(b);c&&this.emulators.set(c.trim(),b);const d=this.option.localReversePort,e=await this.establishADBProxyLink("reverse",[b,d,REMOTE_REVERSE_PORT]);// 建立reverse设定
if(e.err)return void console.error(`### App Server ### onDeviceAdded(): (${b})建立adb reverse失败(local port: ${d}, remote port: ${REMOTE_REVERSE_PORT})`);// 检查cachedDeviceList中的设备状况
let f=this.cachedDeviceMap.get(b);(0,_debuglog.default)(`onDeviceAdded():(${b})\ncachedDevice:\t${(0,_stringify.default)(f)}\ncachedDeviceList:\t${(0,_stringify.default)((0,_from.default)(this.cachedDeviceMap.entries()))}`),f&&f.upForwardPortPair||(f={upForwardPortPair:[this._getNextLocalForwardPort(),REMOTE_UP_FORWARD_PORT]});const g=await this.establishADBProxyLink("forward",[b].concat(f.upForwardPortPair));if(g.err)return void console.error(`### App Server ### onDeviceAdded(): (${b})建立adb forward失败(local port: ${f.upForwardPortPair[0]}, remote port: ${f.upForwardPortPair[1]}) `);// 如果有记录的调试端口 为调试web socket建立forward
if(f.wsPortPair){const a=await this.establishADBProxyLink("forward",[b,f.wsPortPair[0],f.wsPortPair[1]]);a.err&&(console.warn(`### App Server ### onDeviceAdded():(${b}) 建立adb forward失败(local port: ${f.wsPortPair[0]}, remote port: ${f.wsPortPair[1]})`),f.wsPortPair=void 0)}// 记录当前设备
// 记录发送update http请求需要的ip和端口
this.currentDeviceMap.set(b,f),this.cachedDeviceMap.set(b,f),await this._writeClientLogFile({sn:b,ip:`127.0.0.1`,port:f.upForwardPortPair[0]}),(0,_debuglog.default)(`onDeviceAdded():(${b}) end`)}/**
   * 移除设备事件
   */async onDeviceRemoved(a){const{sn:b}=a;console.info(`### App Server ### 手机设备(${b})被拔出`),this.currentDeviceMap.delete(b),this.DEBUG&&((0,_debuglog.default)(`deviceRemoved():(${b}) cachedDeviceList: ${(0,_stringify.default)((0,_from.default)(this.cachedDeviceMap.entries()))}`),await this.commander.print(`adb -s ${b} reverse --list`),await this.commander.print(`adb -s ${b} forward --list`)),await this._removeItemFromClientLogFile(b),(0,_debuglog.default)(`deviceRemoved():(${b}) end`)}/**
   * 记录一条端口映射条目
   */async _writeClientLogFile(a){try{(0,_recordClient.recordClient)(_recordClient.clientRecordPath,a,a=>{(0,_debuglog.default)(a)})}catch(a){console.error(`### App Server ### writeClientLogFile(): 写入client.json文件出错: ${a.message}`)}}/**
   * 从端口映射记录文件中移除一个条目
   */async _removeItemFromClientLogFile(a){try{(0,_recordClient.removeClientBySn)(_recordClient.clientRecordPath,a,a=>{(0,_debuglog.default)(a)})}catch(a){console.error(`### App Server ### _removeItemFromClientLogFile(): 移除client.json设备信息出错： ${a.message}`)}}/**
   * 建立Websocket连接的端口映射
   * @param sn 设备序列号
   * @param remoteWsPort Websocket连接的远程端口号
   * @returns {Promise.<{ localWsPort } | { err }>}
   */async forwardForWsChannel(a,b){let c=this.currentDeviceMap.get(a);// 暂时localWsPort与remoteWsPort一样;
const d=b,e=this.option.localReversePort;if(!c){const b=this.emulators.get(a);console.warn(`### App Server ### 通过（${a}）查找到设备${b}`),c=this.currentDeviceMap.get(b),c&&(a=b)}if(!c)return console.error(`### App Server ### 获取(${a})设备信息失败`),{localWsPort:d,localReversePort:e};const f=c.wsPortPair;// 若之前不存在端口， 说明是第一次连接，否则可以不必设定
if(f&&f[0]===d&&f[1]===b)return{localWsPort:d,localReversePort:e};const{err:g}=await this.establishADBProxyLink("forward",[a,d,b]);return g?(console.error(`### AppApp Server ### forwardForWsChannel(): 创建WebSocket端口映射失败`),c.wsPortPair=void 0,{err:g}):(c.wsPortPair=[d,b],{localWsPort:d,localReversePort:e})}/**
   * 建立adb reverse/forward通道
   * @param type {string} "reverse"|"forward"
   * @param args {array}  建立reverse/forward通道所需的参数. e.g. [sn, localPort, devicePort]
   */async establishADBProxyLink(a,b){const c=await this.commander[a](...b);return this.DEBUG&&((0,_debuglog.default)(`establishADBReverseLink(): (${b[0]}) adb ${a} setup result: ${(0,_stringify.default)(c)}`),await this.commander.print(`adb -s ${b[0]} ${a} --list`)),c}}var _default=ADBModule;exports.default=_default;